<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>MOOSE Classes' Built-in Documentation</title>
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1"/>
<meta name="title" content="MOOSE Classes' Built-in Documentation"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="2012-10-04 16:27:18 IST"/>
<meta name="author" content=""/>
<meta name="description" content=""/>
<meta name="keywords" content=""/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  html { font-family: Times, serif; font-size: 12pt; }
  .title  { text-align: center; }
  .todo   { color: red; }
  .done   { color: green; }
  .tag    { background-color: #add8e6; font-weight:normal }
  .target { }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  {margin-left:auto; margin-right:0px;  text-align:right;}
  .left   {margin-left:0px;  margin-right:auto; text-align:left;}
  .center {margin-left:auto; margin-right:auto; text-align:center;}
  p.verse { margin-left: 3% }
  pre {
	border: 1pt solid #AEBDCC;
	background-color: #F3F5F7;
	padding: 5pt;
	font-family: courier, monospace;
        font-size: 90%;
        overflow:auto;
  }
  table { border-collapse: collapse; }
  td, th { vertical-align: top;  }
  th.right  { text-align:center;  }
  th.left   { text-align:center;   }
  th.center { text-align:center; }
  td.right  { text-align:right;  }
  td.left   { text-align:left;   }
  td.center { text-align:center; }
  dt { font-weight: bold; }
  div.figure { padding: 0.5em; }
  div.figure p { text-align: center; }
  div.inlinetask {
    padding:10px;
    border:2px solid gray;
    margin:10px;
    background: #ffffcc;
  }
  textarea { overflow-x: auto; }
  .linenr { font-size:smaller }
  .code-highlighted {background-color:#ffff00;}
  .org-info-js_info-navigation { border-style:none; }
  #org-info-js_console-label { font-size:10px; font-weight:bold;
                               white-space:nowrap; }
  .org-info-js_search-highlight {background-color:#ffff00; color:#000000;
                                 font-weight:bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>

</head>
<body>

<div id="preamble">

</div>

<div id="content">
<h1 class="title">MOOSE Classes' Built-in Documentation</h1>

<p><i>automatically extracted on 2012-10-04T16:26:57.313801</i>
</p>


<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1 Annotator</a></li>
<li><a href="#sec-2">2 Arith</a></li>
<li><a href="#sec-3">3 Boundary</a></li>
<li><a href="#sec-4">4 BufPool</a></li>
<li><a href="#sec-5">5 CaConc</a></li>
<li><a href="#sec-6">6 ChanBase</a></li>
<li><a href="#sec-7">7 ChemMesh</a></li>
<li><a href="#sec-8">8 Cinfo</a></li>
<li><a href="#sec-9">9 Clock</a></li>
<li><a href="#sec-10">10 Compartment</a></li>
<li><a href="#sec-11">11 CplxEnzBase</a></li>
<li><a href="#sec-12">12 CubeMesh</a></li>
<li><a href="#sec-13">13 CylMesh</a></li>
<li><a href="#sec-14">14 CylPanel</a></li>
<li><a href="#sec-15">15 DiagonalMsg</a></li>
<li><a href="#sec-16">16 DiffAmp</a></li>
<li><a href="#sec-17">17 DiskPanel</a></li>
<li><a href="#sec-18">18 Enz</a></li>
<li><a href="#sec-19">19 EnzBase</a></li>
<li><a href="#sec-20">20 Finfo</a></li>
<li><a href="#sec-21">21 FuncPool</a></li>
<li><a href="#sec-22">22 GHK</a></li>
<li><a href="#sec-23">23 Geometry</a></li>
<li><a href="#sec-24">24 Group</a></li>
<li><a href="#sec-25">25 GslIntegrator</a></li>
<li><a href="#sec-26">26 GssaStoich</a></li>
<li><a href="#sec-27">27 HDF5DataWriter</a></li>
<li><a href="#sec-28">28 HDF5WriterBase</a></li>
<li><a href="#sec-29">29 HHChannel</a></li>
<li><a href="#sec-30">30 HHChannel2D</a></li>
<li><a href="#sec-31">31 HHGate</a></li>
<li><a href="#sec-32">32 HHGate2D</a></li>
<li><a href="#sec-33">33 HSolve</a></li>
<li><a href="#sec-34">34 HemispherePanel</a></li>
<li><a href="#sec-35">35 IntFire</a></li>
<li><a href="#sec-36">36 Interpol2D</a></li>
<li><a href="#sec-37">37 IzhikevichNrn</a></li>
<li><a href="#sec-38">38 LeakyIaF</a></li>
<li><a href="#sec-39">39 MMenz</a></li>
<li><a href="#sec-40">40 MarkovChannel</a></li>
<li><a href="#sec-41">41 MarkovGslSolver</a></li>
<li><a href="#sec-42">42 MarkovRateTable</a></li>
<li><a href="#sec-43">43 MarkovSolver</a></li>
<li><a href="#sec-44">44 MarkovSolverBase</a></li>
<li><a href="#sec-45">45 MathFunc</a></li>
<li><a href="#sec-46">46 Mdouble</a></li>
<li><a href="#sec-47">47 MeshEntry</a></li>
<li><a href="#sec-48">48 MgBlock</a></li>
<li><a href="#sec-49">49 Msg</a></li>
<li><a href="#sec-50">50 Mstring</a></li>
<li><a href="#sec-51">51 NMDAChan</a></li>
<li><a href="#sec-52">52 Nernst</a></li>
<li><a href="#sec-53">53 NeuroMesh</a></li>
<li><a href="#sec-54">54 Neuron</a></li>
<li><a href="#sec-55">55 Neutral</a></li>
<li><a href="#sec-56">56 OneToAllMsg</a></li>
<li><a href="#sec-57">57 OneToOneMsg</a></li>
<li><a href="#sec-58">58 PIDController</a></li>
<li><a href="#sec-59">59 Panel</a></li>
<li><a href="#sec-60">60 Pool</a></li>
<li><a href="#sec-61">61 PoolBase</a></li>
<li><a href="#sec-62">62 Port</a></li>
<li><a href="#sec-63">63 PulseGen</a></li>
<li><a href="#sec-64">64 RC</a></li>
<li><a href="#sec-65">65 Reac</a></li>
<li><a href="#sec-66">66 ReacBase</a></li>
<li><a href="#sec-67">67 RectPanel</a></li>
<li><a href="#sec-68">68 ReduceMsg</a></li>
<li><a href="#sec-69">69 Shell</a></li>
<li><a href="#sec-70">70 SimManager</a></li>
<li><a href="#sec-71">71 SingleMsg</a></li>
<li><a href="#sec-72">72 SparseMsg</a></li>
<li><a href="#sec-73">73 Species</a></li>
<li><a href="#sec-74">74 SpherePanel</a></li>
<li><a href="#sec-75">75 SpikeGen</a></li>
<li><a href="#sec-76">76 Stats</a></li>
<li><a href="#sec-77">77 StimulusTable</a></li>
<li><a href="#sec-78">78 Stoich</a></li>
<li><a href="#sec-79">79 SumFunc</a></li>
<li><a href="#sec-80">80 Surface</a></li>
<li><a href="#sec-81">81 SymCompartment</a></li>
<li><a href="#sec-82">82 SynBase</a></li>
<li><a href="#sec-83">83 SynChan</a></li>
<li><a href="#sec-84">84 SynChanBase</a></li>
<li><a href="#sec-85">85 Synapse</a></li>
<li><a href="#sec-86">86 Table</a></li>
<li><a href="#sec-87">87 TableBase</a></li>
<li><a href="#sec-88">88 TableEntry</a></li>
<li><a href="#sec-89">89 Tick</a></li>
<li><a href="#sec-90">90 TriPanel</a></li>
<li><a href="#sec-91">91 VectorTable</a></li>
<li><a href="#sec-92">92 ZombieBufPool</a></li>
<li><a href="#sec-93">93 ZombieCaConc</a></li>
<li><a href="#sec-94">94 ZombieCompartment</a></li>
<li><a href="#sec-95">95 ZombieEnz</a></li>
<li><a href="#sec-96">96 ZombieFuncPool</a></li>
<li><a href="#sec-97">97 ZombieHHChannel</a></li>
<li><a href="#sec-98">98 ZombieMMenz</a></li>
<li><a href="#sec-99">99 ZombiePool</a></li>
<li><a href="#sec-100">100 ZombieReac</a></li>
<li><a href="#sec-101">101 ZombieSumFunc</a></li>
<li><a href="#sec-102">102 testSched</a></li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-3">
<h3 id="sec-1"><span class="section-number-3">1</span> Annotator</h3>
<div class="outline-text-3" id="text-1">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>x:       <i>double</i></dt><dd>
<p>
       x field. Typically display coordinate x
</p></dd>
<dt>y:       <i>double</i></dt><dd>
<p>
       y field. Typically display coordinate y
</p></dd>
<dt>z:       <i>double</i></dt><dd>
<p>
       z field. Typically display coordinate z
</p></dd>
<dt>notes:   <i>string</i></dt><dd>
<p>
       A string to hold some text notes about parent object
</p></dd>
<dt>color:   <i>string</i></dt><dd>
<p>
       A string to hold a text string specifying display color.Can be a regular English color name, or an rgb code rrrgggbbb
</p></dd>
<dt>textColor:       <i>string</i></dt><dd>
<p>
       A string to hold a text string specifying color for text labelthat might be on the display for this object.Can be a regular English color name, or an rgb code rrrgggbbb
</p></dd>
<dt>icon:    <i>string</i></dt><dd>
<p>
       A string to specify icon to use for display
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-2" class="outline-3">
<h3 id="sec-2"><span class="section-number-3">2</span> Arith</h3>
<div class="outline-text-3" id="text-2">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>function:        <i>string</i></dt><dd>
<p>
       Arithmetic function to perform on inputs.
</p></dd>
<dt>outputValue:     <i>double</i></dt><dd>
<p>
       Value of output as computed last timestep.
</p></dd>
<dt>arg1Value:       <i>double</i></dt><dd>
<p>
       Value of arg1 as computed last timestep.
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>output:  <i>double</i></dt><dd>
<p>
       Sends out the computed value
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>arg1:    <i>double</i></dt><dd>
<p>
       Handles argument 1. This just assigns it
</p></dd>
<dt>arg2:    <i>double</i></dt><dd>
<p>
       Handles argument 2. This just assigns it
</p></dd>
<dt>arg3:    <i>double</i></dt><dd>
<p>
       Handles argument 3. This sums in each input, and clears each clock tick.
</p></dd>
<dt>arg1x2:  <i>double,double</i></dt><dd>
<p>
       Store the product of the two arguments in output_
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
<dt>anyValue:        <i>unsigned int,double</i></dt><dd>
<p>
       Value of any of the internal fields, output, arg1, arg2, arg3,as specified by the index argument from 0 to 3.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-3" class="outline-3">
<h3 id="sec-3"><span class="section-number-3">3</span> Boundary</h3>
<div class="outline-text-3" id="text-3">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>reflectivity:    <i>double</i></dt><dd>
<p>
       What happens to a molecule hitting it: bounces, absorbed, diffused?
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>toAdjacent:      <i>void</i></dt><dd>
<p>
       Dummy message going to adjacent compartment.
</p></dd>
<dt>toInside:        <i>void</i></dt><dd>
<p>
       Dummy message going to surrounded compartment.
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>adjacent:        <i>void</i></dt><dd>
<p>
       Dummy message coming from adjacent compartment to current oneImplies that compts are peers: do not surround each other
</p></dd>
<dt>outside: <i>void</i></dt><dd>
<p>
       Dummy message coming from surrounding compartment to this one.Implies that the originating compartment surrounds this one
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-4" class="outline-3">
<h3 id="sec-4"><span class="section-number-3">4</span> BufPool</h3>
<div class="outline-text-3" id="text-4">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>n:       <i>double</i></dt><dd>
<p>
       Number of molecules in pool
</p></dd>
<dt>nInit:   <i>double</i></dt><dd>
<p>
       Initial value of number of molecules in pool
</p></dd>
<dt>diffConst:       <i>double</i></dt><dd>
<p>
       Diffusion constant of molecule
</p></dd>
<dt>conc:    <i>double</i></dt><dd>
<p>
       Concentration of molecules in this pool
</p></dd>
<dt>concInit:        <i>double</i></dt><dd>
<p>
       Initial value of molecular concentration in pool
</p></dd>
<dt>size:    <i>double</i></dt><dd>
<p>
       Size of compartment. Units are SI. Utility field, the actual size info is stored on a volume mesh entry in the parent compartment.This is hooked up by a message. If the message isn'tavailable size is just taken as 1
</p></dd>
<dt>speciesId:       <i>unsigned int</i></dt><dd>
<p>
       Species identifier for this mol pool. Eventually link to ontology.
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>nOut:    <i>double</i></dt><dd>
<p>
       Sends out # of molecules in pool on each timestep
</p></dd>
<dt>requestMolWt:    <i>void</i></dt><dd>
<p>
       Requests Species object for mol wt
</p></dd>
<dt>requestSize:     <i>double</i></dt><dd>
<p>
       Requests Size of pool from matching mesh entry
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>group:   <i>void</i></dt><dd>
<p>
       Handle for grouping. Doesn't do anything.
</p></dd>
<dt>reacDest:        <i>double,double</i></dt><dd>
<p>
       Handles reaction input
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call
</p></dd>
<dt>handleMolWt:     <i>double</i></dt><dd>
<p>
       Separate finfo to assign molWt, and consequently diffusion const.Should only be used in SharedMsg with species.
</p></dd>
<dt>remesh:  <i>double,unsigned int,unsigned int,vector&lt;unsigned int&gt;,vector&lt;double&gt;</i></dt><dd>
<p>
       Handle commands to remesh the pool. This may involve changing the number of pool entries, as well as changing their volumes
</p></dd>
<dt>increment:       <i>double</i></dt><dd>
<p>
       Increments mol numbers by specified amount. Can be +ve or -ve
</p></dd>
<dt>decrement:       <i>double</i></dt><dd>
<p>
       Decrements mol numbers by specified amount. Can be +ve or -ve
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-5" class="outline-3">
<h3 id="sec-5"><span class="section-number-3">5</span> CaConc</h3>
<div class="outline-text-3" id="text-5">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>Ca:      <i>double</i></dt><dd>
<p>
       Calcium concentration.
</p></dd>
<dt>CaBasal: <i>double</i></dt><dd>
<p>
       Basal Calcium concentration.
</p></dd>
<dt>Ca<sub>base</sub>: <i>double</i></dt><dd>
<p>
       Basal Calcium concentration, synonym for CaBasal
</p></dd>
<dt>tau:     <i>double</i></dt><dd>
<p>
       Settling time for Ca concentration
</p></dd>
<dt>B:       <i>double</i></dt><dd>
<p>
       Volume scaling factor
</p></dd>
<dt>thick:   <i>double</i></dt><dd>
<p>
       Thickness of Ca shell.
</p></dd>
<dt>ceiling: <i>double</i></dt><dd>
<p>
       Ceiling value for Ca concentration. If Ca &gt; ceiling, Ca = ceiling. If ceiling &lt;= 0.0, there is no upper limit on Ca concentration value.
</p></dd>
<dt>floor:   <i>double</i></dt><dd>
<p>
       Floor value for Ca concentration. If Ca &lt; floor, Ca = floor
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>concOut: <i>double</i></dt><dd>
<p>
       Concentration of Ca in pool
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call
</p></dd>
<dt>current: <i>double</i></dt><dd>
<p>
       Calcium Ion current, due to be converted to conc.
</p></dd>
<dt>currentFraction: <i>double,double</i></dt><dd>
<p>
       Fraction of total Ion current, that is carried by Ca2+.
</p></dd>
<dt>increase:        <i>double</i></dt><dd>
<p>
       Any input current that increases the concentration.
</p></dd>
<dt>decrease:        <i>double</i></dt><dd>
<p>
       Any input current that decreases the concentration.
</p></dd>
<dt>basal:   <i>double</i></dt><dd>
<p>
       Synonym for assignment of basal conc.
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-6" class="outline-3">
<h3 id="sec-6"><span class="section-number-3">6</span> ChanBase</h3>
<div class="outline-text-3" id="text-6">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>Gbar:    <i>double</i></dt><dd>
<p>
       Maximal channel conductance
</p></dd>
<dt>Ek:      <i>double</i></dt><dd>
<p>
       Reversal potential of channel
</p></dd>
<dt>Gk:      <i>double</i></dt><dd>
<p>
       Channel conductance variable
</p></dd>
<dt>Ik:      <i>double</i></dt><dd>
<p>
       Channel current variable
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>channelOut:      <i>double,double</i></dt><dd>
<p>
       Sends channel variables Gk and Ek to compartment
</p></dd>
<dt>permeability:    <i>double</i></dt><dd>
<p>
       Conductance term going out to GHK object
</p></dd>
<dt>IkOut:   <i>double</i></dt><dd>
<p>
       Channel current. This message typically goes to concenobjects that keep track of ion concentration.
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>Vm:      <i>double</i></dt><dd>
<p>
       Handles Vm message coming in from compartment
</p></dd>
<dt>Vm:      <i>double</i></dt><dd>
<p>
       Handles Vm message coming in from compartment
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-7" class="outline-3">
<h3 id="sec-7"><span class="section-number-3">7</span> ChemMesh</h3>
<div class="outline-text-3" id="text-7">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>size:    <i>double</i></dt><dd>
<p>
       Size of entire chemical domain.Assigning this assumes that the geometry is that of the default mesh, which may not be what you want. If so, usea more specific mesh assignment function.
</p></dd>
<dt>numDimensions:   <i>unsigned int</i></dt><dd>
<p>
       Number of spatial dimensions of this compartment. Usually 3 or 2
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>meshSplit:       <i>double,vector&lt;double&gt;,vector&lt;unsigned int&gt;,vector&lt; vector&lt;unsigned int&gt; &gt;,vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Defines how meshEntries communicate between nodes.Args: oldVol, volListOfAllEntries, localEntryList, outgoingDiffusion[node#][entry#], incomingDiffusion[node#][entry#]This message is meant to go to the SimManager and Stoich.
</p></dd>
<dt>meshStats:       <i>unsigned int,vector&lt;double&gt;</i></dt><dd>
<p>
       Basic statistics for mesh: Total # of entries, and a vector ofunique volumes of voxels
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>buildDefaultMesh:        <i>double,unsigned int</i></dt><dd>
<p>
       Tells ChemMesh derived class to build a default mesh with thespecified size and number of meshEntries.
</p></dd>
<dt>handleRequestMeshStats:  <i>void</i></dt><dd>
<p>
       Handles request from SimManager for mesh stats
</p></dd>
<dt>handleNodeInfo:  <i>unsigned int,unsigned int</i></dt><dd>
<p>
       Tells ChemMesh how many nodes and threads per node it is allowed to use. Triggers a return meshSplit message.
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-8" class="outline-3">
<h3 id="sec-8"><span class="section-number-3">8</span> Cinfo</h3>
<div class="outline-text-3" id="text-8">

<p>   Author:              Upi Bhalla
</p>
<p>   
   Description:         Class information object.
</p>
<p>   
   Name:                Cinfo
</p>
<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>docs:    <i>string</i></dt><dd>
<p>
       Documentation
</p></dd>
<dt>baseClass:       <i>string</i></dt><dd>
<p>
       Name of base class
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-9" class="outline-3">
<h3 id="sec-9"><span class="section-number-3">9</span> Clock</h3>
<div class="outline-text-3" id="text-9">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>runTime: <i>double</i></dt><dd>
<p>
       Duration to run the simulation
</p></dd>
<dt>currentTime:     <i>double</i></dt><dd>
<p>
       Current simulation time
</p></dd>
<dt>nsteps:  <i>unsigned int</i></dt><dd>
<p>
       Number of steps to advance the simulation, in units of the smallest timestep on the clock ticks
</p></dd>
<dt>numTicks:        <i>unsigned int</i></dt><dd>
<p>
       Number of clock ticks
</p></dd>
<dt>currentStep:     <i>unsigned int</i></dt><dd>
<p>
       Current simulation step
</p></dd>
<dt>dts:     <i>vector&lt;double&gt;</i></dt><dd>
<p>
       Utility function returning the dt (timestep) of all ticks.
</p></dd>
<dt>isRunning:       <i>bool</i></dt><dd>
<p>
       Utility function to report if simulation is in progress.
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>childTick:       <i>void</i></dt><dd>
<p>
       Parent of Tick element
</p></dd>
<dt>finished:        <i>void</i></dt><dd>
<p>
       Signal for completion of run
</p></dd>
<dt>ack:     <i>unsigned int,unsigned int</i></dt><dd>
<p>
       Acknowledgement signal for receipt/completion of function.Goes back to Shell on master node
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>start:   <i>double</i></dt><dd>
<p>
       Sets off the simulation for the specified duration
</p></dd>
<dt>step:    <i>unsigned int</i></dt><dd>
<p>
       Sets off the simulation for the specified # of steps
</p></dd>
<dt>stop:    <i>void</i></dt><dd>
<p>
       Halts the simulation, with option to restart seamlessly
</p></dd>
<dt>setupTick:       <i>unsigned int,double</i></dt><dd>
<p>
       Sets up a specific clock tick: args tick#, dt
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Zeroes out all ticks, starts at t = 0
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-10" class="outline-3">
<h3 id="sec-10"><span class="section-number-3">10</span> Compartment</h3>
<div class="outline-text-3" id="text-10">

<p>   Author:              Upi Bhalla
</p>
<p>   
   Description:         Compartment object, for branching neuron models.
</p>
<p>   
   Name:                Compartment
</p>
<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>Vm:      <i>double</i></dt><dd>
<p>
       membrane potential
</p></dd>
<dt>Cm:      <i>double</i></dt><dd>
<p>
       Membrane capacitance
</p></dd>
<dt>Em:      <i>double</i></dt><dd>
<p>
       Resting membrane potential
</p></dd>
<dt>Im:      <i>double</i></dt><dd>
<p>
       Current going through membrane
</p></dd>
<dt>inject:  <i>double</i></dt><dd>
<p>
       Current injection to deliver into compartment
</p></dd>
<dt>initVm:  <i>double</i></dt><dd>
<p>
       Initial value for membrane potential
</p></dd>
<dt>Rm:      <i>double</i></dt><dd>
<p>
       Membrane resistance
</p></dd>
<dt>Ra:      <i>double</i></dt><dd>
<p>
       Axial resistance of compartment
</p></dd>
<dt>diameter:        <i>double</i></dt><dd>
<p>
       Diameter of compartment
</p></dd>
<dt>length:  <i>double</i></dt><dd>
<p>
       Length of compartment
</p></dd>
<dt>x0:      <i>double</i></dt><dd>
<p>
       X coordinate of start of compartment
</p></dd>
<dt>y0:      <i>double</i></dt><dd>
<p>
       Y coordinate of start of compartment
</p></dd>
<dt>z0:      <i>double</i></dt><dd>
<p>
       Z coordinate of start of compartment
</p></dd>
<dt>x:       <i>double</i></dt><dd>
<p>
       x coordinate of end of compartment
</p></dd>
<dt>y:       <i>double</i></dt><dd>
<p>
       y coordinate of end of compartment
</p></dd>
<dt>z:       <i>double</i></dt><dd>
<p>
       z coordinate of end of compartment
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>VmOut:   <i>double</i></dt><dd>
<p>
       Sends out Vm value of compartment on each timestep
</p></dd>
<dt>axialOut:        <i>double</i></dt><dd>
<p>
       Sends out Vm value of compartment to adjacent compartments,on each timestep
</p></dd>
<dt>raxialOut:       <i>double,double</i></dt><dd>
<p>
       Sends out Raxial information on each timestep, fields are Ra and Vm
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>injectMsg:       <i>double</i></dt><dd>
<p>
       The injectMsg corresponds to the INJECT message in the GENESIS compartment. Unlike the 'inject' field, any value assigned by handleInject applies only for a single timestep.So it needs to be updated every dt for a steady (or varying)injection current
</p></dd>
<dt>randInject:      <i>double,double</i></dt><dd>
<p>
       Sends a random injection current to the compartment. Must beupdated each timestep.Arguments to randInject are probability and current.
</p></dd>
<dt>injectMsg:       <i>double</i></dt><dd>
<p>
       The injectMsg corresponds to the INJECT message in the GENESIS compartment. Unlike the 'inject' field, any value assigned by handleInject applies only for a single timestep.So it needs to be updated every dt for a steady (or varying)injection current
</p></dd>
<dt>cable:   <i>void</i></dt><dd>
<p>
       Message for organizing compartments into groups, calledcables. Doesn't do anything.
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles 'process' call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles 'reinit' call
</p></dd>
<dt>initProc:        <i>void</i></dt><dd>
<p>
       Handles Process call for the 'init' phase of the Compartment calculations. These occur as a separate Tick cycle from the regular proc cycle, and should be called before the proc msg.
</p></dd>
<dt>initReinit:      <i>void</i></dt><dd>
<p>
       Handles Reinit call for the 'init' phase of the Compartment calculations.
</p></dd>
<dt>handleChannel:   <i>double,double</i></dt><dd>
<p>
       Handles conductance and Reversal potential arguments from Channel
</p></dd>
<dt>handleRaxial:    <i>double,double</i></dt><dd>
<p>
       Handles Raxial info: arguments are Ra and Vm.
</p></dd>
<dt>handleAxial:     <i>double</i></dt><dd>
<p>
       Handles Axial information. Argument is just Vm.
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-11" class="outline-3">
<h3 id="sec-11"><span class="section-number-3">11</span> CplxEnzBase</h3>
<div class="outline-text-3" id="text-11">

<p>   Author:              Upi Bhalla
</p>
<p>   
   Description::                Base class for mass-action enzymes in which there is an  explicit pool for the enzyme-substrate complex. It models the reaction: E + S &lt;===&gt; E.S -&mdash;&gt; E + P
</p>
<p>   
   Name:                CplxEnzBase
</p>
<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>Km:      <i>double</i></dt><dd>
<p>
       Michaelis-Menten constant in SI conc units (milliMolar)
</p></dd>
<dt>numKm:   <i>double</i></dt><dd>
<p>
       Michaelis-Menten constant in number units, volume dependent
</p></dd>
<dt>kcat:    <i>double</i></dt><dd>
<p>
       Forward rate constant for enzyme, units 1/sec
</p></dd>
<dt>numSubstrates:   <i>unsigned int</i></dt><dd>
<p>
       Number of substrates in this MM reaction. Usually 1.Does not include the enzyme itself
</p></dd>
<dt>k1:      <i>double</i></dt><dd>
<p>
       Forward reaction from enz + sub to complex
</p></dd>
<dt>k2:      <i>double</i></dt><dd>
<p>
       Reverse reaction from complex to enz + sub
</p></dd>
<dt>k3:      <i>double</i></dt><dd>
<p>
       Forward rate constant from complex to product + enz
</p></dd>
<dt>ratio:   <i>double</i></dt><dd>
<p>
       Ratio of k2/k3
</p></dd>
<dt>concK1:  <i>double</i></dt><dd>
<p>
       K1 expressed in concentration (1/millimolar.sec) units
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>toSub:   <i>double,double</i></dt><dd>
<p>
       Sends out increment of molecules on product each timestep
</p></dd>
<dt>toPrd:   <i>double,double</i></dt><dd>
<p>
       Sends out increment of molecules on product each timestep
</p></dd>
<dt>toEnz:   <i>double,double</i></dt><dd>
<p>
       Sends out increment of molecules on product each timestep
</p></dd>
<dt>toCplx:  <i>double,double</i></dt><dd>
<p>
       Sends out increment of molecules on product each timestep
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>enzDest: <i>double</i></dt><dd>
<p>
       Handles # of molecules of Enzyme
</p></dd>
<dt>subDest: <i>double</i></dt><dd>
<p>
       Handles # of molecules of substrate
</p></dd>
<dt>prdDest: <i>double</i></dt><dd>
<p>
       Handles # of molecules of product. Dummy.
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call
</p></dd>
<dt>remesh:  <i>void</i></dt><dd>
<p>
       Tells the MMEnz to recompute its numKm after remeshing
</p></dd>
<dt>enzDest: <i>double</i></dt><dd>
<p>
       Handles # of molecules of Enzyme
</p></dd>
<dt>cplxDest:        <i>double</i></dt><dd>
<p>
       Handles # of molecules of enz-sub complex
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-12" class="outline-3">
<h3 id="sec-12"><span class="section-number-3">12</span> CubeMesh</h3>
<div class="outline-text-3" id="text-12">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>size:    <i>double</i></dt><dd>
<p>
       Size of entire chemical domain.Assigning this assumes that the geometry is that of the default mesh, which may not be what you want. If so, usea more specific mesh assignment function.
</p></dd>
<dt>numDimensions:   <i>unsigned int</i></dt><dd>
<p>
       Number of spatial dimensions of this compartment. Usually 3 or 2
</p></dd>
<dt>isToroid:        <i>bool</i></dt><dd>
<p>
       Flag. True when the mesh should be toroidal, that is,when going beyond the right face brings us around to theleft-most mesh entry, and so on. If we have nx, ny, nzentries, this rule means that the coordinate (x, ny, z)will map onto (x, 0, z). Similarly,(-1, y, z) -&gt; (nx-1, y, z)Default is false
</p></dd>
<dt>preserveNumEntries:      <i>bool</i></dt><dd>
<p>
       Flag. When it is true, the numbers nx, ny, nz remainunchanged when x0, x1, y0, y1, z0, z1 are altered. Thusdx, dy, dz would change instead. When it is false, thendx, dy, dz remain the same and nx, ny, nz are altered.Default is true
</p></dd>
<dt>x0:      <i>double</i></dt><dd>
<p>
       X coord of one end
</p></dd>
<dt>y0:      <i>double</i></dt><dd>
<p>
       Y coord of one end
</p></dd>
<dt>z0:      <i>double</i></dt><dd>
<p>
       Z coord of one end
</p></dd>
<dt>x1:      <i>double</i></dt><dd>
<p>
       X coord of other end
</p></dd>
<dt>y1:      <i>double</i></dt><dd>
<p>
       Y coord of other end
</p></dd>
<dt>z1:      <i>double</i></dt><dd>
<p>
       Z coord of other end
</p></dd>
<dt>dx:      <i>double</i></dt><dd>
<p>
       X size for mesh
</p></dd>
<dt>dy:      <i>double</i></dt><dd>
<p>
       Y size for mesh
</p></dd>
<dt>dz:      <i>double</i></dt><dd>
<p>
       Z size for mesh
</p></dd>
<dt>nx:      <i>unsigned int</i></dt><dd>
<p>
       Number of subdivisions in mesh in X
</p></dd>
<dt>ny:      <i>unsigned int</i></dt><dd>
<p>
       Number of subdivisions in mesh in Y
</p></dd>
<dt>nz:      <i>unsigned int</i></dt><dd>
<p>
       Number of subdivisions in mesh in Z
</p></dd>
<dt>coords:  <i>vector&lt;double&gt;</i></dt><dd>
<p>
       Set all the coords of the cuboid at once. Order is:x0 y0 z0   x1 y1 z1   dx dy dz
</p></dd>
<dt>meshToSpace:     <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array in which each mesh entry stores spatial (cubic) index
</p></dd>
<dt>spaceToMesh:     <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array in which each space index (obtained by linearizing the xyz coords) specifies which meshIndex is present.In many cases the index will store the EMPTY flag if there isno mesh entry at that spatial location
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>meshSplit:       <i>double,vector&lt;double&gt;,vector&lt;unsigned int&gt;,vector&lt; vector&lt;unsigned int&gt; &gt;,vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Defines how meshEntries communicate between nodes.Args: oldVol, volListOfAllEntries, localEntryList, outgoingDiffusion[node#][entry#], incomingDiffusion[node#][entry#]This message is meant to go to the SimManager and Stoich.
</p></dd>
<dt>meshStats:       <i>unsigned int,vector&lt;double&gt;</i></dt><dd>
<p>
       Basic statistics for mesh: Total # of entries, and a vector ofunique volumes of voxels
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>buildDefaultMesh:        <i>double,unsigned int</i></dt><dd>
<p>
       Tells ChemMesh derived class to build a default mesh with thespecified size and number of meshEntries.
</p></dd>
<dt>handleRequestMeshStats:  <i>void</i></dt><dd>
<p>
       Handles request from SimManager for mesh stats
</p></dd>
<dt>handleNodeInfo:  <i>unsigned int,unsigned int</i></dt><dd>
<p>
       Tells ChemMesh how many nodes and threads per node it is allowed to use. Triggers a return meshSplit message.
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-13" class="outline-3">
<h3 id="sec-13"><span class="section-number-3">13</span> CylMesh</h3>
<div class="outline-text-3" id="text-13">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>size:    <i>double</i></dt><dd>
<p>
       Size of entire chemical domain.Assigning this assumes that the geometry is that of the default mesh, which may not be what you want. If so, usea more specific mesh assignment function.
</p></dd>
<dt>numDimensions:   <i>unsigned int</i></dt><dd>
<p>
       Number of spatial dimensions of this compartment. Usually 3 or 2
</p></dd>
<dt>x0:      <i>double</i></dt><dd>
<p>
       x coord of one end
</p></dd>
<dt>y0:      <i>double</i></dt><dd>
<p>
       y coord of one end
</p></dd>
<dt>z0:      <i>double</i></dt><dd>
<p>
       z coord of one end
</p></dd>
<dt>r0:      <i>double</i></dt><dd>
<p>
       Radius of one end
</p></dd>
<dt>x1:      <i>double</i></dt><dd>
<p>
       x coord of other end
</p></dd>
<dt>y1:      <i>double</i></dt><dd>
<p>
       y coord of other end
</p></dd>
<dt>z1:      <i>double</i></dt><dd>
<p>
       z coord of other end
</p></dd>
<dt>r1:      <i>double</i></dt><dd>
<p>
       Radius of other end
</p></dd>
<dt>lambda:  <i>double</i></dt><dd>
<p>
       Length constant to use for subdivisionsThe system will attempt to subdivide using compartments oflength lambda on average. If the cylinder has different enddiameters r0 and r1, it will scale to smaller lengthsfor the smaller diameter end and vice versa.Once the value is set it will recompute lambda as totLength/numEntries
</p></dd>
<dt>coords:  <i>vector&lt;double&gt;</i></dt><dd>
<p>
       All the coords as a single vector: x0 y0 z0  x1 y1 z1  r0 r1 lambda
</p></dd>
<dt>totLength:       <i>double</i></dt><dd>
<p>
       Total length of cylinder
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>meshSplit:       <i>double,vector&lt;double&gt;,vector&lt;unsigned int&gt;,vector&lt; vector&lt;unsigned int&gt; &gt;,vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Defines how meshEntries communicate between nodes.Args: oldVol, volListOfAllEntries, localEntryList, outgoingDiffusion[node#][entry#], incomingDiffusion[node#][entry#]This message is meant to go to the SimManager and Stoich.
</p></dd>
<dt>meshStats:       <i>unsigned int,vector&lt;double&gt;</i></dt><dd>
<p>
       Basic statistics for mesh: Total # of entries, and a vector ofunique volumes of voxels
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>buildDefaultMesh:        <i>double,unsigned int</i></dt><dd>
<p>
       Tells ChemMesh derived class to build a default mesh with thespecified size and number of meshEntries.
</p></dd>
<dt>handleRequestMeshStats:  <i>void</i></dt><dd>
<p>
       Handles request from SimManager for mesh stats
</p></dd>
<dt>handleNodeInfo:  <i>unsigned int,unsigned int</i></dt><dd>
<p>
       Tells ChemMesh how many nodes and threads per node it is allowed to use. Triggers a return meshSplit message.
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-14" class="outline-3">
<h3 id="sec-14"><span class="section-number-3">14</span> CylPanel</h3>
<div class="outline-text-3" id="text-14">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>nPts:    <i>unsigned int</i></dt><dd>
<p>
       Number of points used by panel to specify geometry
</p></dd>
<dt>nDims:   <i>unsigned int</i></dt><dd>
<p>
       Number of Dimensions used by panel to specify geometry
</p></dd>
<dt>numNeighbors:    <i>unsigned int</i></dt><dd>
<p>
       Number of Neighbors of panel
</p></dd>
<dt>shapeId: <i>unsigned int</i></dt><dd>
<p>
       Identifier for shape type, as used by Smoldyn
</p></dd>
<dt>coords:  <i>vector&lt;double&gt;</i></dt><dd>
<p>
       All the coordinates for the panel. X vector, then Y, then ZZ can be left out for 2-D panels.Z and Y can be left out for 1-D panels.
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>toNeighbor:      <i>void</i></dt><dd>
<p>
       Identifies neighbors of the current panel
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>neighbor:        <i>void</i></dt><dd>
<p>
       Handles incoming message from neighbor
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
<dt>x:       <i>unsigned int,double</i></dt><dd>
<p>
       x coordinate identified by index
</p></dd>
<dt>y:       <i>unsigned int,double</i></dt><dd>
<p>
       y coordinate identified by index
</p></dd>
<dt>z:       <i>unsigned int,double</i></dt><dd>
<p>
       z coordinate identified by index
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-15" class="outline-3">
<h3 id="sec-15"><span class="section-number-3">15</span> DiagonalMsg</h3>
<div class="outline-text-3" id="text-15">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>e1:      <i>Id</i></dt><dd>
<p>
       Id of source Element.
</p></dd>
<dt>e2:      <i>Id</i></dt><dd>
<p>
       Id of source Element.
</p></dd>
<dt>srcFieldsOnE1:   <i>vector&lt;string&gt;</i></dt><dd>
<p>
       Names of SrcFinfos for messages going from e1 to e2. There arematching entries in the destFieldsOnE2 vector
</p></dd>
<dt>destFieldsOnE2:  <i>vector&lt;string&gt;</i></dt><dd>
<p>
       Names of DestFinfos for messages going from e1 to e2. There arematching entries in the srcFieldsOnE1 vector
</p></dd>
<dt>srcFieldsOnE2:   <i>vector&lt;string&gt;</i></dt><dd>
<p>
       Names of SrcFinfos for messages going from e2 to e1. There arematching entries in the destFieldsOnE1 vector
</p></dd>
<dt>destFieldsOnE1:  <i>vector&lt;string&gt;</i></dt><dd>
<p>
       Names of destFinfos for messages going from e2 to e1. There arematching entries in the srcFieldsOnE2 vector
</p></dd>
<dt>stride:  <i>int</i></dt><dd>
<p>
       The stride is the increment to the src DataId that gives thedest DataId. It can be positive or negative, but bounds checkingtakes place and it does not wrap around.
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-16" class="outline-3">
<h3 id="sec-16"><span class="section-number-3">16</span> DiffAmp</h3>
<div class="outline-text-3" id="text-16">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>gain:    <i>double</i></dt><dd>
<p>
       Gain of the amplifier. The output of the amplifier is the difference between the totals in plus and minus inputs multiplied by the gain. Defaults to 1
</p></dd>
<dt>saturation:      <i>double</i></dt><dd>
<p>
       Saturation is the bound on the output. If output goes beyond the +/-saturation range, it is truncated to the closer of +saturation and -saturation. Defaults to the maximum double precision floating point number representable on the system.
</p></dd>
<dt>output:  <i>double</i></dt><dd>
<p>
       Output of the amplifier, i.e. gain * (plus - minus).
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>outputOut:       <i>double</i></dt><dd>
<p>
       Current output level.
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>gainIn:  <i>double</i></dt><dd>
<p>
       Destination message to control gain dynamically.
</p></dd>
<dt>plusIn:  <i>double</i></dt><dd>
<p>
       Positive input terminal of the amplifier. All the messages connected here are summed up to get total positive input.
</p></dd>
<dt>minusIn: <i>double</i></dt><dd>
<p>
       Negative input terminal of the amplifier. All the messages connected here are summed up to get total positive input.
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call, updates internal time stamp.
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call.
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-17" class="outline-3">
<h3 id="sec-17"><span class="section-number-3">17</span> DiskPanel</h3>
<div class="outline-text-3" id="text-17">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>nPts:    <i>unsigned int</i></dt><dd>
<p>
       Number of points used by panel to specify geometry
</p></dd>
<dt>nDims:   <i>unsigned int</i></dt><dd>
<p>
       Number of Dimensions used by panel to specify geometry
</p></dd>
<dt>numNeighbors:    <i>unsigned int</i></dt><dd>
<p>
       Number of Neighbors of panel
</p></dd>
<dt>shapeId: <i>unsigned int</i></dt><dd>
<p>
       Identifier for shape type, as used by Smoldyn
</p></dd>
<dt>coords:  <i>vector&lt;double&gt;</i></dt><dd>
<p>
       All the coordinates for the panel. X vector, then Y, then ZZ can be left out for 2-D panels.Z and Y can be left out for 1-D panels.
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>toNeighbor:      <i>void</i></dt><dd>
<p>
       Identifies neighbors of the current panel
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>neighbor:        <i>void</i></dt><dd>
<p>
       Handles incoming message from neighbor
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
<dt>x:       <i>unsigned int,double</i></dt><dd>
<p>
       x coordinate identified by index
</p></dd>
<dt>y:       <i>unsigned int,double</i></dt><dd>
<p>
       y coordinate identified by index
</p></dd>
<dt>z:       <i>unsigned int,double</i></dt><dd>
<p>
       z coordinate identified by index
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-18" class="outline-3">
<h3 id="sec-18"><span class="section-number-3">18</span> Enz</h3>
<div class="outline-text-3" id="text-18">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>Km:      <i>double</i></dt><dd>
<p>
       Michaelis-Menten constant in SI conc units (milliMolar)
</p></dd>
<dt>numKm:   <i>double</i></dt><dd>
<p>
       Michaelis-Menten constant in number units, volume dependent
</p></dd>
<dt>kcat:    <i>double</i></dt><dd>
<p>
       Forward rate constant for enzyme, units 1/sec
</p></dd>
<dt>numSubstrates:   <i>unsigned int</i></dt><dd>
<p>
       Number of substrates in this MM reaction. Usually 1.Does not include the enzyme itself
</p></dd>
<dt>k1:      <i>double</i></dt><dd>
<p>
       Forward reaction from enz + sub to complex
</p></dd>
<dt>k2:      <i>double</i></dt><dd>
<p>
       Reverse reaction from complex to enz + sub
</p></dd>
<dt>k3:      <i>double</i></dt><dd>
<p>
       Forward rate constant from complex to product + enz
</p></dd>
<dt>ratio:   <i>double</i></dt><dd>
<p>
       Ratio of k2/k3
</p></dd>
<dt>concK1:  <i>double</i></dt><dd>
<p>
       K1 expressed in concentration (1/millimolar.sec) units
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>toSub:   <i>double,double</i></dt><dd>
<p>
       Sends out increment of molecules on product each timestep
</p></dd>
<dt>toPrd:   <i>double,double</i></dt><dd>
<p>
       Sends out increment of molecules on product each timestep
</p></dd>
<dt>toEnz:   <i>double,double</i></dt><dd>
<p>
       Sends out increment of molecules on product each timestep
</p></dd>
<dt>toCplx:  <i>double,double</i></dt><dd>
<p>
       Sends out increment of molecules on product each timestep
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>enzDest: <i>double</i></dt><dd>
<p>
       Handles # of molecules of Enzyme
</p></dd>
<dt>subDest: <i>double</i></dt><dd>
<p>
       Handles # of molecules of substrate
</p></dd>
<dt>prdDest: <i>double</i></dt><dd>
<p>
       Handles # of molecules of product. Dummy.
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call
</p></dd>
<dt>remesh:  <i>void</i></dt><dd>
<p>
       Tells the MMEnz to recompute its numKm after remeshing
</p></dd>
<dt>enzDest: <i>double</i></dt><dd>
<p>
       Handles # of molecules of Enzyme
</p></dd>
<dt>cplxDest:        <i>double</i></dt><dd>
<p>
       Handles # of molecules of enz-sub complex
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-19" class="outline-3">
<h3 id="sec-19"><span class="section-number-3">19</span> EnzBase</h3>
<div class="outline-text-3" id="text-19">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>Km:      <i>double</i></dt><dd>
<p>
       Michaelis-Menten constant in SI conc units (milliMolar)
</p></dd>
<dt>numKm:   <i>double</i></dt><dd>
<p>
       Michaelis-Menten constant in number units, volume dependent
</p></dd>
<dt>kcat:    <i>double</i></dt><dd>
<p>
       Forward rate constant for enzyme, units 1/sec
</p></dd>
<dt>numSubstrates:   <i>unsigned int</i></dt><dd>
<p>
       Number of substrates in this MM reaction. Usually 1.Does not include the enzyme itself
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>toSub:   <i>double,double</i></dt><dd>
<p>
       Sends out increment of molecules on product each timestep
</p></dd>
<dt>toPrd:   <i>double,double</i></dt><dd>
<p>
       Sends out increment of molecules on product each timestep
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>enzDest: <i>double</i></dt><dd>
<p>
       Handles # of molecules of Enzyme
</p></dd>
<dt>subDest: <i>double</i></dt><dd>
<p>
       Handles # of molecules of substrate
</p></dd>
<dt>prdDest: <i>double</i></dt><dd>
<p>
       Handles # of molecules of product. Dummy.
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call
</p></dd>
<dt>remesh:  <i>void</i></dt><dd>
<p>
       Tells the MMEnz to recompute its numKm after remeshing
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-20" class="outline-3">
<h3 id="sec-20"><span class="section-number-3">20</span> Finfo</h3>
<div class="outline-text-3" id="text-20">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of Finfo
</p></dd>
<dt>docs:    <i>string</i></dt><dd>
<p>
       Documentation for Finfo
</p></dd>
<dt>type:    <i>string</i></dt><dd>
<p>
       RTTI type info for this Finfo
</p></dd>
<dt>src:     <i>vector&lt;string&gt;</i></dt><dd>
<p>
       Subsidiary SrcFinfos. Useful for SharedFinfos
</p></dd>
<dt>dest:    <i>vector&lt;string&gt;</i></dt><dd>
<p>
       Subsidiary DestFinfos. Useful for SharedFinfos
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-21" class="outline-3">
<h3 id="sec-21"><span class="section-number-3">21</span> FuncPool</h3>
<div class="outline-text-3" id="text-21">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>n:       <i>double</i></dt><dd>
<p>
       Number of molecules in pool
</p></dd>
<dt>nInit:   <i>double</i></dt><dd>
<p>
       Initial value of number of molecules in pool
</p></dd>
<dt>diffConst:       <i>double</i></dt><dd>
<p>
       Diffusion constant of molecule
</p></dd>
<dt>conc:    <i>double</i></dt><dd>
<p>
       Concentration of molecules in this pool
</p></dd>
<dt>concInit:        <i>double</i></dt><dd>
<p>
       Initial value of molecular concentration in pool
</p></dd>
<dt>size:    <i>double</i></dt><dd>
<p>
       Size of compartment. Units are SI. Utility field, the actual size info is stored on a volume mesh entry in the parent compartment.This is hooked up by a message. If the message isn'tavailable size is just taken as 1
</p></dd>
<dt>speciesId:       <i>unsigned int</i></dt><dd>
<p>
       Species identifier for this mol pool. Eventually link to ontology.
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>nOut:    <i>double</i></dt><dd>
<p>
       Sends out # of molecules in pool on each timestep
</p></dd>
<dt>requestMolWt:    <i>void</i></dt><dd>
<p>
       Requests Species object for mol wt
</p></dd>
<dt>requestSize:     <i>double</i></dt><dd>
<p>
       Requests Size of pool from matching mesh entry
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>group:   <i>void</i></dt><dd>
<p>
       Handle for grouping. Doesn't do anything.
</p></dd>
<dt>reacDest:        <i>double,double</i></dt><dd>
<p>
       Handles reaction input
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call
</p></dd>
<dt>handleMolWt:     <i>double</i></dt><dd>
<p>
       Separate finfo to assign molWt, and consequently diffusion const.Should only be used in SharedMsg with species.
</p></dd>
<dt>remesh:  <i>double,unsigned int,unsigned int,vector&lt;unsigned int&gt;,vector&lt;double&gt;</i></dt><dd>
<p>
       Handle commands to remesh the pool. This may involve changing the number of pool entries, as well as changing their volumes
</p></dd>
<dt>increment:       <i>double</i></dt><dd>
<p>
       Increments mol numbers by specified amount. Can be +ve or -ve
</p></dd>
<dt>decrement:       <i>double</i></dt><dd>
<p>
       Decrements mol numbers by specified amount. Can be +ve or -ve
</p></dd>
<dt>input:   <i>double</i></dt><dd>
<p>
       Handles input to control value of n_
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-22" class="outline-3">
<h3 id="sec-22"><span class="section-number-3">22</span> GHK</h3>
<div class="outline-text-3" id="text-22">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>Ik:      <i>double</i></dt><dd>
<p>
       Membrane current
</p></dd>
<dt>Gk:      <i>double</i></dt><dd>
<p>
       Conductance
</p></dd>
<dt>Ek:      <i>double</i></dt><dd>
<p>
       Reversal Potential
</p></dd>
<dt>T:       <i>double</i></dt><dd>
<p>
       Temperature of system
</p></dd>
<dt>p:       <i>double</i></dt><dd>
<p>
       Permeability of channel
</p></dd>
<dt>Vm:      <i>double</i></dt><dd>
<p>
       Membrane potential
</p></dd>
<dt>Cin:     <i>double</i></dt><dd>
<p>
       Internal concentration
</p></dd>
<dt>Cout:    <i>double</i></dt><dd>
<p>
       External ion concentration
</p></dd>
<dt>valency: <i>double</i></dt><dd>
<p>
       Valence of ion
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>channelOut:      <i>double,double</i></dt><dd>
<p>
       Sends channel variables Gk and Ek to compartment
</p></dd>
<dt>VmOut:   <i>double</i></dt><dd>
<p>
       Relay of membrane potential Vm.
</p></dd>
<dt>IkOut:   <i>double</i></dt><dd>
<p>
       MembraneCurrent.
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>handleVm:        <i>double</i></dt><dd>
<p>
       Handles Vm message coming in from compartment
</p></dd>
<dt>addPermeability: <i>double</i></dt><dd>
<p>
       Handles permeability message coming in from channel
</p></dd>
<dt>CinDest: <i>double</i></dt><dd>
<p>
       Alias for set<sub>Cin</sub>
</p></dd>
<dt>CoutDest:        <i>double</i></dt><dd>
<p>
       Alias for set<sub>Cout</sub>
</p></dd>
<dt>addPermeability: <i>double</i></dt><dd>
<p>
       Handles permeability message coming in from channel
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-23" class="outline-3">
<h3 id="sec-23"><span class="section-number-3">23</span> Geometry</h3>
<div class="outline-text-3" id="text-23">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>epsilon: <i>double</i></dt><dd>
<p>
       epsilon is the max deviation of surface-point from surface.I think it refers to when the molecule is stuck to the surface. Need to check with Steven.
</p></dd>
<dt>neighdist:       <i>double</i></dt><dd>
<p>
       neighdist is capture distance from one panel to another.When a molecule diffuses off one panel and is within neighdist of the other, it is captured by the second.
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>returnSize:      <i>double</i></dt><dd>
<p>
       Return size of compartment
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>handleSizeRequest:       <i>void</i></dt><dd>
<p>
       Handles a request for size. Part of SharedMsg to ChemCompt.
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-24" class="outline-3">
<h3 id="sec-24"><span class="section-number-3">24</span> Group</h3>
<div class="outline-text-3" id="text-24">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>group:   <i>void</i></dt><dd>
<p>
       Handle for grouping Elements
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-25" class="outline-3">
<h3 id="sec-25"><span class="section-number-3">25</span> GslIntegrator</h3>
<div class="outline-text-3" id="text-25">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>isInitialized:   <i>bool</i></dt><dd>
<p>
       True if the Stoich message has come in to set parms
</p></dd>
<dt>method:  <i>string</i></dt><dd>
<p>
       Numerical method to use.
</p></dd>
<dt>relativeAccuracy:        <i>double</i></dt><dd>
<p>
       Accuracy criterion
</p></dd>
<dt>absoluteAccuracy:        <i>double</i></dt><dd>
<p>
       Another accuracy criterion
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>stoich:  <i>Id</i></dt><dd>
<p>
       Handle data from Stoich
</p></dd>
<dt>remesh:  <i>double,unsigned int,unsigned int,vector&lt;unsigned int&gt;,vector&lt;double&gt;</i></dt><dd>
<p>
       Handle commands to remesh the pool. This may involve changing the number of pool entries, as well as changing their volumes
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-26" class="outline-3">
<h3 id="sec-26"><span class="section-number-3">26</span> GssaStoich</h3>
<div class="outline-text-3" id="text-26">

<p>   Author:              Upinder S. Bhalla, 2008, 2011, NCBS
</p>
<p>   
   Description:         GssaStoich: Gillespie Stochastic Simulation Algorithm object.Closely based on the Stoich object and inherits its handling functions for constructing the matrix. Sets up stoichiometry matrix based calculations from a
   wildcard path for the reaction system.Knows how to compute derivatives for most common things, also knows how to handle special cases where the object will have to do its own computation.Generates a stoichiometry matrix, which is useful for lots of other operations as well.
</p>
<p>   
   Name:                GssaStoich
</p>
<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>useOneWayReacs:  <i>bool</i></dt><dd>
<p>
       Flag: use bidirectional or one-way reacs. One-way is neededfor Gillespie type stochastic calculations. Two-way islikely to be margninally more efficient in ODE calculations
</p></dd>
<dt>nVarPools:       <i>unsigned int</i></dt><dd>
<p>
       Number of variable molecule pools in the reac system
</p></dd>
<dt>numMeshEntries:  <i>unsigned int</i></dt><dd>
<p>
       Number of meshEntries in reac-diff system
</p></dd>
<dt>estimatedDt:     <i>double</i></dt><dd>
<p>
       Estimate of fastest (smallest) timescale in system.This is fallible because it depends on instantaneous concs,which of course change over the course of the simulation.
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       Path of reaction system to take over
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       Path of reaction system to take over and solve
</p></dd>
<dt>method:  <i>string</i></dt><dd>
<p>
       Numerical method to use for the GssaStoich. The defaultand currently the only method is Gillespie1.
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>plugin:  <i>Id</i></dt><dd>
<p>
       Sends out Stoich Id so that plugins can directly access fields and functions
</p></dd>
<dt>nodeDiffBoundary:        <i>unsigned int,vector&lt;unsigned int&gt;,vector&lt;double&gt;</i></dt><dd>
<p>
       Sends mol #s across boundary between nodes, to calculate diffusionterms. arg1 is originating node, arg2 is list of meshIndices forwhich data is being transferred, and arg3 are the 'n' values forall the pools on the specified meshIndices, to be plugged intothe appropriate place on the recipient node's S_ matrix
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>meshSplit:       <i>double,vector&lt;double&gt;,vector&lt;unsigned int&gt;,vector&lt; vector&lt;unsigned int&gt; &gt;,vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Handles message from ChemMesh that defines how meshEntries are decomposed on this node, and how they communicate between nodes.Args: (oldVol, volumeVectorForAllEntries, localEntryList, outgoingDiffusion[node#][entry#], incomingDiffusion[node#][entry#])
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinint call
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-27" class="outline-3">
<h3 id="sec-27"><span class="section-number-3">27</span> HDF5DataWriter</h3>
<div class="outline-text-3" id="text-27">

<p>   Author:              Subhasis Ray
</p>
<p>   
   Description:         HDF5 file writer for saving data tables. It saves the tables added to it via addObject function into an HDF5 file. At every process call it writes the contents of the tables to the file and clears the table vectors. You can explicitly save the data via the flush function.
</p>
<p>   
   Name:                HDF5DataWriter
</p>
<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>filename:        <i>string</i></dt><dd>
<p>
       Name of the file associated with this HDF5 writer object.
</p></dd>
<dt>isOpen:  <i>bool</i></dt><dd>
<p>
       True if this object has an open file handle.
</p></dd>
<dt>mode:    <i>unsigned int</i></dt><dd>
<p>
       Depending on mode, if file already exists, if mode=1, data will be appended to existing file, if mode=2, file will be truncated, if  mode=4, no writing will happen.
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>requestData:     <i>unsigned int</i></dt><dd>
<p>
       Sends request for a field to target object
</p></dd>
<dt>clear:   <i>void</i></dt><dd>
<p>
       Send request to clear a Table vector.
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>flush:   <i>void</i></dt><dd>
<p>
       Write all buffer contents to file and clear the buffers.
</p></dd>
<dt>recvData:        <i>bad</i></dt><dd>
<p>
       Handles data sent back following request
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handle process calls. Write data to file and clear all Table objects associated with this.
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Reinitialize the object
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-28" class="outline-3">
<h3 id="sec-28"><span class="section-number-3">28</span> HDF5WriterBase</h3>
<div class="outline-text-3" id="text-28">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>filename:        <i>string</i></dt><dd>
<p>
       Name of the file associated with this HDF5 writer object.
</p></dd>
<dt>isOpen:  <i>bool</i></dt><dd>
<p>
       True if this object has an open file handle.
</p></dd>
<dt>mode:    <i>unsigned int</i></dt><dd>
<p>
       Depending on mode, if file already exists, if mode=1, data will be appended to existing file, if mode=2, file will be truncated, if  mode=4, no writing will happen.
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>flush:   <i>void</i></dt><dd>
<p>
       Write all buffer contents to file and clear the buffers.
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-29" class="outline-3">
<h3 id="sec-29"><span class="section-number-3">29</span> HHChannel</h3>
<div class="outline-text-3" id="text-29">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>Gbar:    <i>double</i></dt><dd>
<p>
       Maximal channel conductance
</p></dd>
<dt>Ek:      <i>double</i></dt><dd>
<p>
       Reversal potential of channel
</p></dd>
<dt>Gk:      <i>double</i></dt><dd>
<p>
       Channel conductance variable
</p></dd>
<dt>Ik:      <i>double</i></dt><dd>
<p>
       Channel current variable
</p></dd>
<dt>Xpower:  <i>double</i></dt><dd>
<p>
       Power for X gate
</p></dd>
<dt>Ypower:  <i>double</i></dt><dd>
<p>
       Power for Y gate
</p></dd>
<dt>Zpower:  <i>double</i></dt><dd>
<p>
       Power for Z gate
</p></dd>
<dt>instant: <i>int</i></dt><dd>
<p>
       Bitmapped flag: bit 0 = Xgate, bit 1 = Ygate, bit 2 = ZgateWhen true, specifies that the lookup table value should beused directly as the state of the channel, rather than usedas a rate term for numerical integration for the state
</p></dd>
<dt>X:       <i>double</i></dt><dd>
<p>
       State variable for X gate
</p></dd>
<dt>Y:       <i>double</i></dt><dd>
<p>
       State variable for Y gate
</p></dd>
<dt>Z:       <i>double</i></dt><dd>
<p>
       State variable for Y gate
</p></dd>
<dt>useConcentration:        <i>int</i></dt><dd>
<p>
       Flag: when true, use concentration message rather than Vm tocontrol Z gate
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>channelOut:      <i>double,double</i></dt><dd>
<p>
       Sends channel variables Gk and Ek to compartment
</p></dd>
<dt>permeability:    <i>double</i></dt><dd>
<p>
       Conductance term going out to GHK object
</p></dd>
<dt>IkOut:   <i>double</i></dt><dd>
<p>
       Channel current. This message typically goes to concenobjects that keep track of ion concentration.
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>Vm:      <i>double</i></dt><dd>
<p>
       Handles Vm message coming in from compartment
</p></dd>
<dt>Vm:      <i>double</i></dt><dd>
<p>
       Handles Vm message coming in from compartment
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call
</p></dd>
<dt>concen:  <i>double</i></dt><dd>
<p>
       Incoming message from Concen object to specific conc to usein the Z gate calculations
</p></dd>
<dt>createGate:      <i>string</i></dt><dd>
<p>
       Function to create specified gate.Argument: Gate type [X Y Z]
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-30" class="outline-3">
<h3 id="sec-30"><span class="section-number-3">30</span> HHChannel2D</h3>
<div class="outline-text-3" id="text-30">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>Gbar:    <i>double</i></dt><dd>
<p>
       Maximal channel conductance
</p></dd>
<dt>Ek:      <i>double</i></dt><dd>
<p>
       Reversal potential of channel
</p></dd>
<dt>Gk:      <i>double</i></dt><dd>
<p>
       Channel conductance variable
</p></dd>
<dt>Ik:      <i>double</i></dt><dd>
<p>
       Channel current variable
</p></dd>
<dt>Xindex:  <i>string</i></dt><dd>
<p>
       String for setting X index.
</p></dd>
<dt>Yindex:  <i>string</i></dt><dd>
<p>
       String for setting Y index.
</p></dd>
<dt>Zindex:  <i>string</i></dt><dd>
<p>
       String for setting Z index.
</p></dd>
<dt>Xpower:  <i>double</i></dt><dd>
<p>
       Power for X gate
</p></dd>
<dt>Ypower:  <i>double</i></dt><dd>
<p>
       Power for Y gate
</p></dd>
<dt>Zpower:  <i>double</i></dt><dd>
<p>
       Power for Z gate
</p></dd>
<dt>instant: <i>int</i></dt><dd>
<p>
       Bitmapped flag: bit 0 = Xgate, bit 1 = Ygate, bit 2 = ZgateWhen true, specifies that the lookup table value should beused directly as the state of the channel, rather than usedas a rate term for numerical integration for the state
</p></dd>
<dt>X:       <i>double</i></dt><dd>
<p>
       State variable for X gate
</p></dd>
<dt>Y:       <i>double</i></dt><dd>
<p>
       State variable for Y gate
</p></dd>
<dt>Z:       <i>double</i></dt><dd>
<p>
       State variable for Y gate
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>channelOut:      <i>double,double</i></dt><dd>
<p>
       Sends channel variables Gk and Ek to compartment
</p></dd>
<dt>permeability:    <i>double</i></dt><dd>
<p>
       Conductance term going out to GHK object
</p></dd>
<dt>IkOut:   <i>double</i></dt><dd>
<p>
       Channel current. This message typically goes to concenobjects that keep track of ion concentration.
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>Vm:      <i>double</i></dt><dd>
<p>
       Handles Vm message coming in from compartment
</p></dd>
<dt>Vm:      <i>double</i></dt><dd>
<p>
       Handles Vm message coming in from compartment
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call
</p></dd>
<dt>concen:  <i>double</i></dt><dd>
<p>
       Incoming message from Concen object to specific conc to useas the first concen variable
</p></dd>
<dt>concen2: <i>double</i></dt><dd>
<p>
       Incoming message from Concen object to specific conc to useas the second concen variable
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-31" class="outline-3">
<h3 id="sec-31"><span class="section-number-3">31</span> HHGate</h3>
<div class="outline-text-3" id="text-31">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>alpha:   <i>vector&lt;double&gt;</i></dt><dd>
<p>
       Parameters for voltage-dependent rates, alpha:Set up alpha term using 5 parameters, as follows:y(x) = (A + B * x) / (C + exp((x + D) / F))The original HH equations can readily be cast into this form
</p></dd>
<dt>beta:    <i>vector&lt;double&gt;</i></dt><dd>
<p>
       Parameters for voltage-dependent rates, beta:Set up beta term using 5 parameters, as follows:y(x) = (A + B * x) / (C + exp((x + D) / F))The original HH equations can readily be cast into this form
</p></dd>
<dt>tau:     <i>vector&lt;double&gt;</i></dt><dd>
<p>
       Parameters for voltage-dependent rates, tau:Set up tau curve using 5 parameters, as follows:y(x) = (A + B * x) / (C + exp((x + D) / F))
</p></dd>
<dt>mInfinity:       <i>vector&lt;double&gt;</i></dt><dd>
<p>
       Parameters for voltage-dependent rates, mInfinity:Set up mInfinity curve using 5 parameters, as follows:y(x) = (A + B * x) / (C + exp((x + D) / F))The original HH equations can readily be cast into this form
</p></dd>
<dt>min:     <i>double</i></dt><dd>
<p>
       Minimum range for lookup
</p></dd>
<dt>max:     <i>double</i></dt><dd>
<p>
       Minimum range for lookup
</p></dd>
<dt>divs:    <i>unsigned int</i></dt><dd>
<p>
       Divisions for lookup. Zero means to use linear interpolation
</p></dd>
<dt>tableA:  <i>vector&lt;double&gt;</i></dt><dd>
<p>
       Table of A entries
</p></dd>
<dt>tableB:  <i>vector&lt;double&gt;</i></dt><dd>
<p>
       Table of alpha + beta entries
</p></dd>
<dt>useInterpolation:        <i>bool</i></dt><dd>
<p>
       Flag: use linear interpolation if true, else direct lookup
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>setupAlpha:      <i>vector&lt;double&gt;</i></dt><dd>
<p>
       Set up both gates using 13 parameters, as follows:setupAlpha AA AB AC AD AF BA BB BC BD BF xdivs xmin xmaxHere AA-AF are Coefficients A to F of the alpha (forward) termHere BA-BF are Coefficients A to F of the beta (reverse) termHere xdivs is the number of entries in the table,xmin and xmax define the range for lookup.Outside this range the returned value will be the low [high]entry of the table.The equation describing each table is:y(x) = (A + B * x) / (C + exp((x + D) / F))The original HH equations can readily be cast into this form
</p></dd>
<dt>setupTau:        <i>vector&lt;double&gt;</i></dt><dd>
<p>
       Identical to setupAlpha, except that the forms specified bythe 13 parameters are for the tau and m-infinity curves ratherthan the alpha and beta terms. So the parameters are:setupTau TA TB TC TD TF MA MB MC MD MF xdivs xmin xmaxAs before, the equation describing each curve is:y(x) = (A + B * x) / (C + exp((x + D) / F))
</p></dd>
<dt>tweakAlpha:      <i>void</i></dt><dd>
<p>
       Dummy function for backward compatibility. It used to convertthe tables from alpha, beta values to alpha, alpha+betabecause the internal calculations used these forms. Notneeded now, deprecated.
</p></dd>
<dt>tweakTau:        <i>void</i></dt><dd>
<p>
       Dummy function for backward compatibility. It used to convertthe tables from tau, minf values to alpha, alpha+betabecause the internal calculations used these forms. Notneeded now, deprecated.
</p></dd>
<dt>setupGate:       <i>vector&lt;double&gt;</i></dt><dd>
<p>
       Sets up one gate at a time using the alpha/beta form.Has 9 parameters, as follows:setupGate A B C D F xdivs xmin xmax is<sub>betaThis</sub> sets up the gate using the equation:y(x) = (A + B * x) / (C + exp((x + D) / F))Deprecated.
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
<dt>A:       <i>double,double</i></dt><dd>
<p>
       lookupA: Look up the A gate value from a double. Usually doesso by direct scaling and offset to an integer lookup, usinga fine enough table granularity that there is little error.Alternatively uses linear interpolation.The range of the double is predefined based on knowledge ofvoltage or conc ranges, and the granularity is specified bythe xmin, xmax, and dV fields.
</p></dd>
<dt>B:       <i>double,double</i></dt><dd>
<p>
       lookupB: Look up the B gate value from a double.Note that this looks up the raw tables, which are transformedfrom the reference parameters.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-32" class="outline-3">
<h3 id="sec-32"><span class="section-number-3">32</span> HHGate2D</h3>
<div class="outline-text-3" id="text-32">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
<dt>A:       <i>vector&lt;double&gt;,double</i></dt><dd>
<p>
       lookupA: Look up the A gate value from two doubles, passedin as a vector. Uses linear interpolation in the 2D tableThe range of the lookup doubles is predefined based on knowledge of voltage or conc ranges, and the granularity is specified by the xmin, xmax, and dx field, and their y-axis counterparts.
</p></dd>
<dt>B:       <i>vector&lt;double&gt;,double</i></dt><dd>
<p>
       lookupB: Look up B gate value from two doubles in a vector.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-33" class="outline-3">
<h3 id="sec-33"><span class="section-number-3">33</span> HSolve</h3>
<div class="outline-text-3" id="text-33">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>seed:    <i>Id</i></dt><dd>
<p>
       Use this field to specify path to a 'seed' compartment, that is, any compartment within a neuron. The HSolve object uses this seed as a handle to discover the rest of the neuronal model, which means all the remaining compartments, channels, synapses, etc.
</p></dd>
<dt>target:  <i>string</i></dt><dd>
<p>
       Specifies the path to a compartmental model to be taken over. This can be the path to any container object that has the model under it (found by performing a deep search). Alternatively, this can also be the path to any compartment within the neuron. This compartment will be used as a handle to discover the rest of the model, which means all the remaining compartments, channels, synapses, etc.
</p></dd>
<dt>dt:      <i>double</i></dt><dd>
<p>
       The time-step for this solver.
</p></dd>
<dt>caAdvance:       <i>int</i></dt><dd>
<p>
       This flag determines how current flowing into a calcium pool is computed. A value of 0 means that the membrane potential at the beginning of the time-step is used for the calculation. This is how GENESIS does its computations. A value of 1 means the membrane potential at the middle of the time-step is used. This is the correct way of integration, and is the default way.
</p></dd>
<dt>vDiv:    <i>int</i></dt><dd>
<p>
       Specifies number of divisions for lookup tables of voltage-sensitive channels.
</p></dd>
<dt>vMin:    <i>double</i></dt><dd>
<p>
       Specifies the lower bound for lookup tables of voltage-sensitive channels. Default is to automatically decide based on the tables of the channels that the solver reads in.
</p></dd>
<dt>vMax:    <i>double</i></dt><dd>
<p>
       Specifies the upper bound for lookup tables of voltage-sensitive channels. Default is to automatically decide based on the tables of the channels that the solver reads in.
</p></dd>
<dt>caDiv:   <i>int</i></dt><dd>
<p>
       Specifies number of divisions for lookup tables of calcium-sensitive channels.
</p></dd>
<dt>caMin:   <i>double</i></dt><dd>
<p>
       Specifies the lower bound for lookup tables of calcium-sensitive channels. Default is to automatically decide based on the tables of the channels that the solver reads in.
</p></dd>
<dt>caMax:   <i>double</i></dt><dd>
<p>
       Specifies the upper bound for lookup tables of calcium-sensitive channels. Default is to automatically decide based on the tables of the channels that the solver reads in.
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles 'process' call: Solver advances by one time-step.
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles 'reinit' call: Solver reads in model.
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-34" class="outline-3">
<h3 id="sec-34"><span class="section-number-3">34</span> HemispherePanel</h3>
<div class="outline-text-3" id="text-34">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>nPts:    <i>unsigned int</i></dt><dd>
<p>
       Number of points used by panel to specify geometry
</p></dd>
<dt>nDims:   <i>unsigned int</i></dt><dd>
<p>
       Number of Dimensions used by panel to specify geometry
</p></dd>
<dt>numNeighbors:    <i>unsigned int</i></dt><dd>
<p>
       Number of Neighbors of panel
</p></dd>
<dt>shapeId: <i>unsigned int</i></dt><dd>
<p>
       Identifier for shape type, as used by Smoldyn
</p></dd>
<dt>coords:  <i>vector&lt;double&gt;</i></dt><dd>
<p>
       All the coordinates for the panel. X vector, then Y, then ZZ can be left out for 2-D panels.Z and Y can be left out for 1-D panels.
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>toNeighbor:      <i>void</i></dt><dd>
<p>
       Identifies neighbors of the current panel
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>neighbor:        <i>void</i></dt><dd>
<p>
       Handles incoming message from neighbor
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
<dt>x:       <i>unsigned int,double</i></dt><dd>
<p>
       x coordinate identified by index
</p></dd>
<dt>y:       <i>unsigned int,double</i></dt><dd>
<p>
       y coordinate identified by index
</p></dd>
<dt>z:       <i>unsigned int,double</i></dt><dd>
<p>
       z coordinate identified by index
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-35" class="outline-3">
<h3 id="sec-35"><span class="section-number-3">35</span> IntFire</h3>
<div class="outline-text-3" id="text-35">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>numSynapses:     <i>unsigned int</i></dt><dd>
<p>
       Number of synapses on SynBase
</p></dd>
<dt>Vm:      <i>double</i></dt><dd>
<p>
       Membrane potential
</p></dd>
<dt>tau:     <i>double</i></dt><dd>
<p>
       charging time-course
</p></dd>
<dt>thresh:  <i>double</i></dt><dd>
<p>
       firing threshold
</p></dd>
<dt>refractoryPeriod:        <i>double</i></dt><dd>
<p>
       Minimum time between successive spikes
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>spike:   <i>double</i></dt><dd>
<p>
       Sends out spike events
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-36" class="outline-3">
<h3 id="sec-36"><span class="section-number-3">36</span> Interpol2D</h3>
<div class="outline-text-3" id="text-36">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>xmin:    <i>double</i></dt><dd>
<p>
       Minimum value for x axis of lookup table
</p></dd>
<dt>xmax:    <i>double</i></dt><dd>
<p>
       Maximum value for x axis of lookup table
</p></dd>
<dt>xdivs:   <i>unsigned int</i></dt><dd>
<p>
       # of divisions on x axis of lookup table
</p></dd>
<dt>dx:      <i>double</i></dt><dd>
<p>
       Increment on x axis of lookup table
</p></dd>
<dt>ymin:    <i>double</i></dt><dd>
<p>
       Minimum value for y axis of lookup table
</p></dd>
<dt>ymax:    <i>double</i></dt><dd>
<p>
       Maximum value for y axis of lookup table
</p></dd>
<dt>ydivs:   <i>unsigned int</i></dt><dd>
<p>
       # of divisions on y axis of lookup table
</p></dd>
<dt>dy:      <i>double</i></dt><dd>
<p>
       Increment on y axis of lookup table
</p></dd>
<dt>tableVector2D:   <i>vector&lt; vector&lt;double&gt; &gt;</i></dt><dd>
<p>
       Get the entire table.
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>trig:    <i>double</i></dt><dd>
<p>
       respond to a request for a value lookup
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>lookup:  <i>double,double</i></dt><dd>
<p>
       Looks up table value based on indices v1 and v2, and sendsvalue back using the 'trig' message
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
<dt>table:   <i>vector&lt;unsigned int&gt;,double</i></dt><dd>
<p>
       Lookup an entry on the table
</p></dd>
<dt>z:       <i>vector&lt;double&gt;,double</i></dt><dd>
<p>
       Interpolated value for specified x and y. This is provided for debugging. Normally other objects will retrieve interpolated values via lookup message.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-37" class="outline-3">
<h3 id="sec-37"><span class="section-number-3">37</span> IzhikevichNrn</h3>
<div class="outline-text-3" id="text-37">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>Vmax:    <i>double</i></dt><dd>
<p>
       Maximum membrane potential. Membrane potential is reset to c whenever it reaches Vmax. NOTE: Izhikevich model specifies the PEAK voltage, rather than THRSHOLD voltage. The threshold depends on the previous history.
</p></dd>
<dt>c:       <i>double</i></dt><dd>
<p>
       Reset potential. Membrane potential is reset to c whenever it reaches Vmax.
</p></dd>
<dt>d:       <i>double</i></dt><dd>
<p>
       Parameter d in Izhikevich model. Unit is V/s.
</p></dd>
<dt>a:       <i>double</i></dt><dd>
<p>
       Parameter a in Izhikevich model. Unit is s<sup>-1</sup>
</p></dd>
<dt>b:       <i>double</i></dt><dd>
<p>
       Parameter b in Izhikevich model. Unit is s<sup>-1</sup>
</p></dd>
<dt>u:       <i>double</i></dt><dd>
<p>
       Parameter u in Izhikevich equation. Unit is V/s<sup>-1</sup>
</p></dd>
<dt>Vm:      <i>double</i></dt><dd>
<p>
       Membrane potential, equivalent to v in Izhikevich equation.
</p></dd>
<dt>Im:      <i>double</i></dt><dd>
<p>
       Total current going through the membrane. Unit is A.
</p></dd>
<dt>Rm:      <i>double</i></dt><dd>
<p>
       Hidden cefficient of input current term (I) in Izhikevich model. Defaults to 1e6 Ohm.
</p></dd>
<dt>initVm:  <i>double</i></dt><dd>
<p>
       Initial membrane potential. Unit is V.
</p></dd>
<dt>initU:   <i>double</i></dt><dd>
<p>
       Initial value of u.
</p></dd>
<dt>alpha:   <i>double</i></dt><dd>
<p>
       Coefficient of v<sup>2</sup> in Izhikevich equation. Defaults to 0.04 in physiological unit. In SI it should be 40000.0. Unit is V<sup>-1</sup> s<sup>-1</sup>
</p></dd>
<dt>beta:    <i>double</i></dt><dd>
<p>
       Coefficient of v in Izhikevich model. Defaults to 5 in physiological unit, 5000.0 for SI units. Unit is s<sup>-1</sup>
</p></dd>
<dt>gamma:   <i>double</i></dt><dd>
<p>
       Constant term in Izhikevich model. Defaults to 140 in both physiological and SI units. unit is V/s.
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>VmOut:   <i>double</i></dt><dd>
<p>
       Sends out Vm
</p></dd>
<dt>spike:   <i>double</i></dt><dd>
<p>
       Sends out spike events
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call
</p></dd>
<dt>injectDest:      <i>double</i></dt><dd>
<p>
       Injection current into the neuron.
</p></dd>
<dt>cDest:   <i>double</i></dt><dd>
<p>
       Destination message to modify parameter c at runtime.
</p></dd>
<dt>dDest:   <i>double</i></dt><dd>
<p>
       Destination message to modify parameter d at runtime.
</p></dd>
<dt>bDest:   <i>double</i></dt><dd>
<p>
       Destination message to modify parameter b at runtime
</p></dd>
<dt>aDest:   <i>double</i></dt><dd>
<p>
       Destination message modify parameter a at runtime.
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-38" class="outline-3">
<h3 id="sec-38"><span class="section-number-3">38</span> LeakyIaF</h3>
<div class="outline-text-3" id="text-38">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>Cm:      <i>double</i></dt><dd>
<p>
       Membrane capacitance.
</p></dd>
<dt>Rm:      <i>double</i></dt><dd>
<p>
       Membrane resistance, inverse of leak-conductance.
</p></dd>
<dt>Em:      <i>double</i></dt><dd>
<p>
       Leak reversal potential
</p></dd>
<dt>Vm:      <i>double</i></dt><dd>
<p>
       Membrane potential
</p></dd>
<dt>initVm:  <i>double</i></dt><dd>
<p>
       Inital value of membrane potential
</p></dd>
<dt>Vreset:  <i>double</i></dt><dd>
<p>
       Reset potnetial after firing.
</p></dd>
<dt>Vthreshold:      <i>double</i></dt><dd>
<p>
       firing threshold
</p></dd>
<dt>refractoryPeriod:        <i>double</i></dt><dd>
<p>
       Minimum time between successive spikes
</p></dd>
<dt>inject:  <i>double</i></dt><dd>
<p>
       Injection current.
</p></dd>
<dt>tSpike:  <i>double</i></dt><dd>
<p>
       Time of the last spike
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>spike:   <i>double</i></dt><dd>
<p>
       Sends out spike events
</p></dd>
<dt>VmOut:   <i>double</i></dt><dd>
<p>
       Sends out Vm
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call
</p></dd>
<dt>injectDest:      <i>double</i></dt><dd>
<p>
       Destination for current input.
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-39" class="outline-3">
<h3 id="sec-39"><span class="section-number-3">39</span> MMenz</h3>
<div class="outline-text-3" id="text-39">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>Km:      <i>double</i></dt><dd>
<p>
       Michaelis-Menten constant in SI conc units (milliMolar)
</p></dd>
<dt>numKm:   <i>double</i></dt><dd>
<p>
       Michaelis-Menten constant in number units, volume dependent
</p></dd>
<dt>kcat:    <i>double</i></dt><dd>
<p>
       Forward rate constant for enzyme, units 1/sec
</p></dd>
<dt>numSubstrates:   <i>unsigned int</i></dt><dd>
<p>
       Number of substrates in this MM reaction. Usually 1.Does not include the enzyme itself
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>toSub:   <i>double,double</i></dt><dd>
<p>
       Sends out increment of molecules on product each timestep
</p></dd>
<dt>toPrd:   <i>double,double</i></dt><dd>
<p>
       Sends out increment of molecules on product each timestep
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>enzDest: <i>double</i></dt><dd>
<p>
       Handles # of molecules of Enzyme
</p></dd>
<dt>subDest: <i>double</i></dt><dd>
<p>
       Handles # of molecules of substrate
</p></dd>
<dt>prdDest: <i>double</i></dt><dd>
<p>
       Handles # of molecules of product. Dummy.
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call
</p></dd>
<dt>remesh:  <i>void</i></dt><dd>
<p>
       Tells the MMEnz to recompute its numKm after remeshing
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-40" class="outline-3">
<h3 id="sec-40"><span class="section-number-3">40</span> MarkovChannel</h3>
<div class="outline-text-3" id="text-40">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>Gbar:    <i>double</i></dt><dd>
<p>
       Maximal channel conductance
</p></dd>
<dt>Ek:      <i>double</i></dt><dd>
<p>
       Reversal potential of channel
</p></dd>
<dt>Gk:      <i>double</i></dt><dd>
<p>
       Channel conductance variable
</p></dd>
<dt>Ik:      <i>double</i></dt><dd>
<p>
       Channel current variable
</p></dd>
<dt>ligandconc:      <i>double</i></dt><dd>
<p>
       Ligand concentration.
</p></dd>
<dt>vm:      <i>double</i></dt><dd>
<p>
       Membrane voltage.
</p></dd>
<dt>numstates:       <i>unsigned int</i></dt><dd>
<p>
       The number of states that the channel can occupy.
</p></dd>
<dt>numopenstates:   <i>unsigned int</i></dt><dd>
<p>
       The number of states which are open/conducting.
</p></dd>
<dt>state:   <i>vector&lt;double&gt;</i></dt><dd>
<p>
       This is a row vector that contains the probabilities of finding the channel in each state.
</p></dd>
<dt>initialstate:    <i>vector&lt;double&gt;</i></dt><dd>
<p>
       This is a row vector that contains the probabilities of finding the channel in each state at t = 0. The state of the channel is reset to this value during a call to reinit()
</p></dd>
<dt>labels:  <i>vector&lt;string&gt;</i></dt><dd>
<p>
       Labels for each state.
</p></dd>
<dt>gbar:    <i>vector&lt;double&gt;</i></dt><dd>
<p>
       A row vector containing the conductance associated with each of the open/conducting states.
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>channelOut:      <i>double,double</i></dt><dd>
<p>
       Sends channel variables Gk and Ek to compartment
</p></dd>
<dt>permeability:    <i>double</i></dt><dd>
<p>
       Conductance term going out to GHK object
</p></dd>
<dt>IkOut:   <i>double</i></dt><dd>
<p>
       Channel current. This message typically goes to concenobjects that keep track of ion concentration.
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>Vm:      <i>double</i></dt><dd>
<p>
       Handles Vm message coming in from compartment
</p></dd>
<dt>Vm:      <i>double</i></dt><dd>
<p>
       Handles Vm message coming in from compartment
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call
</p></dd>
<dt>handleligandconc:        <i>double</i></dt><dd>
<p>
       Deals with incoming messages containing information of ligand concentration
</p></dd>
<dt>handlestate:     <i>vector&lt;double&gt;</i></dt><dd>
<p>
       Deals with incoming message from MarkovSolver object containing state information of the channel.
</p></dd>
</dl>

</li>
</ul>



<ul>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-41" class="outline-3">
<h3 id="sec-41"><span class="section-number-3">41</span> MarkovGslSolver</h3>
<div class="outline-text-3" id="text-41">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>isInitialized:   <i>bool</i></dt><dd>
<p>
       True if the message has come in to set solver parameters.
</p></dd>
<dt>method:  <i>string</i></dt><dd>
<p>
       Numerical method to use.
</p></dd>
<dt>relativeAccuracy:        <i>double</i></dt><dd>
<p>
       Accuracy criterion
</p></dd>
<dt>absoluteAccuracy:        <i>double</i></dt><dd>
<p>
       Another accuracy criterion
</p></dd>
<dt>internalDt:      <i>double</i></dt><dd>
<p>
       internal timestep to use.
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>stateOut:        <i>vector&lt;double&gt;</i></dt><dd>
<p>
       Sends updated state to the MarkovChannel class.
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>init:    <i>vector&lt;double&gt;</i></dt><dd>
<p>
       Initialize solver parameters.
</p></dd>
<dt>handleQ: <i>vector&lt; vector&lt;double&gt; &gt;</i></dt><dd>
<p>
       Handles information regarding the instantaneous rate matrix from the MarkovRateTable class.
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-42" class="outline-3">
<h3 id="sec-42"><span class="section-number-3">42</span> MarkovRateTable</h3>
<div class="outline-text-3" id="text-42">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>vm:      <i>double</i></dt><dd>
<p>
       Membrane voltage.
</p></dd>
<dt>ligandconc:      <i>double</i></dt><dd>
<p>
       Ligand concentration.
</p></dd>
<dt>Q:       <i>vector&lt; vector&lt;double&gt; &gt;</i></dt><dd>
<p>
       Instantaneous rate matrix.
</p></dd>
<dt>size:    <i>unsigned int</i></dt><dd>
<p>
       Dimension of the families of lookup tables. Is always equal to the number of states in the model.
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>instratesOut:    <i>vector&lt; vector&lt;double&gt; &gt;</i></dt><dd>
<p>
       Sends out instantaneous rate information of varying transition rates at each time step.
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>handleVm:        <i>double</i></dt><dd>
<p>
       Handles incoming message containing voltage information.
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call
</p></dd>
<dt>init:    <i>unsigned int</i></dt><dd>
<p>
       Initialization of the class. Allocates memory for all the tables.
</p></dd>
<dt>handleLigandConc:        <i>double</i></dt><dd>
<p>
       Handles incoming message containing ligand concentration.
</p></dd>
<dt>set1d:   <i>unsigned int,unsigned int,Id,unsigned int</i></dt><dd>
<p>
       Setting up of 1D lookup table for the (i,j)'th rate.
</p></dd>
<dt>set2d:   <i>unsigned int,unsigned int,Id</i></dt><dd>
<p>
       Setting up of 2D lookup table for the (i,j)'th rate.
</p></dd>
<dt>setconst:        <i>unsigned int,unsigned int,double</i></dt><dd>
<p>
       Setting a constant value for the (i,j)'th rate. Internally, this is      stored as a 1-D rate with a lookup table containing 1 entry.
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-43" class="outline-3">
<h3 id="sec-43"><span class="section-number-3">43</span> MarkovSolver</h3>
<div class="outline-text-3" id="text-43">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>Q:       <i>vector&lt; vector&lt;double&gt; &gt;</i></dt><dd>
<p>
       Instantaneous rate matrix.
</p></dd>
<dt>state:   <i>vector&lt;double&gt;</i></dt><dd>
<p>
       Current state of the channel.
</p></dd>
<dt>initialstate:    <i>vector&lt;double&gt;</i></dt><dd>
<p>
       Initial state of the channel.
</p></dd>
<dt>xmin:    <i>double</i></dt><dd>
<p>
       Minimum value for x axis of lookup table
</p></dd>
<dt>xmax:    <i>double</i></dt><dd>
<p>
       Maximum value for x axis of lookup table
</p></dd>
<dt>xdivs:   <i>unsigned int</i></dt><dd>
<p>
       # of divisions on x axis of lookup table
</p></dd>
<dt>invdx:   <i>double</i></dt><dd>
<p>
       Reciprocal of increment on x axis of lookup table
</p></dd>
<dt>ymin:    <i>double</i></dt><dd>
<p>
       Minimum value for y axis of lookup table
</p></dd>
<dt>ymax:    <i>double</i></dt><dd>
<p>
       Maximum value for y axis of lookup table
</p></dd>
<dt>ydivs:   <i>unsigned int</i></dt><dd>
<p>
       # of divisions on y axis of lookup table
</p></dd>
<dt>invdy:   <i>double</i></dt><dd>
<p>
       Reciprocal of increment on y axis of lookup table
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>stateOut:        <i>vector&lt;double&gt;</i></dt><dd>
<p>
       Sends updated state to the MarkovChannel class.
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>handleVm:        <i>double</i></dt><dd>
<p>
       Handles incoming message containing voltage information.
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call
</p></dd>
<dt>ligandconc:      <i>double</i></dt><dd>
<p>
       Handles incoming message containing ligand concentration.
</p></dd>
<dt>init:    <i>Id,double</i></dt><dd>
<p>
       Setups the table of matrix exponentials associated with the solver object.
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-44" class="outline-3">
<h3 id="sec-44"><span class="section-number-3">44</span> MarkovSolverBase</h3>
<div class="outline-text-3" id="text-44">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>Q:       <i>vector&lt; vector&lt;double&gt; &gt;</i></dt><dd>
<p>
       Instantaneous rate matrix.
</p></dd>
<dt>state:   <i>vector&lt;double&gt;</i></dt><dd>
<p>
       Current state of the channel.
</p></dd>
<dt>initialstate:    <i>vector&lt;double&gt;</i></dt><dd>
<p>
       Initial state of the channel.
</p></dd>
<dt>xmin:    <i>double</i></dt><dd>
<p>
       Minimum value for x axis of lookup table
</p></dd>
<dt>xmax:    <i>double</i></dt><dd>
<p>
       Maximum value for x axis of lookup table
</p></dd>
<dt>xdivs:   <i>unsigned int</i></dt><dd>
<p>
       # of divisions on x axis of lookup table
</p></dd>
<dt>invdx:   <i>double</i></dt><dd>
<p>
       Reciprocal of increment on x axis of lookup table
</p></dd>
<dt>ymin:    <i>double</i></dt><dd>
<p>
       Minimum value for y axis of lookup table
</p></dd>
<dt>ymax:    <i>double</i></dt><dd>
<p>
       Maximum value for y axis of lookup table
</p></dd>
<dt>ydivs:   <i>unsigned int</i></dt><dd>
<p>
       # of divisions on y axis of lookup table
</p></dd>
<dt>invdy:   <i>double</i></dt><dd>
<p>
       Reciprocal of increment on y axis of lookup table
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>stateOut:        <i>vector&lt;double&gt;</i></dt><dd>
<p>
       Sends updated state to the MarkovChannel class.
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>handleVm:        <i>double</i></dt><dd>
<p>
       Handles incoming message containing voltage information.
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call
</p></dd>
<dt>ligandconc:      <i>double</i></dt><dd>
<p>
       Handles incoming message containing ligand concentration.
</p></dd>
<dt>init:    <i>Id,double</i></dt><dd>
<p>
       Setups the table of matrix exponentials associated with the solver object.
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-45" class="outline-3">
<h3 id="sec-45"><span class="section-number-3">45</span> MathFunc</h3>
<div class="outline-text-3" id="text-45">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>mathML:  <i>string</i></dt><dd>
<p>
       MathML version of expression to compute
</p></dd>
<dt>function:        <i>string</i></dt><dd>
<p>
       function is for functions of form f(x, y) = x + y
</p></dd>
<dt>result:  <i>double</i></dt><dd>
<p>
       result value
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>output:  <i>double</i></dt><dd>
<p>
       Sends out result of computation
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>arg1:    <i>double</i></dt><dd>
<p>
       Handle arg1
</p></dd>
<dt>arg2:    <i>double</i></dt><dd>
<p>
       Handle arg2
</p></dd>
<dt>arg3:    <i>double</i></dt><dd>
<p>
       Handle arg3
</p></dd>
<dt>arg4:    <i>double</i></dt><dd>
<p>
       Handle arg4
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handle process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handle reinit call
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-46" class="outline-3">
<h3 id="sec-46"><span class="section-number-3">46</span> Mdouble</h3>
<div class="outline-text-3" id="text-46">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>this:    <i>double</i></dt><dd>
<p>
       Access function for entire Mdouble object.
</p></dd>
<dt>value:   <i>double</i></dt><dd>
<p>
       Access function for value field of Mdouble object,which happens also to be the entire contents of the object.
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-47" class="outline-3">
<h3 id="sec-47"><span class="section-number-3">47</span> MeshEntry</h3>
<div class="outline-text-3" id="text-47">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>size:    <i>double</i></dt><dd>
<p>
       Volume of this MeshEntry
</p></dd>
<dt>dimensions:      <i>unsigned int</i></dt><dd>
<p>
       number of dimensions of this MeshEntry
</p></dd>
<dt>meshType:        <i>unsigned int</i></dt><dd>
<p>
        The MeshType defines the shape of the mesh entry. 0: Not assigned 1: cuboid 2: cylinder 3. cylindrical shell 4: cylindrical shell segment 5: sphere 6: spherical shell 7: spherical shell segment 8: Tetrahedral
</p></dd>
<dt>Coordinates:     <i>vector&lt;double&gt;</i></dt><dd>
<p>
       Coordinates that define current MeshEntry. Depend on MeshType.
</p></dd>
<dt>neighbors:       <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Indices of other MeshEntries that this one connects to
</p></dd>
<dt>DiffusionArea:   <i>vector&lt;double&gt;</i></dt><dd>
<p>
       Diffusion area for geometry of interface
</p></dd>
<dt>DiffusionScaling:        <i>vector&lt;double&gt;</i></dt><dd>
<p>
       Diffusion scaling for geometry of interface
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>remesh:  <i>double,unsigned int,unsigned int,vector&lt;unsigned int&gt;,vector&lt;double&gt;</i></dt><dd>
<p>
       Tells the target pool or other entity that the compartment subdivision(meshing) has changed, and that it has to redo its volume and memory allocation accordingly.Arguments are: oldvol, numTotalEntries, startEntry, localIndices, volsThe vols specifies volumes of each local mesh entry. It also specifieshow many meshEntries are present on the local node.The localIndices vector is used for general load balancing only.It has a list of the all meshEntries on current node.If it is empty, we assume block load balancing. In this secondcase the contents of the current node go from startEntry to startEntry + vols.size().
</p></dd>
<dt>remeshReacs:     <i>void</i></dt><dd>
<p>
       Tells connected enz or reac that the compartment subdivision(meshing) has changed, and that it has to redo its volume-dependent rate terms like numKf_ accordingly.
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>group:   <i>void</i></dt><dd>
<p>
       Handle for grouping. Doesn't do anything.
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-48" class="outline-3">
<h3 id="sec-48"><span class="section-number-3">48</span> MgBlock</h3>
<div class="outline-text-3" id="text-48">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>Gbar:    <i>double</i></dt><dd>
<p>
       Maximal channel conductance
</p></dd>
<dt>Ek:      <i>double</i></dt><dd>
<p>
       Reversal potential of channel
</p></dd>
<dt>Gk:      <i>double</i></dt><dd>
<p>
       Channel conductance variable
</p></dd>
<dt>Ik:      <i>double</i></dt><dd>
<p>
       Channel current variable
</p></dd>
<dt>KMg<sub>A</sub>:   <i>double</i></dt><dd>
<p>
       1/eta
</p></dd>
<dt>KMg<sub>B</sub>:   <i>double</i></dt><dd>
<p>
       1/gamma
</p></dd>
<dt>CMg:     <i>double</i></dt><dd>
<p>
       [Mg] in mM
</p></dd>
<dt>Ik:      <i>double</i></dt><dd>
<p>
       Current through MgBlock
</p></dd>
<dt>Zk:      <i>double</i></dt><dd>
<p>
       Charge on ion
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>channelOut:      <i>double,double</i></dt><dd>
<p>
       Sends channel variables Gk and Ek to compartment
</p></dd>
<dt>permeability:    <i>double</i></dt><dd>
<p>
       Conductance term going out to GHK object
</p></dd>
<dt>IkOut:   <i>double</i></dt><dd>
<p>
       Channel current. This message typically goes to concenobjects that keep track of ion concentration.
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>Vm:      <i>double</i></dt><dd>
<p>
       Handles Vm message coming in from compartment
</p></dd>
<dt>Vm:      <i>double</i></dt><dd>
<p>
       Handles Vm message coming in from compartment
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>origChannel:     <i>double,double</i></dt><dd>
</dd>
</dl>

</li>
</ul>



<ul>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-49" class="outline-3">
<h3 id="sec-49"><span class="section-number-3">49</span> Msg</h3>
<div class="outline-text-3" id="text-49">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>e1:      <i>Id</i></dt><dd>
<p>
       Id of source Element.
</p></dd>
<dt>e2:      <i>Id</i></dt><dd>
<p>
       Id of source Element.
</p></dd>
<dt>srcFieldsOnE1:   <i>vector&lt;string&gt;</i></dt><dd>
<p>
       Names of SrcFinfos for messages going from e1 to e2. There arematching entries in the destFieldsOnE2 vector
</p></dd>
<dt>destFieldsOnE2:  <i>vector&lt;string&gt;</i></dt><dd>
<p>
       Names of DestFinfos for messages going from e1 to e2. There arematching entries in the srcFieldsOnE1 vector
</p></dd>
<dt>srcFieldsOnE2:   <i>vector&lt;string&gt;</i></dt><dd>
<p>
       Names of SrcFinfos for messages going from e2 to e1. There arematching entries in the destFieldsOnE1 vector
</p></dd>
<dt>destFieldsOnE1:  <i>vector&lt;string&gt;</i></dt><dd>
<p>
       Names of destFinfos for messages going from e2 to e1. There arematching entries in the srcFieldsOnE2 vector
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-50" class="outline-3">
<h3 id="sec-50"><span class="section-number-3">50</span> Mstring</h3>
<div class="outline-text-3" id="text-50">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>this:    <i>string</i></dt><dd>
<p>
       Access function for entire Mstring object.
</p></dd>
<dt>value:   <i>string</i></dt><dd>
<p>
       Access function for value field of Mstring object,which happens also to be the entire contents of the object.
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-51" class="outline-3">
<h3 id="sec-51"><span class="section-number-3">51</span> NMDAChan</h3>
<div class="outline-text-3" id="text-51">

<p>   Author:              Subhasis Ray, 2010, NCBS
</p>
<p>   
   Description:         NMDAChan: Extracellular [Mg2+] dependent NMDA channel.This channel has four states as described by Jahr and Stevens (J. Neurosci. 1990, 10(9)) This implementation is based on equation 4(a) in that article. The channel conductance is defined as : k * g(V, [Mg2+]o) * S(t) where k is a scaling constant. S(t) is the legand gated component of the conductance. It rises linearly for t = tau2. Then decays exponentially with time constant t = tau1. g is a function of voltage and the extracellular [Mg2+] defined as: 1 / { 1 + (a1 + a2) * (a1 * B1 + a2 * B2)/ [A * a1 * (b1 + B1) + A * a2 * (b2 + B2)]} a1 = 1e3 * exp( - c0 * V - c1) s<sup>-1</sup>, c0 = 16.0 / V, c1 = 2.91 a2 = 1e-3 * [Mg2+] * exp( -c2 * V - c3) mM<sup>-1</sup> s, c2 = 45.0 / V, c3 = 6.97 b1 = 1e3 * exp(c4  * V + c5) s<sup>-1</sup>, c4 = 9.0 / V, c5 = 1.22 b2 = 1e3 * exp(c6 * V + c7) s<sup>-1</sup>, c6 = 17.0 / V, c7 = 0.96 A = 1e3 * exp(-c8) s<sup>-1</sup>, c8 = 2.847 B1 = 1e3 * exp(-c9) s<sup>-1</sup>, c9 = 0.693 s<sup>-1</sup> B2 = 1e3 * exp(-c10) s<sup>-1</sup>, c10 = 3.101. The behaviour of S(t) is as follows: If a spike arrives, then the slope of the linear rise of S(t) is incremented by weight / tau2. After tau2 time, this component is removed from the slope (reduced by weight/tau) and added over to the rate of decay of S(t).
</p>
<p>   
   Name:                NMDAChan
</p>
<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>numSynapses:     <i>unsigned int</i></dt><dd>
<p>
       Number of synapses on SynBase
</p></dd>
<dt>Gbar:    <i>double</i></dt><dd>
<p>
       Maximal channel conductance
</p></dd>
<dt>Ek:      <i>double</i></dt><dd>
<p>
       Reversal potential of channel
</p></dd>
<dt>Gk:      <i>double</i></dt><dd>
<p>
       Channel conductance variable
</p></dd>
<dt>Ik:      <i>double</i></dt><dd>
<p>
       Channel current variable
</p></dd>
<dt>tau1:    <i>double</i></dt><dd>
<p>
       Decay time constant for the synaptic conductance, tau1 &gt;= tau2.
</p></dd>
<dt>tau2:    <i>double</i></dt><dd>
<p>
       Rise time constant for the synaptic conductance, tau1 &gt;= tau2.
</p></dd>
<dt>normalizeWeights:        <i>bool</i></dt><dd>
<p>
       Flag. If true, the overall conductance is normalized by the number of individual synapses in this SynChan object.
</p></dd>
<dt>unblocked:       <i>double</i></dt><dd>
<p>
       Fraction of channels recovered from Mg2+ block. This is an intermediate variable which corresponds to g(V, [Mg2+]o)  in the equation for conductance: k * g(V, [Mg2+]o) * S(t) where k is a constant.
</p></dd>
<dt>MgConc:  <i>double</i></dt><dd>
<p>
       External Mg2+ concentration
</p></dd>
<dt>unblocked:       <i>double</i></dt><dd>
<p>
       Fraction of channels recovered from Mg2+ block. This is an intermediate variable which corresponds to g(V, [Mg2+]o)  in the equation for conductance: k * g(V, [Mg2+]o) * S(t) where k is a constant.
</p></dd>
<dt>saturation:      <i>double</i></dt><dd>
<p>
       Upper limit on the NMDA conductance.
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>channelOut:      <i>double,double</i></dt><dd>
<p>
       Sends channel variables Gk and Ek to compartment
</p></dd>
<dt>permeability:    <i>double</i></dt><dd>
<p>
       Conductance term going out to GHK object
</p></dd>
<dt>IkOut:   <i>double</i></dt><dd>
<p>
       Channel current. This message typically goes to concenobjects that keep track of ion concentration.
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>Vm:      <i>double</i></dt><dd>
<p>
       Handles Vm message coming in from compartment
</p></dd>
<dt>Vm:      <i>double</i></dt><dd>
<p>
       Handles Vm message coming in from compartment
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call
</p></dd>
<dt>activation:      <i>double</i></dt><dd>
<p>
       Sometimes we want to continuously activate the channel
</p></dd>
<dt>modulator:       <i>double</i></dt><dd>
<p>
       Modulate channel response
</p></dd>
<dt>MgConcDest:      <i>double</i></dt><dd>
<p>
       Update [Mg2+] from other sources at every time step.
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
<dt>c:       <i>unsigned int,double</i></dt><dd>
<p>
       Transition parameters c0 to c10 in the Mg2+ dependentstate transitions.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-52" class="outline-3">
<h3 id="sec-52"><span class="section-number-3">52</span> Nernst</h3>
<div class="outline-text-3" id="text-52">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>E:       <i>double</i></dt><dd>
<p>
       Computed reversal potential
</p></dd>
<dt>Temperature:     <i>double</i></dt><dd>
<p>
       Temperature of cell
</p></dd>
<dt>valence: <i>int</i></dt><dd>
<p>
       Valence of ion in Nernst calculation
</p></dd>
<dt>Cin:     <i>double</i></dt><dd>
<p>
       Internal conc of ion
</p></dd>
<dt>Cout:    <i>double</i></dt><dd>
<p>
       External conc of ion
</p></dd>
<dt>scale:   <i>double</i></dt><dd>
<p>
       Voltage scale factor
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>Eout:    <i>double</i></dt><dd>
<p>
       Computed reversal potential
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>ci:      <i>double</i></dt><dd>
<p>
       Set internal conc of ion, and immediately send out the updated E
</p></dd>
<dt>co:      <i>double</i></dt><dd>
<p>
       Set external conc of ion, and immediately send out the updated E
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-53" class="outline-3">
<h3 id="sec-53"><span class="section-number-3">53</span> NeuroMesh</h3>
<div class="outline-text-3" id="text-53">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>size:    <i>double</i></dt><dd>
<p>
       Size of entire chemical domain.Assigning this assumes that the geometry is that of the default mesh, which may not be what you want. If so, usea more specific mesh assignment function.
</p></dd>
<dt>numDimensions:   <i>unsigned int</i></dt><dd>
<p>
       Number of spatial dimensions of this compartment. Usually 3 or 2
</p></dd>
<dt>cell:    <i>Id</i></dt><dd>
<p>
       Id for base element of cell model. Uses this to traverse theentire tree of the cell to build the mesh.
</p></dd>
<dt>subTree: <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       Set of compartments to model. If they happen to be contiguousthen also set up diffusion between the compartments. Can alsohandle cases where the same cell is divided into multiplenon-diffusively-coupled compartments
</p></dd>
<dt>skipSpines:      <i>bool</i></dt><dd>
<p>
       Flag: when skipSpines is true, the traversal does not includeany compartment with the string 'spine' or 'neck' in its name,and also then skips compartments below this skipped one.Allows to set up separate mesh for spines, based on the same cell model.
</p></dd>
<dt>numSegments:     <i>unsigned int</i></dt><dd>
<p>
       Number of cylindrical/spherical segments in model
</p></dd>
<dt>numDiffCompts:   <i>unsigned int</i></dt><dd>
<p>
       Number of diffusive compartments in model
</p></dd>
<dt>diffLength:      <i>double</i></dt><dd>
<p>
       Diffusive length constant to use for subdivisions. The system willattempt to subdivide cell using diffusive compartments ofthe specified diffusion lengths as a maximum.In order to get integral numbersof compartments in each segment, it may subdivide more finely.Uses default of 0.5 microns, that is, half typical lambda.For default, consider a tau of about 1 second for mostreactions, and a diffusion const of about 1e-12 um<sup>2</sup>/sec.This gives lambda of 1 micron
</p></dd>
<dt>geometryPolicy:  <i>string</i></dt><dd>
<p>
       Policy for how to interpret electrical model geometry (which is a branching 1-dimensional tree) in terms of 3-D constructslike spheres, cylinders, and cones.There are three options, default, trousers, and cylinder:default mode: - Use frustrums of cones. Distal diameter is always from compt dia. - For linear dendrites (no branching), proximal diameter is  diameter of the parent compartment - For branching dendrites and dendrites emerging from soma, proximal diameter is from compt dia. Don't worry about overlap. - Place somatic dendrites on surface of spherical soma, or at ends of cylindrical soma - Place dendritic spines on surface of cylindrical dendrites, not emerging from their middle.trousers mode: - Use frustrums of cones. Distal diameter is always from compt dia. - For linear dendrites (no branching), proximal diameter is  diameter of the parent compartment - For branching dendrites, use a trouser function. Avoid overlap. - For soma, use some variant of trousers. Here we must avoid overlap - For spines, use a way to smoothly merge into parent dend. Radius of curvature should be similar to that of the spine neck. - Place somatic dendrites on surface of spherical soma, or at ends of cylindrical soma - Place dendritic spines on surface of cylindrical dendrites, not emerging from their middle.cylinder mode: - Use cylinders. Diameter is just compartment dia. - Place somatic dendrites on surface of spherical soma, or at ends of cylindrical soma - Place dendritic spines on surface of cylindrical dendrites, not emerging from their middle. - Ignore spatial overlap.
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>meshSplit:       <i>double,vector&lt;double&gt;,vector&lt;unsigned int&gt;,vector&lt; vector&lt;unsigned int&gt; &gt;,vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Defines how meshEntries communicate between nodes.Args: oldVol, volListOfAllEntries, localEntryList, outgoingDiffusion[node#][entry#], incomingDiffusion[node#][entry#]This message is meant to go to the SimManager and Stoich.
</p></dd>
<dt>meshStats:       <i>unsigned int,vector&lt;double&gt;</i></dt><dd>
<p>
       Basic statistics for mesh: Total # of entries, and a vector ofunique volumes of voxels
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>buildDefaultMesh:        <i>double,unsigned int</i></dt><dd>
<p>
       Tells ChemMesh derived class to build a default mesh with thespecified size and number of meshEntries.
</p></dd>
<dt>handleRequestMeshStats:  <i>void</i></dt><dd>
<p>
       Handles request from SimManager for mesh stats
</p></dd>
<dt>handleNodeInfo:  <i>unsigned int,unsigned int</i></dt><dd>
<p>
       Tells ChemMesh how many nodes and threads per node it is allowed to use. Triggers a return meshSplit message.
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-54" class="outline-3">
<h3 id="sec-54"><span class="section-number-3">54</span> Neuron</h3>
<div class="outline-text-3" id="text-54">

<p>   Author:              C H Chaitanya
</p>
<p>   
   Description:         Neuron - A compartment container
</p>
<p>   
   Name:                Neuron
</p>
<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-55" class="outline-3">
<h3 id="sec-55"><span class="section-number-3">55</span> Neutral</h3>
<div class="outline-text-3" id="text-55">

<p>   Author:              Upinder S. Bhalla, 2007, NCBS
</p>
<p>   
   Description:         Neutral: Base class for all MOOSE classes. Providesaccess functions for housekeeping fields and operations, messagetraversal, and so on.
</p>
<p>   
   Name:                Neutral
</p>
<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-56" class="outline-3">
<h3 id="sec-56"><span class="section-number-3">56</span> OneToAllMsg</h3>
<div class="outline-text-3" id="text-56">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>e1:      <i>Id</i></dt><dd>
<p>
       Id of source Element.
</p></dd>
<dt>e2:      <i>Id</i></dt><dd>
<p>
       Id of source Element.
</p></dd>
<dt>srcFieldsOnE1:   <i>vector&lt;string&gt;</i></dt><dd>
<p>
       Names of SrcFinfos for messages going from e1 to e2. There arematching entries in the destFieldsOnE2 vector
</p></dd>
<dt>destFieldsOnE2:  <i>vector&lt;string&gt;</i></dt><dd>
<p>
       Names of DestFinfos for messages going from e1 to e2. There arematching entries in the srcFieldsOnE1 vector
</p></dd>
<dt>srcFieldsOnE2:   <i>vector&lt;string&gt;</i></dt><dd>
<p>
       Names of SrcFinfos for messages going from e2 to e1. There arematching entries in the destFieldsOnE1 vector
</p></dd>
<dt>destFieldsOnE1:  <i>vector&lt;string&gt;</i></dt><dd>
<p>
       Names of destFinfos for messages going from e2 to e1. There arematching entries in the srcFieldsOnE2 vector
</p></dd>
<dt>i1:      <i>DataId</i></dt><dd>
<p>
       DataId of source Element.
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-57" class="outline-3">
<h3 id="sec-57"><span class="section-number-3">57</span> OneToOneMsg</h3>
<div class="outline-text-3" id="text-57">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>e1:      <i>Id</i></dt><dd>
<p>
       Id of source Element.
</p></dd>
<dt>e2:      <i>Id</i></dt><dd>
<p>
       Id of source Element.
</p></dd>
<dt>srcFieldsOnE1:   <i>vector&lt;string&gt;</i></dt><dd>
<p>
       Names of SrcFinfos for messages going from e1 to e2. There arematching entries in the destFieldsOnE2 vector
</p></dd>
<dt>destFieldsOnE2:  <i>vector&lt;string&gt;</i></dt><dd>
<p>
       Names of DestFinfos for messages going from e1 to e2. There arematching entries in the srcFieldsOnE1 vector
</p></dd>
<dt>srcFieldsOnE2:   <i>vector&lt;string&gt;</i></dt><dd>
<p>
       Names of SrcFinfos for messages going from e2 to e1. There arematching entries in the destFieldsOnE1 vector
</p></dd>
<dt>destFieldsOnE1:  <i>vector&lt;string&gt;</i></dt><dd>
<p>
       Names of destFinfos for messages going from e2 to e1. There arematching entries in the srcFieldsOnE2 vector
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-58" class="outline-3">
<h3 id="sec-58"><span class="section-number-3">58</span> PIDController</h3>
<div class="outline-text-3" id="text-58">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>gain:    <i>double</i></dt><dd>
<p>
       This is the proportional gain (Kp). This tuning parameter scales the proportional term. Larger gain usually results in faster response, but too much will lead to instability and oscillation.
</p></dd>
<dt>saturation:      <i>double</i></dt><dd>
<p>
       Bound on the permissible range of output. Defaults to maximum double value.
</p></dd>
<dt>command: <i>double</i></dt><dd>
<p>
       The command (desired) value of the sensed parameter. In control theory this is commonly known as setpoint(SP).
</p></dd>
<dt>sensed:  <i>double</i></dt><dd>
<p>
       Sensed (measured) value. This is commonly known as process variable(PV) in control theory.
</p></dd>
<dt>tauI:    <i>double</i></dt><dd>
<p>
       The integration time constant, typically = dt. This is actually proportional gain divided by integral gain (Kp/Ki)). Larger Ki (smaller tauI) usually leads to fast elimination of steady state errors at the cost of larger overshoot.
</p></dd>
<dt>tauD:    <i>double</i></dt><dd>
<p>
       The differentiation time constant, typically = dt / 4. This is derivative gain (Kd) times proportional gain (Kp). Larger Kd (tauD) decreases overshoot at the cost of slowing down transient response and may lead to instability.
</p></dd>
<dt>output:  <i>double</i></dt><dd>
<p>
       Output of the PIDController. This is given by:      gain * ( error + INTEGRAL[ error dt ] / tau<sub>i</sub>   + tau<sub>d</sub> * d(error)/dt )
       Where gain = proportional gain (Kp), tau<sub>i</sub> = integral gain (Kp/Ki) and tau<sub>d</sub> = derivative gain (Kd/Kp). In control theory this is also known as the manipulated variable (MV)
</p></dd>
<dt>error:   <i>double</i></dt><dd>
<p>
       The error term, which is the difference between command and sensed value.
</p></dd>
<dt>integral:        <i>double</i></dt><dd>
<p>
       The integral term. It is calculated as INTEGRAL(error dt) = previous<sub>integral</sub> + dt * (error + e<sub>previous</sub>)/2.
</p></dd>
<dt>derivative:      <i>double</i></dt><dd>
<p>
       The derivative term. This is (error - e<sub>previous</sub>)/dt.
</p></dd>
<dt>e<sub>previous</sub>:      <i>double</i></dt><dd>
<p>
       The error term for previous step.
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>outputOut:       <i>double</i></dt><dd>
<p>
       Sends the output of the PIDController. This is known as manipulated variable (MV) in control theory. This should be fed into the process which we are trying to control.
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>commandIn:       <i>double</i></dt><dd>
<p>
       Command (desired value) input. This is known as setpoint (SP) in control theory.
</p></dd>
<dt>sensedIn:        <i>double</i></dt><dd>
<p>
       Sensed parameter - this is the one to be tuned. This is known as process variable (PV) in control theory. This comes from the process we are trying to control.
</p></dd>
<dt>gainDest:        <i>double</i></dt><dd>
<p>
       Destination message to control the PIDController gain dynamically.
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handle process calls.
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Reinitialize the object.
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-59" class="outline-3">
<h3 id="sec-59"><span class="section-number-3">59</span> Panel</h3>
<div class="outline-text-3" id="text-59">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>nPts:    <i>unsigned int</i></dt><dd>
<p>
       Number of points used by panel to specify geometry
</p></dd>
<dt>nDims:   <i>unsigned int</i></dt><dd>
<p>
       Number of Dimensions used by panel to specify geometry
</p></dd>
<dt>numNeighbors:    <i>unsigned int</i></dt><dd>
<p>
       Number of Neighbors of panel
</p></dd>
<dt>shapeId: <i>unsigned int</i></dt><dd>
<p>
       Identifier for shape type, as used by Smoldyn
</p></dd>
<dt>coords:  <i>vector&lt;double&gt;</i></dt><dd>
<p>
       All the coordinates for the panel. X vector, then Y, then ZZ can be left out for 2-D panels.Z and Y can be left out for 1-D panels.
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>toNeighbor:      <i>void</i></dt><dd>
<p>
       Identifies neighbors of the current panel
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>neighbor:        <i>void</i></dt><dd>
<p>
       Handles incoming message from neighbor
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
<dt>x:       <i>unsigned int,double</i></dt><dd>
<p>
       x coordinate identified by index
</p></dd>
<dt>y:       <i>unsigned int,double</i></dt><dd>
<p>
       y coordinate identified by index
</p></dd>
<dt>z:       <i>unsigned int,double</i></dt><dd>
<p>
       z coordinate identified by index
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-60" class="outline-3">
<h3 id="sec-60"><span class="section-number-3">60</span> Pool</h3>
<div class="outline-text-3" id="text-60">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>n:       <i>double</i></dt><dd>
<p>
       Number of molecules in pool
</p></dd>
<dt>nInit:   <i>double</i></dt><dd>
<p>
       Initial value of number of molecules in pool
</p></dd>
<dt>diffConst:       <i>double</i></dt><dd>
<p>
       Diffusion constant of molecule
</p></dd>
<dt>conc:    <i>double</i></dt><dd>
<p>
       Concentration of molecules in this pool
</p></dd>
<dt>concInit:        <i>double</i></dt><dd>
<p>
       Initial value of molecular concentration in pool
</p></dd>
<dt>size:    <i>double</i></dt><dd>
<p>
       Size of compartment. Units are SI. Utility field, the actual size info is stored on a volume mesh entry in the parent compartment.This is hooked up by a message. If the message isn'tavailable size is just taken as 1
</p></dd>
<dt>speciesId:       <i>unsigned int</i></dt><dd>
<p>
       Species identifier for this mol pool. Eventually link to ontology.
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>nOut:    <i>double</i></dt><dd>
<p>
       Sends out # of molecules in pool on each timestep
</p></dd>
<dt>requestMolWt:    <i>void</i></dt><dd>
<p>
       Requests Species object for mol wt
</p></dd>
<dt>requestSize:     <i>double</i></dt><dd>
<p>
       Requests Size of pool from matching mesh entry
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>group:   <i>void</i></dt><dd>
<p>
       Handle for grouping. Doesn't do anything.
</p></dd>
<dt>reacDest:        <i>double,double</i></dt><dd>
<p>
       Handles reaction input
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call
</p></dd>
<dt>handleMolWt:     <i>double</i></dt><dd>
<p>
       Separate finfo to assign molWt, and consequently diffusion const.Should only be used in SharedMsg with species.
</p></dd>
<dt>remesh:  <i>double,unsigned int,unsigned int,vector&lt;unsigned int&gt;,vector&lt;double&gt;</i></dt><dd>
<p>
       Handle commands to remesh the pool. This may involve changing the number of pool entries, as well as changing their volumes
</p></dd>
<dt>increment:       <i>double</i></dt><dd>
<p>
       Increments mol numbers by specified amount. Can be +ve or -ve
</p></dd>
<dt>decrement:       <i>double</i></dt><dd>
<p>
       Decrements mol numbers by specified amount. Can be +ve or -ve
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-61" class="outline-3">
<h3 id="sec-61"><span class="section-number-3">61</span> PoolBase</h3>
<div class="outline-text-3" id="text-61">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>n:       <i>double</i></dt><dd>
<p>
       Number of molecules in pool
</p></dd>
<dt>nInit:   <i>double</i></dt><dd>
<p>
       Initial value of number of molecules in pool
</p></dd>
<dt>diffConst:       <i>double</i></dt><dd>
<p>
       Diffusion constant of molecule
</p></dd>
<dt>conc:    <i>double</i></dt><dd>
<p>
       Concentration of molecules in this pool
</p></dd>
<dt>concInit:        <i>double</i></dt><dd>
<p>
       Initial value of molecular concentration in pool
</p></dd>
<dt>size:    <i>double</i></dt><dd>
<p>
       Size of compartment. Units are SI. Utility field, the actual size info is stored on a volume mesh entry in the parent compartment.This is hooked up by a message. If the message isn'tavailable size is just taken as 1
</p></dd>
<dt>speciesId:       <i>unsigned int</i></dt><dd>
<p>
       Species identifier for this mol pool. Eventually link to ontology.
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>nOut:    <i>double</i></dt><dd>
<p>
       Sends out # of molecules in pool on each timestep
</p></dd>
<dt>requestMolWt:    <i>void</i></dt><dd>
<p>
       Requests Species object for mol wt
</p></dd>
<dt>requestSize:     <i>double</i></dt><dd>
<p>
       Requests Size of pool from matching mesh entry
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>group:   <i>void</i></dt><dd>
<p>
       Handle for grouping. Doesn't do anything.
</p></dd>
<dt>reacDest:        <i>double,double</i></dt><dd>
<p>
       Handles reaction input
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call
</p></dd>
<dt>handleMolWt:     <i>double</i></dt><dd>
<p>
       Separate finfo to assign molWt, and consequently diffusion const.Should only be used in SharedMsg with species.
</p></dd>
<dt>remesh:  <i>double,unsigned int,unsigned int,vector&lt;unsigned int&gt;,vector&lt;double&gt;</i></dt><dd>
<p>
       Handle commands to remesh the pool. This may involve changing the number of pool entries, as well as changing their volumes
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-62" class="outline-3">
<h3 id="sec-62"><span class="section-number-3">62</span> Port</h3>
<div class="outline-text-3" id="text-62">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>scaleOutRate:    <i>double</i></dt><dd>
<p>
       Scaling factor for outgoing rates. Applies to the RateTermscontrolled by this port. Represents a diffusion related term,or the permeability of the port
</p></dd>
<dt>inStart: <i>unsigned int</i></dt><dd>
<p>
       Start index to S_ vector into which incoming molecules should add.
</p></dd>
<dt>inEnd:   <i>unsigned int</i></dt><dd>
<p>
       End index to S_ vector into which incoming molecules should add.
</p></dd>
<dt>outStart:        <i>unsigned int</i></dt><dd>
<p>
       Start index to S_ vector from where outgoing molecules come.
</p></dd>
<dt>outEnd:  <i>unsigned int</i></dt><dd>
<p>
       End index to S_ vector from where outgoing molecules come.
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>availableMolsAtPort:     <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       Sends out the full set of molecule Ids that are available for data transfer
</p></dd>
<dt>efflux:  <i>vector&lt;double&gt;</i></dt><dd>
<p>
       Molecule #s going out
</p></dd>
<dt>matchedMolsAtPort:       <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       Sends out the set of molecule Ids that match between both ports
</p></dd>
<dt>efflux:  <i>vector&lt;double&gt;</i></dt><dd>
<p>
       Molecule #s going out
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>handleMatchedMolsAtPort: <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Handles list of matched molecules worked out by the other port
</p></dd>
<dt>influx:  <i>vector&lt;double&gt;</i></dt><dd>
<p>
       Molecule #s coming back in
</p></dd>
<dt>handleAvailableMolsAtPort:       <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Handles list of all species that the other port cares about
</p></dd>
<dt>influx:  <i>vector&lt;double&gt;</i></dt><dd>
<p>
       Molecule #s coming back in
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-63" class="outline-3">
<h3 id="sec-63"><span class="section-number-3">63</span> PulseGen</h3>
<div class="outline-text-3" id="text-63">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>output:  <i>double</i></dt><dd>
<p>
       Output amplitude
</p></dd>
<dt>baseLevel:       <i>double</i></dt><dd>
<p>
       Basal level of the stimulus
</p></dd>
<dt>firstLevel:      <i>double</i></dt><dd>
<p>
       Amplitude of the first pulse in a sequence
</p></dd>
<dt>firstWidth:      <i>double</i></dt><dd>
<p>
       Width of the first pulse in a sequence
</p></dd>
<dt>firstDelay:      <i>double</i></dt><dd>
<p>
       Delay to start of the first pulse in a sequence
</p></dd>
<dt>secondLevel:     <i>double</i></dt><dd>
<p>
       Amplitude of the second pulse in a sequence
</p></dd>
<dt>secondWidth:     <i>double</i></dt><dd>
<p>
       Width of the second pulse in a sequence
</p></dd>
<dt>secondDelay:     <i>double</i></dt><dd>
<p>
       Delay to start of of the second pulse in a sequence
</p></dd>
<dt>count:   <i>unsigned int</i></dt><dd>
<p>
       Number of pulses in a sequence
</p></dd>
<dt>trigMode:        <i>unsigned int</i></dt><dd>
<p>
       Trigger mode for pulses in the sequence.
        0 : free-running mode where it keeps looping its output
        1 : external trigger, where it is triggered by an external input (and stops after creating the first train of pulses)
        2 : external gate mode, where it keeps generating the pulses in a loop as long as the input is high.
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>outputOut:       <i>double</i></dt><dd>
<p>
       Current output level.
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>input:   <i>double</i></dt><dd>
<p>
       Handle incoming input that determines gating/triggering onset.
</p></dd>
<dt>levelIn: <i>unsigned int,double</i></dt><dd>
<p>
       Handle level value coming from other objects
</p></dd>
<dt>widthIn: <i>unsigned int,double</i></dt><dd>
<p>
       Handle width value coming from other objects
</p></dd>
<dt>delayIn: <i>unsigned int,double</i></dt><dd>
<p>
       Handle delay value coming from other objects
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call, updates internal time stamp.
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call.
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
<dt>level:   <i>unsigned int,double</i></dt><dd>
<p>
       Level of the pulse at specified index
</p></dd>
<dt>width:   <i>unsigned int,double</i></dt><dd>
<p>
       Width of the pulse at specified index
</p></dd>
<dt>delay:   <i>unsigned int,double</i></dt><dd>
<p>
       Delay of the pulse at specified index
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-64" class="outline-3">
<h3 id="sec-64"><span class="section-number-3">64</span> RC</h3>
<div class="outline-text-3" id="text-64">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>V0:      <i>double</i></dt><dd>
<p>
       Initial value of 'state'
</p></dd>
<dt>R:       <i>double</i></dt><dd>
<p>
       Series resistance of the RC circuit.
</p></dd>
<dt>C:       <i>double</i></dt><dd>
<p>
       Parallel capacitance of the RC circuit.
</p></dd>
<dt>state:   <i>double</i></dt><dd>
<p>
       Output value of the RC circuit. This is the voltage across the capacitor.
</p></dd>
<dt>inject:  <i>double</i></dt><dd>
<p>
       Input value to the RC circuit.This is handled as an input current to the circuit.
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>outputOut:       <i>double</i></dt><dd>
<p>
       Current output level.
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>injectIn:        <i>double</i></dt><dd>
<p>
       Receives input to the RC circuit. All incoming messages are summed up to give the total input current.
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call.
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handle reinitialization
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-65" class="outline-3">
<h3 id="sec-65"><span class="section-number-3">65</span> Reac</h3>
<div class="outline-text-3" id="text-65">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>kf:      <i>double</i></dt><dd>
<p>
       Forward rate constant, in # units
</p></dd>
<dt>kb:      <i>double</i></dt><dd>
<p>
       Reverse rate constant, in # units
</p></dd>
<dt>Kf:      <i>double</i></dt><dd>
<p>
       Forward rate constant, in concentration units
</p></dd>
<dt>Kb:      <i>double</i></dt><dd>
<p>
       Reverse rate constant, in concentration units
</p></dd>
<dt>numSubstrates:   <i>unsigned int</i></dt><dd>
<p>
       Number of substrates of reaction
</p></dd>
<dt>numProducts:     <i>unsigned int</i></dt><dd>
<p>
       Number of products of reaction
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>toSub:   <i>double,double</i></dt><dd>
<p>
       Sends out increment of molecules on product each timestep
</p></dd>
<dt>toPrd:   <i>double,double</i></dt><dd>
<p>
       Sends out increment of molecules on product each timestep
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>subDest: <i>double</i></dt><dd>
<p>
       Handles # of molecules of substrate
</p></dd>
<dt>prdDest: <i>double</i></dt><dd>
<p>
       Handles # of molecules of product
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call
</p></dd>
<dt>remesh:  <i>void</i></dt><dd>
<p>
       Tells the reac to recompute its numRates, as remeshing has happened
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-66" class="outline-3">
<h3 id="sec-66"><span class="section-number-3">66</span> ReacBase</h3>
<div class="outline-text-3" id="text-66">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>kf:      <i>double</i></dt><dd>
<p>
       Forward rate constant, in # units
</p></dd>
<dt>kb:      <i>double</i></dt><dd>
<p>
       Reverse rate constant, in # units
</p></dd>
<dt>Kf:      <i>double</i></dt><dd>
<p>
       Forward rate constant, in concentration units
</p></dd>
<dt>Kb:      <i>double</i></dt><dd>
<p>
       Reverse rate constant, in concentration units
</p></dd>
<dt>numSubstrates:   <i>unsigned int</i></dt><dd>
<p>
       Number of substrates of reaction
</p></dd>
<dt>numProducts:     <i>unsigned int</i></dt><dd>
<p>
       Number of products of reaction
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>toSub:   <i>double,double</i></dt><dd>
<p>
       Sends out increment of molecules on product each timestep
</p></dd>
<dt>toPrd:   <i>double,double</i></dt><dd>
<p>
       Sends out increment of molecules on product each timestep
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>subDest: <i>double</i></dt><dd>
<p>
       Handles # of molecules of substrate
</p></dd>
<dt>prdDest: <i>double</i></dt><dd>
<p>
       Handles # of molecules of product
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call
</p></dd>
<dt>remesh:  <i>void</i></dt><dd>
<p>
       Tells the reac to recompute its numRates, as remeshing has happened
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-67" class="outline-3">
<h3 id="sec-67"><span class="section-number-3">67</span> RectPanel</h3>
<div class="outline-text-3" id="text-67">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>nPts:    <i>unsigned int</i></dt><dd>
<p>
       Number of points used by panel to specify geometry
</p></dd>
<dt>nDims:   <i>unsigned int</i></dt><dd>
<p>
       Number of Dimensions used by panel to specify geometry
</p></dd>
<dt>numNeighbors:    <i>unsigned int</i></dt><dd>
<p>
       Number of Neighbors of panel
</p></dd>
<dt>shapeId: <i>unsigned int</i></dt><dd>
<p>
       Identifier for shape type, as used by Smoldyn
</p></dd>
<dt>coords:  <i>vector&lt;double&gt;</i></dt><dd>
<p>
       All the coordinates for the panel. X vector, then Y, then ZZ can be left out for 2-D panels.Z and Y can be left out for 1-D panels.
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>toNeighbor:      <i>void</i></dt><dd>
<p>
       Identifies neighbors of the current panel
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>neighbor:        <i>void</i></dt><dd>
<p>
       Handles incoming message from neighbor
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
<dt>x:       <i>unsigned int,double</i></dt><dd>
<p>
       x coordinate identified by index
</p></dd>
<dt>y:       <i>unsigned int,double</i></dt><dd>
<p>
       y coordinate identified by index
</p></dd>
<dt>z:       <i>unsigned int,double</i></dt><dd>
<p>
       z coordinate identified by index
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-68" class="outline-3">
<h3 id="sec-68"><span class="section-number-3">68</span> ReduceMsg</h3>
<div class="outline-text-3" id="text-68">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>e1:      <i>Id</i></dt><dd>
<p>
       Id of source Element.
</p></dd>
<dt>e2:      <i>Id</i></dt><dd>
<p>
       Id of source Element.
</p></dd>
<dt>srcFieldsOnE1:   <i>vector&lt;string&gt;</i></dt><dd>
<p>
       Names of SrcFinfos for messages going from e1 to e2. There arematching entries in the destFieldsOnE2 vector
</p></dd>
<dt>destFieldsOnE2:  <i>vector&lt;string&gt;</i></dt><dd>
<p>
       Names of DestFinfos for messages going from e1 to e2. There arematching entries in the srcFieldsOnE1 vector
</p></dd>
<dt>srcFieldsOnE2:   <i>vector&lt;string&gt;</i></dt><dd>
<p>
       Names of SrcFinfos for messages going from e2 to e1. There arematching entries in the destFieldsOnE1 vector
</p></dd>
<dt>destFieldsOnE1:  <i>vector&lt;string&gt;</i></dt><dd>
<p>
       Names of destFinfos for messages going from e2 to e1. There arematching entries in the srcFieldsOnE2 vector
</p></dd>
<dt>i1:      <i>DataId</i></dt><dd>
<p>
       DataId of source Element.
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-69" class="outline-3">
<h3 id="sec-69"><span class="section-number-3">69</span> Shell</h3>
<div class="outline-text-3" id="text-69">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>reduceArraySize: <i>unsigned int</i></dt><dd>
<p>
       Look up maximum value of an index, here ragged array size,across many nodes, and assign uniformly to all nodes. Normallyfollowed by an operation to assign the size to the object thatwas resized.
</p></dd>
<dt>requestCreate:   <i>string,Id,Id,string,vector&lt;int&gt;</i></dt><dd>
<p>
       requestCreate( class, parent, newElm, name, dimensions ): creates a new Element on all nodes with the specified Id. Initiates a callback to indicate completion of operation. Goes to all nodes including self.
</p></dd>
<dt>requestDelete:   <i>Id</i></dt><dd>
<p>
       requestDelete( doomedElement ):Deletes specified Element on all nodes.Initiates a callback to indicate completion of operation.Goes to all nodes including self.
</p></dd>
<dt>requestAddMsg:   <i>string,unsigned int,ObjId,string,ObjId,string</i></dt><dd>
<p>
       requestAddMsg( type, src, srcField, dest, destField );Creates specified Msg between specified Element on all nodes.Initiates a callback to indicate completion of operation.Goes to all nodes including self.
</p></dd>
<dt>requestQuit:     <i>void</i></dt><dd>
<p>
       requestQuit():Emerges from the inner loop, and wraps up. No return value.
</p></dd>
<dt>move:    <i>Id,Id</i></dt><dd>
<p>
       move( origId, newParent);Moves origId to become a child of newParent
</p></dd>
<dt>copy:    <i>vector&lt;Id&gt;,string,unsigned int,bool,bool</i></dt><dd>
<p>
       copy( origId, newParent, numRepeats, toGlobal, copyExtMsg );Copies origId to become a child of newParent
</p></dd>
<dt>useClock:        <i>string,string,unsigned int</i></dt><dd>
<p>
       useClock( path, field, tick# );Specifies which clock tick to use for all elements in Path.The 'field' is typically process, but some cases need to sendupdates to the 'init' field.Tick # specifies which tick to be attached to the objects.
</p></dd>
<dt>sync:    <i>Id,unsigned int</i></dt><dd>
<p>
       sync( ElementId, FuncId );Synchronizes Element data indexing across all nodes.Used when distributed ops like message setup might set updifferent #s of data entries on Elements on different nodes.The ElementId is the element being synchronized.The FuncId is the 'get' function for the synchronized field.
</p></dd>
<dt>requestReMesh:   <i>Id</i></dt><dd>
<p>
       requestReMesh( meshId );Chops up specified mesh.
</p></dd>
<dt>requestSetParserIdleFlag:        <i>bool</i></dt><dd>
<p>
       SetParserIdleFlag( bool isParserIdle );When True, the main ProcessLoop waits a little each cycleso as to avoid pounding on the CPU.
</p></dd>
<dt>ack:     <i>unsigned int,unsigned int</i></dt><dd>
<p>
       ack( unsigned int node#, unsigned int status ):Acknowledges receipt and completion of a command on a worker node.Goes back only to master node.
</p></dd>
<dt>requestStart:    <i>double</i></dt><dd>
<p>
       requestStart( runtime ):Starts a simulation. Goes to all nodes including self.Initiates a callback to indicate completion of run.
</p></dd>
<dt>requestStep:     <i>unsigned int</i></dt><dd>
<p>
       requestStep():Advances a simulation for the specified # of steps.Goes to all nodes including self.
</p></dd>
<dt>requestStop:     <i>void</i></dt><dd>
<p>
       requestStop():Gently stops a simulation after completing current ops.After this op it is save to do 'start' again, and it willresume where it left offGoes to all nodes including self.
</p></dd>
<dt>requestSetupTick:        <i>unsigned int,double</i></dt><dd>
<p>
       requestSetupTick():Asks the Clock to coordinate the assignment of a specificclock tick. Args: Tick#, dt.Goes to all nodes including self.
</p></dd>
<dt>requestReinit:   <i>void</i></dt><dd>
<p>
       requestReinit():Reinits a simulation: sets to time 0.If simulation is running it stops it first.Goes to all nodes including self.
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>receiveGet:      <i>bad</i></dt><dd>
<p>
       receiveGet( Uint node#, Uint status, PrepackedBuffer data )Function on master shell that handles the value relayed from worker.
</p></dd>
<dt>setclock:        <i>unsigned int,double,bool</i></dt><dd>
<p>
       Assigns clock ticks. Args: tick#, dt
</p></dd>
<dt>handleAck:       <i>unsigned int,unsigned int</i></dt><dd>
<p>
       Keeps track of # of acks to a blocking shell command. Arg: Source node num.
</p></dd>
<dt>create:  <i>string,Id,Id,string,vector&lt;int&gt;</i></dt><dd>
<p>
       create( class, parent, newElm, name, dimensions )
</p></dd>
<dt>delete:  <i>Id</i></dt><dd>
<p>
       Destroys Element, all its messages, and all its children. Args: Id
</p></dd>
<dt>handleAddMsg:    <i>string,unsigned int,ObjId,string,ObjId,string</i></dt><dd>
<p>
       Makes a msg
</p></dd>
<dt>handleQuit:      <i>void</i></dt><dd>
<p>
       Stops simulation running and quits the simulator
</p></dd>
<dt>move:    <i>Id,Id</i></dt><dd>
<p>
       handleMove( Id orig, Id newParent ): moves an Element to a new parent
</p></dd>
<dt>handleCopy:      <i>vector&lt;Id&gt;,string,unsigned int,bool,bool</i></dt><dd>
<p>
       handleCopy( vector&lt; Id &gt; args, string newName, unsigned int nCopies, bool toGlobal, bool copyExtMsgs ):  The vector&lt; Id &gt; has Id orig, Id newParent, Id newElm. This function copies an Element and all its children to a new parent. May also expand out the original into nCopies copies. Normally all messages within the copy tree are also copied.  If the flag copyExtMsgs is true, then all msgs going out are also copied.
</p></dd>
<dt>handleUseClock:  <i>string,string,unsigned int</i></dt><dd>
<p>
       Deals with assignment of path to a given clock.
</p></dd>
<dt>handleSync:      <i>Id,unsigned int</i></dt><dd>
<p>
       handleSync( Id Element): Synchronizes DataHandler indexing across nodesThe ElementId is the element being synchronized.The FuncId is the 'get' function for the synchronized field.
</p></dd>
<dt>handleReMesh:    <i>Id</i></dt><dd>
<p>
       handleReMesh( Id BaseMesh): Deals with outcome of resizing the meshing in a cellularcompartment (the ChemMesh class). The mesh change has topropagate down to the molecules and reactions managed by this.Mesh. The ElementId is the mesh being synchronized.
</p></dd>
<dt>handleSetParserIdleFlag: <i>bool</i></dt><dd>
<p>
       handleSetParserIdleFlag( bool isParserIdle ): When True, tells the ProcessLoop to wait as the Parser is idle.
</p></dd>
<dt>handleAck:       <i>unsigned int,unsigned int</i></dt><dd>
<p>
       Keeps track of # of acks to a blocking shell command. Arg: Source node num.
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-70" class="outline-3">
<h3 id="sec-70"><span class="section-number-3">70</span> SimManager</h3>
<div class="outline-text-3" id="text-70">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>syncTime:        <i>double</i></dt><dd>
<p>
       SyncTime is the interval between synchronizing solvers5 msec is a typical value
</p></dd>
<dt>autoPlot:        <i>bool</i></dt><dd>
<p>
       When the autoPlot flag is true, the simManager guesses whichplots are of interest, and builds them.
</p></dd>
<dt>plotDt:  <i>double</i></dt><dd>
<p>
       plotDt is the timestep for plotting variables. As most will bechemical, a default of 1 sec is reasonable
</p></dd>
<dt>runTime: <i>double</i></dt><dd>
<p>
       runTime is the requested duration of the simulation that is stored in some kinds of model definition files.
</p></dd>
<dt>method:  <i>string</i></dt><dd>
<p>
       method is the numerical method used for the calculations.This will set up or even replace the solver with one ableto use the specified method. Currently works only with two solvers: GSL and GSSA.The GSL solver has a variety of ODE methods, by defaultRunge-Kutta-Fehlberg.The GSSA solver currently uses the Gillespie StochasticSystems Algorithm, somewhat optimized over the originalmethod.
</p></dd>
<dt>version: <i>unsigned int</i></dt><dd>
<p>
       Numerical version number. Used by kkit
</p></dd>
<dt>modelFamily:     <i>string</i></dt><dd>
<p>
       Family classification of model: *kinetic, and *neuron are the options so far. In due course expect to see thingslike detailedNetwork, intFireNetwork, sigNeur and so on.
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>requestMeshStats:        <i>void</i></dt><dd>
<p>
       Asks for basic stats for mesh:Total # of entries, and a vector of unique volumes of voxels
</p></dd>
<dt>nodeInfo:        <i>unsigned int,unsigned int</i></dt><dd>
<p>
       Sends out # of nodes to use for meshing, and # of threads to use on each node, to the ChemMesh. These numbers sometimesdiffer from the total # of nodes and threads, because the SimManager may have other portions of the model to allocate.
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>build:   <i>string</i></dt><dd>
<p>
       Sets up model, with the specified method. The method may beempty if the intention is that methods be set up through hints in the ChemMesh compartments.
</p></dd>
<dt>makeStandardElements:    <i>string</i></dt><dd>
<p>
       Sets up the usual infrastructure for a model, with theChemMesh, Stoich, solver and suitable messaging.The argument is the MeshClass to use.
</p></dd>
<dt>meshSplit:       <i>double,vector&lt;unsigned int&gt;,vector&lt;unsigned int&gt;,vector&lt;unsigned int&gt;,vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Handles message from ChemMesh that defines howmeshEntries communicate between nodes.First arg is oldvol, next is list of other nodes, third arg is list number ofmeshEntries to be transferred for each of these nodes, fourth arg is catenated list of meshEntries indices onmy node going to each of the other connected nodes, andlast arg is matching list of meshEntries on other nodes
</p></dd>
<dt>meshStats:       <i>unsigned int,vector&lt;double&gt;</i></dt><dd>
<p>
       Basic statistics for mesh: Total # of entries, and a vectorof unique volumes of voxels
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-71" class="outline-3">
<h3 id="sec-71"><span class="section-number-3">71</span> SingleMsg</h3>
<div class="outline-text-3" id="text-71">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>e1:      <i>Id</i></dt><dd>
<p>
       Id of source Element.
</p></dd>
<dt>e2:      <i>Id</i></dt><dd>
<p>
       Id of source Element.
</p></dd>
<dt>srcFieldsOnE1:   <i>vector&lt;string&gt;</i></dt><dd>
<p>
       Names of SrcFinfos for messages going from e1 to e2. There arematching entries in the destFieldsOnE2 vector
</p></dd>
<dt>destFieldsOnE2:  <i>vector&lt;string&gt;</i></dt><dd>
<p>
       Names of DestFinfos for messages going from e1 to e2. There arematching entries in the srcFieldsOnE1 vector
</p></dd>
<dt>srcFieldsOnE2:   <i>vector&lt;string&gt;</i></dt><dd>
<p>
       Names of SrcFinfos for messages going from e2 to e1. There arematching entries in the destFieldsOnE1 vector
</p></dd>
<dt>destFieldsOnE1:  <i>vector&lt;string&gt;</i></dt><dd>
<p>
       Names of destFinfos for messages going from e2 to e1. There arematching entries in the srcFieldsOnE2 vector
</p></dd>
<dt>i1:      <i>DataId</i></dt><dd>
<p>
       Index of source object.
</p></dd>
<dt>i2:      <i>DataId</i></dt><dd>
<p>
       Index of dest object.
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-72" class="outline-3">
<h3 id="sec-72"><span class="section-number-3">72</span> SparseMsg</h3>
<div class="outline-text-3" id="text-72">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>e1:      <i>Id</i></dt><dd>
<p>
       Id of source Element.
</p></dd>
<dt>e2:      <i>Id</i></dt><dd>
<p>
       Id of source Element.
</p></dd>
<dt>srcFieldsOnE1:   <i>vector&lt;string&gt;</i></dt><dd>
<p>
       Names of SrcFinfos for messages going from e1 to e2. There arematching entries in the destFieldsOnE2 vector
</p></dd>
<dt>destFieldsOnE2:  <i>vector&lt;string&gt;</i></dt><dd>
<p>
       Names of DestFinfos for messages going from e1 to e2. There arematching entries in the srcFieldsOnE1 vector
</p></dd>
<dt>srcFieldsOnE2:   <i>vector&lt;string&gt;</i></dt><dd>
<p>
       Names of SrcFinfos for messages going from e2 to e1. There arematching entries in the destFieldsOnE1 vector
</p></dd>
<dt>destFieldsOnE1:  <i>vector&lt;string&gt;</i></dt><dd>
<p>
       Names of destFinfos for messages going from e2 to e1. There arematching entries in the srcFieldsOnE2 vector
</p></dd>
<dt>numRows: <i>unsigned int</i></dt><dd>
<p>
       Number of rows in matrix.
</p></dd>
<dt>numColumns:      <i>unsigned int</i></dt><dd>
<p>
       Number of columns in matrix.
</p></dd>
<dt>numEntries:      <i>unsigned int</i></dt><dd>
<p>
       Number of Entries in matrix.
</p></dd>
<dt>probability:     <i>double</i></dt><dd>
<p>
       connection probability for random connectivity.
</p></dd>
<dt>seed:    <i>long</i></dt><dd>
<p>
       Random number seed for generating probabilistic connectivity.
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>setRandomConnectivity:   <i>double,long</i></dt><dd>
<p>
       Assigns connectivity with specified probability and seed
</p></dd>
<dt>setEntry:        <i>unsigned int,unsigned int,unsigned int</i></dt><dd>
<p>
       Assigns single row,column value
</p></dd>
<dt>unsetEntry:      <i>unsigned int,unsigned int</i></dt><dd>
<p>
       Clears single row,column entry
</p></dd>
<dt>clear:   <i>void</i></dt><dd>
<p>
       Clears out the entire matrix
</p></dd>
<dt>transpose:       <i>void</i></dt><dd>
<p>
       Transposes the sparse matrix
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-73" class="outline-3">
<h3 id="sec-73"><span class="section-number-3">73</span> Species</h3>
<div class="outline-text-3" id="text-73">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>molWt:   <i>double</i></dt><dd>
<p>
       Molecular weight of species
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>sendMolWt:       <i>double</i></dt><dd>
<p>
       returns molWt.
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>handleMolWtRequest:      <i>void</i></dt><dd>
<p>
       Handle requests for molWt.
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-74" class="outline-3">
<h3 id="sec-74"><span class="section-number-3">74</span> SpherePanel</h3>
<div class="outline-text-3" id="text-74">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>nPts:    <i>unsigned int</i></dt><dd>
<p>
       Number of points used by panel to specify geometry
</p></dd>
<dt>nDims:   <i>unsigned int</i></dt><dd>
<p>
       Number of Dimensions used by panel to specify geometry
</p></dd>
<dt>numNeighbors:    <i>unsigned int</i></dt><dd>
<p>
       Number of Neighbors of panel
</p></dd>
<dt>shapeId: <i>unsigned int</i></dt><dd>
<p>
       Identifier for shape type, as used by Smoldyn
</p></dd>
<dt>coords:  <i>vector&lt;double&gt;</i></dt><dd>
<p>
       All the coordinates for the panel. X vector, then Y, then ZZ can be left out for 2-D panels.Z and Y can be left out for 1-D panels.
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>toNeighbor:      <i>void</i></dt><dd>
<p>
       Identifies neighbors of the current panel
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>neighbor:        <i>void</i></dt><dd>
<p>
       Handles incoming message from neighbor
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
<dt>x:       <i>unsigned int,double</i></dt><dd>
<p>
       x coordinate identified by index
</p></dd>
<dt>y:       <i>unsigned int,double</i></dt><dd>
<p>
       y coordinate identified by index
</p></dd>
<dt>z:       <i>unsigned int,double</i></dt><dd>
<p>
       z coordinate identified by index
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-75" class="outline-3">
<h3 id="sec-75"><span class="section-number-3">75</span> SpikeGen</h3>
<div class="outline-text-3" id="text-75">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>threshold:       <i>double</i></dt><dd>
<p>
       Spiking threshold, must cross it going up
</p></dd>
<dt>refractT:        <i>double</i></dt><dd>
<p>
       Refractory Time.
</p></dd>
<dt>abs<sub>refract</sub>:     <i>double</i></dt><dd>
<p>
       Absolute refractory time. Synonym for refractT.
</p></dd>
<dt>hasFired:        <i>bool</i></dt><dd>
<p>
       True if SpikeGen has just fired
</p></dd>
<dt>edgeTriggered:   <i>bool</i></dt><dd>
<p>
       When edgeTriggered = 0, the SpikeGen will fire an event in each timestep while incoming Vm is &gt; threshold and at least abs<sub>refracttime</sub> has passed since last event. This may be problematic if the incoming Vm remains above threshold for longer than abs<sub>refract</sub>. Setting edgeTriggered to 1 resolves this as the SpikeGen generatesan event only on the rising edge of the incoming Vm and will remain idle unless the incoming Vm goes below threshold.
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>event:   <i>double</i></dt><dd>
<p>
       Sends out a trigger for an event.
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call
</p></dd>
<dt>Vm:      <i>double</i></dt><dd>
<p>
       Handles Vm message coming in from compartment
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-76" class="outline-3">
<h3 id="sec-76"><span class="section-number-3">76</span> Stats</h3>
<div class="outline-text-3" id="text-76">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>mean:    <i>double</i></dt><dd>
<p>
       Mean of all sampled values.
</p></dd>
<dt>sdev:    <i>double</i></dt><dd>
<p>
       Standard Deviation of all sampled values.
</p></dd>
<dt>sum:     <i>double</i></dt><dd>
<p>
       Sum of all sampled values.
</p></dd>
<dt>num:     <i>unsigned int</i></dt><dd>
<p>
       Number of all sampled values.
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>reduce:  <i>unsigned int</i></dt><dd>
<p>
       Execute statistics reduction operation on all targets andplace results in this object
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>trig:    <i>void</i></dt><dd>
<p>
       Triggers Reduction operation.
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-77" class="outline-3">
<h3 id="sec-77"><span class="section-number-3">77</span> StimulusTable</h3>
<div class="outline-text-3" id="text-77">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>vec:     <i>vector&lt;double&gt;</i></dt><dd>
<p>
       vector with all table entries
</p></dd>
<dt>outputValue:     <i>double</i></dt><dd>
<p>
       Output value holding current table entry or output of a calculation
</p></dd>
<dt>size:    <i>unsigned int</i></dt><dd>
<p>
       size of table. Note that this is the number of x divisions +1since it must represent the largest value as well as thesmallest
</p></dd>
<dt>startTime:       <i>double</i></dt><dd>
<p>
       Start time used when table is emitting values. For lookupvalues below this, the table just sends out its zero entry.Corresponds to zeroth entry of table.
</p></dd>
<dt>stopTime:        <i>double</i></dt><dd>
<p>
       Time to stop emitting values.If time exceeds this, then the table sends out its last entry.The stopTime corresponds to the last entry of table.
</p></dd>
<dt>loopTime:        <i>double</i></dt><dd>
<p>
       If looping, this is the time between successive cycle starts.Defaults to the difference between stopTime and startTime, so that the output waveform cycles with precisely the same duration as the table contents.If larger than stopTime - startTime, then it pauses at the last table value till it is time to go around again.If smaller than stopTime - startTime, then it begins the next cycle even before the first one has reached the end of the table.
</p></dd>
<dt>stepSize:        <i>double</i></dt><dd>
<p>
       Increment in lookup (x) value on every timestep. If it isless than or equal to zero, the StimulusTable uses the current timeas the lookup value.
</p></dd>
<dt>stepPosition:    <i>double</i></dt><dd>
<p>
       Current value of lookup (x) value.If stepSize is less than or equal to zero, this is set tothe current time to use as the lookup value.
</p></dd>
<dt>doLoop:  <i>bool</i></dt><dd>
<p>
       Flag: Should it loop around to startTime once it has reachedstopTime. Default (zero) is to do a single pass.
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>output:  <i>double</i></dt><dd>
<p>
       Sends out tabulated data according to lookup parameters.
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>group:   <i>void</i></dt><dd>
<p>
       Handle for grouping. Doesn't do anything.
</p></dd>
<dt>linearTransform: <i>double,double</i></dt><dd>
<p>
       Linearly scales and offsets data. Scale first, then offset.
</p></dd>
<dt>xplot:   <i>string,string</i></dt><dd>
<p>
       Dumps table contents to xplot-format file. Argument 1 is filename, argument 2 is plotname
</p></dd>
<dt>plainPlot:       <i>string</i></dt><dd>
<p>
       Dumps table contents to single-column ascii file. Uses scientific notation. Argument 1 is filename
</p></dd>
<dt>loadCSV: <i>string,int,int,char</i></dt><dd>
<p>
       Reads a single column from a CSV file. Arguments: filename, column#, starting row#, separator
</p></dd>
<dt>loadXplot:       <i>string,string</i></dt><dd>
<p>
       Reads a single plot from an xplot file. Arguments: filename, plotnameWhen the file has 2 columns, the 2nd column is loaded.
</p></dd>
<dt>loadXplotRange:  <i>string,string,unsigned int,unsigned int</i></dt><dd>
<p>
       Reads a single plot from an xplot file, and selects a subset of points from it. Arguments: filename, plotname, startindex, endindexUses C convention: startindex included, endindex not included.When the file has 2 columns, the 2nd column is loaded.
</p></dd>
<dt>compareXplot:    <i>string,string,string</i></dt><dd>
<p>
       Reads a plot from an xplot file and compares with contents of TableBase.Result is put in 'output' field of table.If the comparison fails (e.g., due to zero entries), the return value is -1.Arguments: filename, plotname, comparison<sub>operationOperations</sub>: rmsd (for RMSDifference), rmsr (RMSratio ), dotp (Dot product, not yet implemented).
</p></dd>
<dt>compareVec:      <i>vector&lt;double&gt;,string</i></dt><dd>
<p>
       Compares contents of TableBase with a vector of doubles.Result is put in 'output' field of table.If the comparison fails (e.g., due to zero entries), the return value is -1.Arguments: Other vector, comparison<sub>operationOperations</sub>: rmsd (for RMSDifference), rmsr (RMSratio ), dotp (Dot product, not yet implemented).
</p></dd>
<dt>clearVec:        <i>void</i></dt><dd>
<p>
       Handles request to clear the data vector
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call, updates internal time stamp.
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call.
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
<dt>y:       <i>unsigned int,double</i></dt><dd>
<p>
       Value of table at specified index
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-78" class="outline-3">
<h3 id="sec-78"><span class="section-number-3">78</span> Stoich</h3>
<div class="outline-text-3" id="text-78">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>useOneWayReacs:  <i>bool</i></dt><dd>
<p>
       Flag: use bidirectional or one-way reacs. One-way is neededfor Gillespie type stochastic calculations. Two-way islikely to be margninally more efficient in ODE calculations
</p></dd>
<dt>nVarPools:       <i>unsigned int</i></dt><dd>
<p>
       Number of variable molecule pools in the reac system
</p></dd>
<dt>numMeshEntries:  <i>unsigned int</i></dt><dd>
<p>
       Number of meshEntries in reac-diff system
</p></dd>
<dt>estimatedDt:     <i>double</i></dt><dd>
<p>
       Estimate of fastest (smallest) timescale in system.This is fallible because it depends on instantaneous concs,which of course change over the course of the simulation.
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       Path of reaction system to take over
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>plugin:  <i>Id</i></dt><dd>
<p>
       Sends out Stoich Id so that plugins can directly access fields and functions
</p></dd>
<dt>nodeDiffBoundary:        <i>unsigned int,vector&lt;unsigned int&gt;,vector&lt;double&gt;</i></dt><dd>
<p>
       Sends mol #s across boundary between nodes, to calculate diffusionterms. arg1 is originating node, arg2 is list of meshIndices forwhich data is being transferred, and arg3 are the 'n' values forall the pools on the specified meshIndices, to be plugged intothe appropriate place on the recipient node's S_ matrix
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>meshSplit:       <i>double,vector&lt;double&gt;,vector&lt;unsigned int&gt;,vector&lt; vector&lt;unsigned int&gt; &gt;,vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Handles message from ChemMesh that defines how meshEntries are decomposed on this node, and how they communicate between nodes.Args: (oldVol, volumeVectorForAllEntries, localEntryList, outgoingDiffusion[node#][entry#], incomingDiffusion[node#][entry#])
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-79" class="outline-3">
<h3 id="sec-79"><span class="section-number-3">79</span> SumFunc</h3>
<div class="outline-text-3" id="text-79">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>result:  <i>double</i></dt><dd>
<p>
       outcome of summation
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>output:  <i>double</i></dt><dd>
<p>
       Sends out sum on each timestep
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>input:   <i>double</i></dt><dd>
<p>
       Handles input values
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-80" class="outline-3">
<h3 id="sec-80"><span class="section-number-3">80</span> Surface</h3>
<div class="outline-text-3" id="text-80">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>volume:  <i>double</i></dt><dd>
<p>
       This is something I'll need to write a function to compute.Perhaps have an update routine as it may be hard to compute but is needed often by the molecules.
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>absorb:  <i>void</i></dt><dd>
<p>
       these help the system define non-standard operations for what a molecule does when it hits a surface.The default is reflect.As a molecule may interact with multiple surfaces, it isn't enough to confer a property on the molecule itself. We have to use messages. Perhaps we don't need these, but instead put entities on the surface which the molecule interacts with if it doesn't do the basic reflect operation.
</p></dd>
<dt>transmit:        <i>void</i></dt><dd>
<p>
       Surface lets molecules through
</p></dd>
<dt>jump:    <i>void</i></dt><dd>
<p>
       dunno
</p></dd>
<dt>mixture: <i>void</i></dt><dd>
<p>
       dunno
</p></dd>
<dt>surface: <i>double,double,double</i></dt><dd>
<p>
       Connects up to a compartment, either as interior or exterior Args are volume, area, perimeter
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-81" class="outline-3">
<h3 id="sec-81"><span class="section-number-3">81</span> SymCompartment</h3>
<div class="outline-text-3" id="text-81">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>Vm:      <i>double</i></dt><dd>
<p>
       membrane potential
</p></dd>
<dt>Cm:      <i>double</i></dt><dd>
<p>
       Membrane capacitance
</p></dd>
<dt>Em:      <i>double</i></dt><dd>
<p>
       Resting membrane potential
</p></dd>
<dt>Im:      <i>double</i></dt><dd>
<p>
       Current going through membrane
</p></dd>
<dt>inject:  <i>double</i></dt><dd>
<p>
       Current injection to deliver into compartment
</p></dd>
<dt>initVm:  <i>double</i></dt><dd>
<p>
       Initial value for membrane potential
</p></dd>
<dt>Rm:      <i>double</i></dt><dd>
<p>
       Membrane resistance
</p></dd>
<dt>Ra:      <i>double</i></dt><dd>
<p>
       Axial resistance of compartment
</p></dd>
<dt>diameter:        <i>double</i></dt><dd>
<p>
       Diameter of compartment
</p></dd>
<dt>length:  <i>double</i></dt><dd>
<p>
       Length of compartment
</p></dd>
<dt>x0:      <i>double</i></dt><dd>
<p>
       X coordinate of start of compartment
</p></dd>
<dt>y0:      <i>double</i></dt><dd>
<p>
       Y coordinate of start of compartment
</p></dd>
<dt>z0:      <i>double</i></dt><dd>
<p>
       Z coordinate of start of compartment
</p></dd>
<dt>x:       <i>double</i></dt><dd>
<p>
       x coordinate of end of compartment
</p></dd>
<dt>y:       <i>double</i></dt><dd>
<p>
       y coordinate of end of compartment
</p></dd>
<dt>z:       <i>double</i></dt><dd>
<p>
       z coordinate of end of compartment
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>VmOut:   <i>double</i></dt><dd>
<p>
       Sends out Vm value of compartment on each timestep
</p></dd>
<dt>axialOut:        <i>double</i></dt><dd>
<p>
       Sends out Vm value of compartment to adjacent compartments,on each timestep
</p></dd>
<dt>raxialOut:       <i>double,double</i></dt><dd>
<p>
       Sends out Raxial information on each timestep, fields are Ra and Vm
</p></dd>
<dt>raxialOut:       <i>double,double</i></dt><dd>
<p>
       Sends out Ra and Vm on each timestep
</p></dd>
<dt>sumRaxialOut:    <i>double</i></dt><dd>
<p>
       Sends out Ra
</p></dd>
<dt>requestSumAxial: <i>void</i></dt><dd>
<p>
       Sends out request for Ra.
</p></dd>
<dt>raxialOut:       <i>double,double</i></dt><dd>
<p>
       Sends out Ra and Vm on each timestep
</p></dd>
<dt>sumRaxialOut:    <i>double</i></dt><dd>
<p>
       Sends out Ra
</p></dd>
<dt>requestSumAxial: <i>void</i></dt><dd>
<p>
       Sends out request for Ra.
</p></dd>
<dt>Raxial2Out:      <i>double,double</i></dt><dd>
<p>
       Sends out Ra and Vm
</p></dd>
<dt>sumRaxial2Out:   <i>double</i></dt><dd>
<p>
       Sends out Ra
</p></dd>
<dt>requestSumAxial2:        <i>void</i></dt><dd>
<p>
       Sends out request for Ra.
</p></dd>
<dt>Raxial2Out:      <i>double,double</i></dt><dd>
<p>
       Sends out Ra and Vm
</p></dd>
<dt>sumRaxial2Out:   <i>double</i></dt><dd>
<p>
       Sends out Ra
</p></dd>
<dt>requestSumAxial2:        <i>void</i></dt><dd>
<p>
       Sends out request for Ra.
</p></dd>
<dt>Raxial2Out:      <i>double,double</i></dt><dd>
<p>
       Sends out Ra and Vm
</p></dd>
<dt>sumRaxial2Out:   <i>double</i></dt><dd>
<p>
       Sends out Ra
</p></dd>
<dt>requestSumAxial2:        <i>void</i></dt><dd>
<p>
       Sends out request for Ra.
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>injectMsg:       <i>double</i></dt><dd>
<p>
       The injectMsg corresponds to the INJECT message in the GENESIS compartment. Unlike the 'inject' field, any value assigned by handleInject applies only for a single timestep.So it needs to be updated every dt for a steady (or varying)injection current
</p></dd>
<dt>randInject:      <i>double,double</i></dt><dd>
<p>
       Sends a random injection current to the compartment. Must beupdated each timestep.Arguments to randInject are probability and current.
</p></dd>
<dt>injectMsg:       <i>double</i></dt><dd>
<p>
       The injectMsg corresponds to the INJECT message in the GENESIS compartment. Unlike the 'inject' field, any value assigned by handleInject applies only for a single timestep.So it needs to be updated every dt for a steady (or varying)injection current
</p></dd>
<dt>cable:   <i>void</i></dt><dd>
<p>
       Message for organizing compartments into groups, calledcables. Doesn't do anything.
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles 'process' call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles 'reinit' call
</p></dd>
<dt>initProc:        <i>void</i></dt><dd>
<p>
       Handles Process call for the 'init' phase of the Compartment calculations. These occur as a separate Tick cycle from the regular proc cycle, and should be called before the proc msg.
</p></dd>
<dt>initReinit:      <i>void</i></dt><dd>
<p>
       Handles Reinit call for the 'init' phase of the Compartment calculations.
</p></dd>
<dt>handleChannel:   <i>double,double</i></dt><dd>
<p>
       Handles conductance and Reversal potential arguments from Channel
</p></dd>
<dt>handleRaxial:    <i>double,double</i></dt><dd>
<p>
       Handles Raxial info: arguments are Ra and Vm.
</p></dd>
<dt>handleAxial:     <i>double</i></dt><dd>
<p>
       Handles Axial information. Argument is just Vm.
</p></dd>
<dt>raxialSym:       <i>double,double</i></dt><dd>
<p>
       Expects Ra and Vm from other compartment.
</p></dd>
<dt>sumRaxial:       <i>double</i></dt><dd>
<p>
       Expects Ra from other compartment.
</p></dd>
<dt>handleSumRaxialRequest:  <i>void</i></dt><dd>
<p>
       Handle request to send back Ra to originating compartment.
</p></dd>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-82" class="outline-3">
<h3 id="sec-82"><span class="section-number-3">82</span> SynBase</h3>
<div class="outline-text-3" id="text-82">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>numSynapses:     <i>unsigned int</i></dt><dd>
<p>
       Number of synapses on SynBase
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-83" class="outline-3">
<h3 id="sec-83"><span class="section-number-3">83</span> SynChan</h3>
<div class="outline-text-3" id="text-83">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>numSynapses:     <i>unsigned int</i></dt><dd>
<p>
       Number of synapses on SynBase
</p></dd>
<dt>Gbar:    <i>double</i></dt><dd>
<p>
       Maximal channel conductance
</p></dd>
<dt>Ek:      <i>double</i></dt><dd>
<p>
       Reversal potential of channel
</p></dd>
<dt>Gk:      <i>double</i></dt><dd>
<p>
       Channel conductance variable
</p></dd>
<dt>Ik:      <i>double</i></dt><dd>
<p>
       Channel current variable
</p></dd>
<dt>tau1:    <i>double</i></dt><dd>
<p>
       Decay time constant for the synaptic conductance, tau1 &gt;= tau2.
</p></dd>
<dt>tau2:    <i>double</i></dt><dd>
<p>
       Rise time constant for the synaptic conductance, tau1 &gt;= tau2.
</p></dd>
<dt>normalizeWeights:        <i>bool</i></dt><dd>
<p>
       Flag. If true, the overall conductance is normalized by the number of individual synapses in this SynChan object.
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>channelOut:      <i>double,double</i></dt><dd>
<p>
       Sends channel variables Gk and Ek to compartment
</p></dd>
<dt>permeability:    <i>double</i></dt><dd>
<p>
       Conductance term going out to GHK object
</p></dd>
<dt>IkOut:   <i>double</i></dt><dd>
<p>
       Channel current. This message typically goes to concenobjects that keep track of ion concentration.
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>Vm:      <i>double</i></dt><dd>
<p>
       Handles Vm message coming in from compartment
</p></dd>
<dt>Vm:      <i>double</i></dt><dd>
<p>
       Handles Vm message coming in from compartment
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call
</p></dd>
<dt>activation:      <i>double</i></dt><dd>
<p>
       Sometimes we want to continuously activate the channel
</p></dd>
<dt>modulator:       <i>double</i></dt><dd>
<p>
       Modulate channel response
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-84" class="outline-3">
<h3 id="sec-84"><span class="section-number-3">84</span> SynChanBase</h3>
<div class="outline-text-3" id="text-84">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>numSynapses:     <i>unsigned int</i></dt><dd>
<p>
       Number of synapses on SynBase
</p></dd>
<dt>Gbar:    <i>double</i></dt><dd>
<p>
       Maximal channel conductance
</p></dd>
<dt>Ek:      <i>double</i></dt><dd>
<p>
       Reversal potential of channel
</p></dd>
<dt>Gk:      <i>double</i></dt><dd>
<p>
       Channel conductance variable
</p></dd>
<dt>Ik:      <i>double</i></dt><dd>
<p>
       Channel current variable
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>channelOut:      <i>double,double</i></dt><dd>
<p>
       Sends channel variables Gk and Ek to compartment
</p></dd>
<dt>permeability:    <i>double</i></dt><dd>
<p>
       Conductance term going out to GHK object
</p></dd>
<dt>IkOut:   <i>double</i></dt><dd>
<p>
       Channel current. This message typically goes to concenobjects that keep track of ion concentration.
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>Vm:      <i>double</i></dt><dd>
<p>
       Handles Vm message coming in from compartment
</p></dd>
<dt>Vm:      <i>double</i></dt><dd>
<p>
       Handles Vm message coming in from compartment
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-85" class="outline-3">
<h3 id="sec-85"><span class="section-number-3">85</span> Synapse</h3>
<div class="outline-text-3" id="text-85">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>weight:  <i>double</i></dt><dd>
<p>
       Synaptic weight
</p></dd>
<dt>delay:   <i>double</i></dt><dd>
<p>
       Axonal propagation delay to this synapse
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>addSpike:        <i>double</i></dt><dd>
<p>
       Handles arriving spike messages, by redirecting up to parent SynBase object
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-86" class="outline-3">
<h3 id="sec-86"><span class="section-number-3">86</span> Table</h3>
<div class="outline-text-3" id="text-86">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>vec:     <i>vector&lt;double&gt;</i></dt><dd>
<p>
       vector with all table entries
</p></dd>
<dt>outputValue:     <i>double</i></dt><dd>
<p>
       Output value holding current table entry or output of a calculation
</p></dd>
<dt>size:    <i>unsigned int</i></dt><dd>
<p>
       size of table. Note that this is the number of x divisions +1since it must represent the largest value as well as thesmallest
</p></dd>
<dt>threshold:       <i>double</i></dt><dd>
<p>
       threshold used when Table acts as a buffer for spikes
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>requestData:     <i>unsigned int</i></dt><dd>
<p>
       Sends request for a field to target object
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>group:   <i>void</i></dt><dd>
<p>
       Handle for grouping. Doesn't do anything.
</p></dd>
<dt>linearTransform: <i>double,double</i></dt><dd>
<p>
       Linearly scales and offsets data. Scale first, then offset.
</p></dd>
<dt>xplot:   <i>string,string</i></dt><dd>
<p>
       Dumps table contents to xplot-format file. Argument 1 is filename, argument 2 is plotname
</p></dd>
<dt>plainPlot:       <i>string</i></dt><dd>
<p>
       Dumps table contents to single-column ascii file. Uses scientific notation. Argument 1 is filename
</p></dd>
<dt>loadCSV: <i>string,int,int,char</i></dt><dd>
<p>
       Reads a single column from a CSV file. Arguments: filename, column#, starting row#, separator
</p></dd>
<dt>loadXplot:       <i>string,string</i></dt><dd>
<p>
       Reads a single plot from an xplot file. Arguments: filename, plotnameWhen the file has 2 columns, the 2nd column is loaded.
</p></dd>
<dt>loadXplotRange:  <i>string,string,unsigned int,unsigned int</i></dt><dd>
<p>
       Reads a single plot from an xplot file, and selects a subset of points from it. Arguments: filename, plotname, startindex, endindexUses C convention: startindex included, endindex not included.When the file has 2 columns, the 2nd column is loaded.
</p></dd>
<dt>compareXplot:    <i>string,string,string</i></dt><dd>
<p>
       Reads a plot from an xplot file and compares with contents of TableBase.Result is put in 'output' field of table.If the comparison fails (e.g., due to zero entries), the return value is -1.Arguments: filename, plotname, comparison<sub>operationOperations</sub>: rmsd (for RMSDifference), rmsr (RMSratio ), dotp (Dot product, not yet implemented).
</p></dd>
<dt>compareVec:      <i>vector&lt;double&gt;,string</i></dt><dd>
<p>
       Compares contents of TableBase with a vector of doubles.Result is put in 'output' field of table.If the comparison fails (e.g., due to zero entries), the return value is -1.Arguments: Other vector, comparison<sub>operationOperations</sub>: rmsd (for RMSDifference), rmsr (RMSratio ), dotp (Dot product, not yet implemented).
</p></dd>
<dt>clearVec:        <i>void</i></dt><dd>
<p>
       Handles request to clear the data vector
</p></dd>
<dt>input:   <i>double</i></dt><dd>
<p>
       Fills data into the Table.
</p></dd>
<dt>spike:   <i>double</i></dt><dd>
<p>
       Fills spike timings into the Table. Signal has to exceed thresh
</p></dd>
<dt>recvData:        <i>bad</i></dt><dd>
<p>
       Handles data sent back following request
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call, updates internal time stamp.
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call.
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
<dt>y:       <i>unsigned int,double</i></dt><dd>
<p>
       Value of table at specified index
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-87" class="outline-3">
<h3 id="sec-87"><span class="section-number-3">87</span> TableBase</h3>
<div class="outline-text-3" id="text-87">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>vec:     <i>vector&lt;double&gt;</i></dt><dd>
<p>
       vector with all table entries
</p></dd>
<dt>outputValue:     <i>double</i></dt><dd>
<p>
       Output value holding current table entry or output of a calculation
</p></dd>
<dt>size:    <i>unsigned int</i></dt><dd>
<p>
       size of table. Note that this is the number of x divisions +1since it must represent the largest value as well as thesmallest
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>group:   <i>void</i></dt><dd>
<p>
       Handle for grouping. Doesn't do anything.
</p></dd>
<dt>linearTransform: <i>double,double</i></dt><dd>
<p>
       Linearly scales and offsets data. Scale first, then offset.
</p></dd>
<dt>xplot:   <i>string,string</i></dt><dd>
<p>
       Dumps table contents to xplot-format file. Argument 1 is filename, argument 2 is plotname
</p></dd>
<dt>plainPlot:       <i>string</i></dt><dd>
<p>
       Dumps table contents to single-column ascii file. Uses scientific notation. Argument 1 is filename
</p></dd>
<dt>loadCSV: <i>string,int,int,char</i></dt><dd>
<p>
       Reads a single column from a CSV file. Arguments: filename, column#, starting row#, separator
</p></dd>
<dt>loadXplot:       <i>string,string</i></dt><dd>
<p>
       Reads a single plot from an xplot file. Arguments: filename, plotnameWhen the file has 2 columns, the 2nd column is loaded.
</p></dd>
<dt>loadXplotRange:  <i>string,string,unsigned int,unsigned int</i></dt><dd>
<p>
       Reads a single plot from an xplot file, and selects a subset of points from it. Arguments: filename, plotname, startindex, endindexUses C convention: startindex included, endindex not included.When the file has 2 columns, the 2nd column is loaded.
</p></dd>
<dt>compareXplot:    <i>string,string,string</i></dt><dd>
<p>
       Reads a plot from an xplot file and compares with contents of TableBase.Result is put in 'output' field of table.If the comparison fails (e.g., due to zero entries), the return value is -1.Arguments: filename, plotname, comparison<sub>operationOperations</sub>: rmsd (for RMSDifference), rmsr (RMSratio ), dotp (Dot product, not yet implemented).
</p></dd>
<dt>compareVec:      <i>vector&lt;double&gt;,string</i></dt><dd>
<p>
       Compares contents of TableBase with a vector of doubles.Result is put in 'output' field of table.If the comparison fails (e.g., due to zero entries), the return value is -1.Arguments: Other vector, comparison<sub>operationOperations</sub>: rmsd (for RMSDifference), rmsr (RMSratio ), dotp (Dot product, not yet implemented).
</p></dd>
<dt>clearVec:        <i>void</i></dt><dd>
<p>
       Handles request to clear the data vector
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
<dt>y:       <i>unsigned int,double</i></dt><dd>
<p>
       Value of table at specified index
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-88" class="outline-3">
<h3 id="sec-88"><span class="section-number-3">88</span> TableEntry</h3>
<div class="outline-text-3" id="text-88">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>value:   <i>double</i></dt><dd>
<p>
       Data value in this entry
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-89" class="outline-3">
<h3 id="sec-89"><span class="section-number-3">89</span> Tick</h3>
<div class="outline-text-3" id="text-89">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>dt:      <i>double</i></dt><dd>
<p>
       Timestep for this tick
</p></dd>
<dt>localdt: <i>double</i></dt><dd>
<p>
       Timestep for this tick
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>process0:        <i>PK8ProcInfo</i></dt><dd>
<p>
       Process for Tick 0
</p></dd>
<dt>reinit0: <i>PK8ProcInfo</i></dt><dd>
<p>
       Reinit for Tick 0
</p></dd>
<dt>process1:        <i>PK8ProcInfo</i></dt><dd>
<p>
       Process for Tick 1
</p></dd>
<dt>reinit1: <i>PK8ProcInfo</i></dt><dd>
<p>
       Reinit for Tick 1
</p></dd>
<dt>process2:        <i>PK8ProcInfo</i></dt><dd>
<p>
       Process for Tick 2
</p></dd>
<dt>reinit2: <i>PK8ProcInfo</i></dt><dd>
<p>
       Reinit for Tick 2
</p></dd>
<dt>process3:        <i>PK8ProcInfo</i></dt><dd>
<p>
       Process for Tick 3
</p></dd>
<dt>reinit3: <i>PK8ProcInfo</i></dt><dd>
<p>
       Reinit for Tick 3
</p></dd>
<dt>process4:        <i>PK8ProcInfo</i></dt><dd>
<p>
       Process for Tick 4
</p></dd>
<dt>reinit4: <i>PK8ProcInfo</i></dt><dd>
<p>
       Reinit for Tick 4
</p></dd>
<dt>process5:        <i>PK8ProcInfo</i></dt><dd>
<p>
       Process for Tick 5
</p></dd>
<dt>reinit5: <i>PK8ProcInfo</i></dt><dd>
<p>
       Reinit for Tick 5
</p></dd>
<dt>process6:        <i>PK8ProcInfo</i></dt><dd>
<p>
       Process for Tick 6
</p></dd>
<dt>reinit6: <i>PK8ProcInfo</i></dt><dd>
<p>
       Reinit for Tick 6
</p></dd>
<dt>process7:        <i>PK8ProcInfo</i></dt><dd>
<p>
       Process for Tick 7
</p></dd>
<dt>reinit7: <i>PK8ProcInfo</i></dt><dd>
<p>
       Reinit for Tick 7
</p></dd>
<dt>process8:        <i>PK8ProcInfo</i></dt><dd>
<p>
       Process for Tick 8
</p></dd>
<dt>reinit8: <i>PK8ProcInfo</i></dt><dd>
<p>
       Reinit for Tick 8
</p></dd>
<dt>process9:        <i>PK8ProcInfo</i></dt><dd>
<p>
       Process for Tick 9
</p></dd>
<dt>reinit9: <i>PK8ProcInfo</i></dt><dd>
<p>
       Reinit for Tick 9
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-90" class="outline-3">
<h3 id="sec-90"><span class="section-number-3">90</span> TriPanel</h3>
<div class="outline-text-3" id="text-90">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>nPts:    <i>unsigned int</i></dt><dd>
<p>
       Number of points used by panel to specify geometry
</p></dd>
<dt>nDims:   <i>unsigned int</i></dt><dd>
<p>
       Number of Dimensions used by panel to specify geometry
</p></dd>
<dt>numNeighbors:    <i>unsigned int</i></dt><dd>
<p>
       Number of Neighbors of panel
</p></dd>
<dt>shapeId: <i>unsigned int</i></dt><dd>
<p>
       Identifier for shape type, as used by Smoldyn
</p></dd>
<dt>coords:  <i>vector&lt;double&gt;</i></dt><dd>
<p>
       All the coordinates for the panel. X vector, then Y, then ZZ can be left out for 2-D panels.Z and Y can be left out for 1-D panels.
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>toNeighbor:      <i>void</i></dt><dd>
<p>
       Identifies neighbors of the current panel
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>neighbor:        <i>void</i></dt><dd>
<p>
       Handles incoming message from neighbor
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
<dt>x:       <i>unsigned int,double</i></dt><dd>
<p>
       x coordinate identified by index
</p></dd>
<dt>y:       <i>unsigned int,double</i></dt><dd>
<p>
       y coordinate identified by index
</p></dd>
<dt>z:       <i>unsigned int,double</i></dt><dd>
<p>
       z coordinate identified by index
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-91" class="outline-3">
<h3 id="sec-91"><span class="section-number-3">91</span> VectorTable</h3>
<div class="outline-text-3" id="text-91">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>xdivs:   <i>unsigned int</i></dt><dd>
<p>
       Number of divisions.
</p></dd>
<dt>xmin:    <i>double</i></dt><dd>
<p>
       Minimum value in table.
</p></dd>
<dt>xmax:    <i>double</i></dt><dd>
<p>
       Maximum value in table.
</p></dd>
<dt>invdx:   <i>double</i></dt><dd>
<p>
       Maximum value in table.
</p></dd>
<dt>table:   <i>vector&lt;double&gt;</i></dt><dd>
<p>
       The lookup table.
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
<dt>lookupvalue:     <i>double,double</i></dt><dd>
<p>
       Lookup function that performs interpolation to return a value.
</p></dd>
<dt>lookupindex:     <i>unsigned int,double</i></dt><dd>
<p>
       Lookup function that returns value by index.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-92" class="outline-3">
<h3 id="sec-92"><span class="section-number-3">92</span> ZombieBufPool</h3>
<div class="outline-text-3" id="text-92">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>n:       <i>double</i></dt><dd>
<p>
       Number of molecules in pool
</p></dd>
<dt>nInit:   <i>double</i></dt><dd>
<p>
       Initial value of number of molecules in pool
</p></dd>
<dt>diffConst:       <i>double</i></dt><dd>
<p>
       Diffusion constant of molecule
</p></dd>
<dt>conc:    <i>double</i></dt><dd>
<p>
       Concentration of molecules in this pool
</p></dd>
<dt>concInit:        <i>double</i></dt><dd>
<p>
       Initial value of molecular concentration in pool
</p></dd>
<dt>size:    <i>double</i></dt><dd>
<p>
       Size of compartment. Units are SI. Utility field, the actual size info is stored on a volume mesh entry in the parent compartment.This is hooked up by a message. If the message isn'tavailable size is just taken as 1
</p></dd>
<dt>speciesId:       <i>unsigned int</i></dt><dd>
<p>
       Species identifier for this mol pool. Eventually link to ontology.
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>nOut:    <i>double</i></dt><dd>
<p>
       Sends out # of molecules in pool on each timestep
</p></dd>
<dt>requestMolWt:    <i>void</i></dt><dd>
<p>
       Requests Species object for mol wt
</p></dd>
<dt>requestSize:     <i>double</i></dt><dd>
<p>
       Requests Size of pool from matching mesh entry
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>group:   <i>void</i></dt><dd>
<p>
       Handle for grouping. Doesn't do anything.
</p></dd>
<dt>reacDest:        <i>double,double</i></dt><dd>
<p>
       Handles reaction input
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call
</p></dd>
<dt>handleMolWt:     <i>double</i></dt><dd>
<p>
       Separate finfo to assign molWt, and consequently diffusion const.Should only be used in SharedMsg with species.
</p></dd>
<dt>remesh:  <i>double,unsigned int,unsigned int,vector&lt;unsigned int&gt;,vector&lt;double&gt;</i></dt><dd>
<p>
       Handle commands to remesh the pool. This may involve changing the number of pool entries, as well as changing their volumes
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-93" class="outline-3">
<h3 id="sec-93"><span class="section-number-3">93</span> ZombieCaConc</h3>
<div class="outline-text-3" id="text-93">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>Ca:      <i>double</i></dt><dd>
<p>
       Calcium concentration.
</p></dd>
<dt>CaBasal: <i>double</i></dt><dd>
<p>
       Basal Calcium concentration.
</p></dd>
<dt>Ca<sub>base</sub>: <i>double</i></dt><dd>
<p>
       Basal Calcium concentration, synonym for CaBasal
</p></dd>
<dt>tau:     <i>double</i></dt><dd>
<p>
       Settling time for Ca concentration
</p></dd>
<dt>B:       <i>double</i></dt><dd>
<p>
       Volume scaling factor
</p></dd>
<dt>thick:   <i>double</i></dt><dd>
<p>
       Thickness of Ca shell.
</p></dd>
<dt>ceiling: <i>double</i></dt><dd>
<p>
       Ceiling value for Ca concentration. If Ca &gt; ceiling, Ca = ceiling. If ceiling &lt;= 0.0, there is no upper limit on Ca concentration value.
</p></dd>
<dt>floor:   <i>double</i></dt><dd>
<p>
       Floor value for Ca concentration. If Ca &lt; floor, Ca = floor
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>concOut: <i>double</i></dt><dd>
<p>
       Concentration of Ca in pool
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call
</p></dd>
<dt>current: <i>double</i></dt><dd>
<p>
       Calcium Ion current, due to be converted to conc.
</p></dd>
<dt>currentFraction: <i>double,double</i></dt><dd>
<p>
       Fraction of total Ion current, that is carried by Ca2+.
</p></dd>
<dt>increase:        <i>double</i></dt><dd>
<p>
       Any input current that increases the concentration.
</p></dd>
<dt>decrease:        <i>double</i></dt><dd>
<p>
       Any input current that decreases the concentration.
</p></dd>
<dt>basal:   <i>double</i></dt><dd>
<p>
       Synonym for assignment of basal conc.
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-94" class="outline-3">
<h3 id="sec-94"><span class="section-number-3">94</span> ZombieCompartment</h3>
<div class="outline-text-3" id="text-94">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>Vm:      <i>double</i></dt><dd>
<p>
       membrane potential
</p></dd>
<dt>Cm:      <i>double</i></dt><dd>
<p>
       Membrane capacitance
</p></dd>
<dt>Em:      <i>double</i></dt><dd>
<p>
       Resting membrane potential
</p></dd>
<dt>Im:      <i>double</i></dt><dd>
<p>
       Current going through membrane
</p></dd>
<dt>inject:  <i>double</i></dt><dd>
<p>
       Current injection to deliver into compartment
</p></dd>
<dt>initVm:  <i>double</i></dt><dd>
<p>
       Initial value for membrane potential
</p></dd>
<dt>Rm:      <i>double</i></dt><dd>
<p>
       Membrane resistance
</p></dd>
<dt>Ra:      <i>double</i></dt><dd>
<p>
       Axial resistance of compartment
</p></dd>
<dt>diameter:        <i>double</i></dt><dd>
<p>
       Diameter of compartment
</p></dd>
<dt>length:  <i>double</i></dt><dd>
<p>
       Length of compartment
</p></dd>
<dt>x0:      <i>double</i></dt><dd>
<p>
       X coordinate of start of compartment
</p></dd>
<dt>y0:      <i>double</i></dt><dd>
<p>
       Y coordinate of start of compartment
</p></dd>
<dt>z0:      <i>double</i></dt><dd>
<p>
       Z coordinate of start of compartment
</p></dd>
<dt>x:       <i>double</i></dt><dd>
<p>
       x coordinate of end of compartment
</p></dd>
<dt>y:       <i>double</i></dt><dd>
<p>
       y coordinate of end of compartment
</p></dd>
<dt>z:       <i>double</i></dt><dd>
<p>
       z coordinate of end of compartment
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>VmOut:   <i>double</i></dt><dd>
<p>
       Sends out Vm value of compartment on each timestep
</p></dd>
<dt>axialOut:        <i>double</i></dt><dd>
<p>
       Sends out Vm value of compartment to adjacent compartments,on each timestep
</p></dd>
<dt>raxialOut:       <i>double,double</i></dt><dd>
<p>
       Sends out Raxial information on each timestep, fields are Ra and Vm
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>injectMsg:       <i>double</i></dt><dd>
<p>
       The injectMsg corresponds to the INJECT message in the GENESIS compartment. Unlike the 'inject' field, any value assigned by handleInject applies only for a single timestep.So it needs to be updated every dt for a steady (or varying)injection current
</p></dd>
<dt>randInject:      <i>double,double</i></dt><dd>
<p>
       Sends a random injection current to the compartment. Must beupdated each timestep.Arguments to randInject are probability and current.
</p></dd>
<dt>injectMsg:       <i>double</i></dt><dd>
<p>
       The injectMsg corresponds to the INJECT message in the GENESIS compartment. Unlike the 'inject' field, any value assigned by handleInject applies only for a single timestep.So it needs to be updated every dt for a steady (or varying)injection current
</p></dd>
<dt>cable:   <i>void</i></dt><dd>
<p>
       Message for organizing compartments into groups, calledcables. Doesn't do anything.
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles 'process' call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles 'reinit' call
</p></dd>
<dt>initProc:        <i>void</i></dt><dd>
<p>
       Handles Process call for the 'init' phase of the Compartment calculations. These occur as a separate Tick cycle from the regular proc cycle, and should be called before the proc msg.
</p></dd>
<dt>initReinit:      <i>void</i></dt><dd>
<p>
       Handles Reinit call for the 'init' phase of the Compartment calculations.
</p></dd>
<dt>handleChannel:   <i>double,double</i></dt><dd>
<p>
       Handles conductance and Reversal potential arguments from Channel
</p></dd>
<dt>handleRaxial:    <i>double,double</i></dt><dd>
<p>
       Handles Raxial info: arguments are Ra and Vm.
</p></dd>
<dt>handleAxial:     <i>double</i></dt><dd>
<p>
       Handles Axial information. Argument is just Vm.
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-95" class="outline-3">
<h3 id="sec-95"><span class="section-number-3">95</span> ZombieEnz</h3>
<div class="outline-text-3" id="text-95">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>Km:      <i>double</i></dt><dd>
<p>
       Michaelis-Menten constant in SI conc units (milliMolar)
</p></dd>
<dt>numKm:   <i>double</i></dt><dd>
<p>
       Michaelis-Menten constant in number units, volume dependent
</p></dd>
<dt>kcat:    <i>double</i></dt><dd>
<p>
       Forward rate constant for enzyme, units 1/sec
</p></dd>
<dt>numSubstrates:   <i>unsigned int</i></dt><dd>
<p>
       Number of substrates in this MM reaction. Usually 1.Does not include the enzyme itself
</p></dd>
<dt>k1:      <i>double</i></dt><dd>
<p>
       Forward reaction from enz + sub to complex
</p></dd>
<dt>k2:      <i>double</i></dt><dd>
<p>
       Reverse reaction from complex to enz + sub
</p></dd>
<dt>k3:      <i>double</i></dt><dd>
<p>
       Forward rate constant from complex to product + enz
</p></dd>
<dt>ratio:   <i>double</i></dt><dd>
<p>
       Ratio of k2/k3
</p></dd>
<dt>concK1:  <i>double</i></dt><dd>
<p>
       K1 expressed in concentration (1/millimolar.sec) units
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>toSub:   <i>double,double</i></dt><dd>
<p>
       Sends out increment of molecules on product each timestep
</p></dd>
<dt>toPrd:   <i>double,double</i></dt><dd>
<p>
       Sends out increment of molecules on product each timestep
</p></dd>
<dt>toEnz:   <i>double,double</i></dt><dd>
<p>
       Sends out increment of molecules on product each timestep
</p></dd>
<dt>toCplx:  <i>double,double</i></dt><dd>
<p>
       Sends out increment of molecules on product each timestep
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>enzDest: <i>double</i></dt><dd>
<p>
       Handles # of molecules of Enzyme
</p></dd>
<dt>subDest: <i>double</i></dt><dd>
<p>
       Handles # of molecules of substrate
</p></dd>
<dt>prdDest: <i>double</i></dt><dd>
<p>
       Handles # of molecules of product. Dummy.
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call
</p></dd>
<dt>remesh:  <i>void</i></dt><dd>
<p>
       Tells the MMEnz to recompute its numKm after remeshing
</p></dd>
<dt>enzDest: <i>double</i></dt><dd>
<p>
       Handles # of molecules of Enzyme
</p></dd>
<dt>cplxDest:        <i>double</i></dt><dd>
<p>
       Handles # of molecules of enz-sub complex
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-96" class="outline-3">
<h3 id="sec-96"><span class="section-number-3">96</span> ZombieFuncPool</h3>
<div class="outline-text-3" id="text-96">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>n:       <i>double</i></dt><dd>
<p>
       Number of molecules in pool
</p></dd>
<dt>nInit:   <i>double</i></dt><dd>
<p>
       Initial value of number of molecules in pool
</p></dd>
<dt>diffConst:       <i>double</i></dt><dd>
<p>
       Diffusion constant of molecule
</p></dd>
<dt>conc:    <i>double</i></dt><dd>
<p>
       Concentration of molecules in this pool
</p></dd>
<dt>concInit:        <i>double</i></dt><dd>
<p>
       Initial value of molecular concentration in pool
</p></dd>
<dt>size:    <i>double</i></dt><dd>
<p>
       Size of compartment. Units are SI. Utility field, the actual size info is stored on a volume mesh entry in the parent compartment.This is hooked up by a message. If the message isn'tavailable size is just taken as 1
</p></dd>
<dt>speciesId:       <i>unsigned int</i></dt><dd>
<p>
       Species identifier for this mol pool. Eventually link to ontology.
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>nOut:    <i>double</i></dt><dd>
<p>
       Sends out # of molecules in pool on each timestep
</p></dd>
<dt>requestMolWt:    <i>void</i></dt><dd>
<p>
       Requests Species object for mol wt
</p></dd>
<dt>requestSize:     <i>double</i></dt><dd>
<p>
       Requests Size of pool from matching mesh entry
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>group:   <i>void</i></dt><dd>
<p>
       Handle for grouping. Doesn't do anything.
</p></dd>
<dt>reacDest:        <i>double,double</i></dt><dd>
<p>
       Handles reaction input
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call
</p></dd>
<dt>handleMolWt:     <i>double</i></dt><dd>
<p>
       Separate finfo to assign molWt, and consequently diffusion const.Should only be used in SharedMsg with species.
</p></dd>
<dt>remesh:  <i>double,unsigned int,unsigned int,vector&lt;unsigned int&gt;,vector&lt;double&gt;</i></dt><dd>
<p>
       Handle commands to remesh the pool. This may involve changing the number of pool entries, as well as changing their volumes
</p></dd>
<dt>input:   <i>double</i></dt><dd>
<p>
       Handles input to control value of n_
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-97" class="outline-3">
<h3 id="sec-97"><span class="section-number-3">97</span> ZombieHHChannel</h3>
<div class="outline-text-3" id="text-97">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>Gbar:    <i>double</i></dt><dd>
<p>
       Maximal channel conductance
</p></dd>
<dt>Ek:      <i>double</i></dt><dd>
<p>
       Reversal potential of channel
</p></dd>
<dt>Gk:      <i>double</i></dt><dd>
<p>
       Channel conductance variable
</p></dd>
<dt>Ik:      <i>double</i></dt><dd>
<p>
       Channel current variable
</p></dd>
<dt>Xpower:  <i>double</i></dt><dd>
<p>
       Power for X gate
</p></dd>
<dt>Ypower:  <i>double</i></dt><dd>
<p>
       Power for Y gate
</p></dd>
<dt>Zpower:  <i>double</i></dt><dd>
<p>
       Power for Z gate
</p></dd>
<dt>instant: <i>int</i></dt><dd>
<p>
       Bitmapped flag: bit 0 = Xgate, bit 1 = Ygate, bit 2 = ZgateWhen true, specifies that the lookup table value should beused directly as the state of the channel, rather than usedas a rate term for numerical integration for the state
</p></dd>
<dt>X:       <i>double</i></dt><dd>
<p>
       State variable for X gate
</p></dd>
<dt>Y:       <i>double</i></dt><dd>
<p>
       State variable for Y gate
</p></dd>
<dt>Z:       <i>double</i></dt><dd>
<p>
       State variable for Y gate
</p></dd>
<dt>useConcentration:        <i>int</i></dt><dd>
<p>
       Flag: when true, use concentration message rather than Vm tocontrol Z gate
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>channelOut:      <i>double,double</i></dt><dd>
<p>
       Sends channel variables Gk and Ek to compartment
</p></dd>
<dt>permeability:    <i>double</i></dt><dd>
<p>
       Conductance term going out to GHK object
</p></dd>
<dt>IkOut:   <i>double</i></dt><dd>
<p>
       Channel current. This message typically goes to concenobjects that keep track of ion concentration.
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>Vm:      <i>double</i></dt><dd>
<p>
       Handles Vm message coming in from compartment
</p></dd>
<dt>Vm:      <i>double</i></dt><dd>
<p>
       Handles Vm message coming in from compartment
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call
</p></dd>
<dt>concen:  <i>double</i></dt><dd>
<p>
       Incoming message from Concen object to specific conc to usein the Z gate calculations
</p></dd>
<dt>createGate:      <i>string</i></dt><dd>
<p>
       Function to create specified gate.Argument: Gate type [X Y Z]
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-98" class="outline-3">
<h3 id="sec-98"><span class="section-number-3">98</span> ZombieMMenz</h3>
<div class="outline-text-3" id="text-98">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>Km:      <i>double</i></dt><dd>
<p>
       Michaelis-Menten constant in SI conc units (milliMolar)
</p></dd>
<dt>numKm:   <i>double</i></dt><dd>
<p>
       Michaelis-Menten constant in number units, volume dependent
</p></dd>
<dt>kcat:    <i>double</i></dt><dd>
<p>
       Forward rate constant for enzyme, units 1/sec
</p></dd>
<dt>numSubstrates:   <i>unsigned int</i></dt><dd>
<p>
       Number of substrates in this MM reaction. Usually 1.Does not include the enzyme itself
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>toSub:   <i>double,double</i></dt><dd>
<p>
       Sends out increment of molecules on product each timestep
</p></dd>
<dt>toPrd:   <i>double,double</i></dt><dd>
<p>
       Sends out increment of molecules on product each timestep
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>enzDest: <i>double</i></dt><dd>
<p>
       Handles # of molecules of Enzyme
</p></dd>
<dt>subDest: <i>double</i></dt><dd>
<p>
       Handles # of molecules of substrate
</p></dd>
<dt>prdDest: <i>double</i></dt><dd>
<p>
       Handles # of molecules of product. Dummy.
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call
</p></dd>
<dt>remesh:  <i>void</i></dt><dd>
<p>
       Tells the MMEnz to recompute its numKm after remeshing
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-99" class="outline-3">
<h3 id="sec-99"><span class="section-number-3">99</span> ZombiePool</h3>
<div class="outline-text-3" id="text-99">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>n:       <i>double</i></dt><dd>
<p>
       Number of molecules in pool
</p></dd>
<dt>nInit:   <i>double</i></dt><dd>
<p>
       Initial value of number of molecules in pool
</p></dd>
<dt>diffConst:       <i>double</i></dt><dd>
<p>
       Diffusion constant of molecule
</p></dd>
<dt>conc:    <i>double</i></dt><dd>
<p>
       Concentration of molecules in this pool
</p></dd>
<dt>concInit:        <i>double</i></dt><dd>
<p>
       Initial value of molecular concentration in pool
</p></dd>
<dt>size:    <i>double</i></dt><dd>
<p>
       Size of compartment. Units are SI. Utility field, the actual size info is stored on a volume mesh entry in the parent compartment.This is hooked up by a message. If the message isn'tavailable size is just taken as 1
</p></dd>
<dt>speciesId:       <i>unsigned int</i></dt><dd>
<p>
       Species identifier for this mol pool. Eventually link to ontology.
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>nOut:    <i>double</i></dt><dd>
<p>
       Sends out # of molecules in pool on each timestep
</p></dd>
<dt>requestMolWt:    <i>void</i></dt><dd>
<p>
       Requests Species object for mol wt
</p></dd>
<dt>requestSize:     <i>double</i></dt><dd>
<p>
       Requests Size of pool from matching mesh entry
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>group:   <i>void</i></dt><dd>
<p>
       Handle for grouping. Doesn't do anything.
</p></dd>
<dt>reacDest:        <i>double,double</i></dt><dd>
<p>
       Handles reaction input
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call
</p></dd>
<dt>handleMolWt:     <i>double</i></dt><dd>
<p>
       Separate finfo to assign molWt, and consequently diffusion const.Should only be used in SharedMsg with species.
</p></dd>
<dt>remesh:  <i>double,unsigned int,unsigned int,vector&lt;unsigned int&gt;,vector&lt;double&gt;</i></dt><dd>
<p>
       Handle commands to remesh the pool. This may involve changing the number of pool entries, as well as changing their volumes
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-100" class="outline-3">
<h3 id="sec-100"><span class="section-number-3">100</span> ZombieReac</h3>
<div class="outline-text-3" id="text-100">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>kf:      <i>double</i></dt><dd>
<p>
       Forward rate constant, in # units
</p></dd>
<dt>kb:      <i>double</i></dt><dd>
<p>
       Reverse rate constant, in # units
</p></dd>
<dt>Kf:      <i>double</i></dt><dd>
<p>
       Forward rate constant, in concentration units
</p></dd>
<dt>Kb:      <i>double</i></dt><dd>
<p>
       Reverse rate constant, in concentration units
</p></dd>
<dt>numSubstrates:   <i>unsigned int</i></dt><dd>
<p>
       Number of substrates of reaction
</p></dd>
<dt>numProducts:     <i>unsigned int</i></dt><dd>
<p>
       Number of products of reaction
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>toSub:   <i>double,double</i></dt><dd>
<p>
       Sends out increment of molecules on product each timestep
</p></dd>
<dt>toPrd:   <i>double,double</i></dt><dd>
<p>
       Sends out increment of molecules on product each timestep
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>subDest: <i>double</i></dt><dd>
<p>
       Handles # of molecules of substrate
</p></dd>
<dt>prdDest: <i>double</i></dt><dd>
<p>
       Handles # of molecules of product
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call
</p></dd>
<dt>remesh:  <i>void</i></dt><dd>
<p>
       Tells the reac to recompute its numRates, as remeshing has happened
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-101" class="outline-3">
<h3 id="sec-101"><span class="section-number-3">101</span> ZombieSumFunc</h3>
<div class="outline-text-3" id="text-101">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>result:  <i>double</i></dt><dd>
<p>
       outcome of summation
</p>
</dd>
</dl>

</li>
<li><b>Source field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>output:  <i>double</i></dt><dd>
<p>
       Sends out sum on each timestep
</p>
</dd>
</dl>

</li>
<li><b>Destination field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>input:   <i>double</i></dt><dd>
<p>
       Handles input values
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-102" class="outline-3">
<h3 id="sec-102"><span class="section-number-3">102</span> testSched</h3>
<div class="outline-text-3" id="text-102">


<ul>
<li><b>Value field</b>

</li>
<li><b>Source field</b>

</li>
<li><b>Destination field</b>
<dl>
<dt>process: <i>void</i></dt><dd>
<p>
       handles process call
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
</li>
</ul>

</div>
</div>
</div>

<div id="postamble">
<p class="date">Date: 2012-10-04 16:27:18 IST</p>
<p class="author">Author: </p>
<p class="creator">Org version 7.8.11 with Emacs version 23</p>
<a href="http://validator.w3.org/check?uri=referer">Validate XHTML 1.0</a>

</div>
</body>
</html>
