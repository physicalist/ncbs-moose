\section{Initialize store-house}
\label{sec:setup}

\paragraph{Dependencies and import}

  We need [[lxml.etree]] for XML parsing. To print error and warning messages, I
  wrote a small module [[DebugModule]] \ref{sec:debug}. This module is
  implemented in file [[debug.nw]]. 
  
\paragraph{Imports}

  This chunk [[Imports]] keeps the essentials modules which we'll need in almost
  all files. We might occasionally also need a logger from python [[logging]]
  library. Let's create a standard logger too.

<<Import>>=
# Basic imports
import os 
import sys 
import logging 
import debug 

logger = logging.getLogger('multiscale')
from lxml import etree

@ %def imports

\paragraph{Entry point}

  This is entry point of this program. Let's write down the sturcture of
  program. This is what we want to do in this application.
  
%file:src/main.py
<<main.py>>=
<<Import>>
<<functions in main>>
<<argument parser>>
<<parse xml models and handover control to main class>>

@ %def entry_point

\paragraph{Argument parser}

  This application accepts paths of XML based models from command line. More
  than one XML model can be passed from command line. Python comes with a
  standard library [[argparse]] well suited to do this job. If more than two
  XML models are to be passed, each should be passed with its own [[--xml]]
  switch e.g. to pass [[modelA.xml]] and [[modelB.xml]] from command line, use
  the string {\color{blue}[[--xml modelA.xml --xml modelB.xml]]}. We must also
  provide the path of [[adaptorML]] file.

<<argument parser>>=
# standard module for building a command line parser.
import argparse

# This section build the command line parser
argParser = argparse.ArgumentParser(description= 'Mutiscale modelling of neurons')
argParser.add_argument('--nml', metavar='nmlpath'
    , required = True
    , nargs = '+'
    , help = 'nueroml model'
    )
argParser.add_argument('--sbml', metavar='nmlpath'
    , nargs = '*'
    , help = 'sbml model'
    )
argParser.add_argument('--mechml', metavar='mechml'
    , nargs = '*'
    , help = 'mechml model'
    )
argParser.add_argument('--chml', metavar='channelml'
    , nargs = '*'
    , help = 'Channelml model'
    )
argParser.add_argument('--3dml', metavar='3dml'
    , nargs = '*'
    , help = '3DMCML model'
    )
argParser.add_argument('--meshml', metavar='meshml'
    , nargs = '*'
    , help = 'MeshML model'
    )
argParser.add_argument('--adaptor', metavar='adaptor'
    , required = True
    , nargs = '+'
    , help = 'AdaptorML for moose'
    )
args = argParser.parse_args()

@ %def argParser 

  Once we have verified paths of XML models, we need a module to parse them. For
  the purpose of modularity, we wrote this module in its on literate file
  [[parser.nw]] and you can see its documentation in section \ref{sec:parser}.


\paragraph{Parse XML models}

  But before we parse, we need a helper function to check if given paths exists
  and are readable.

<<functions in main>>=
def ifPathsAreValid(paths) :
  ''' Verify if path exists and are readable. '''
  if paths :
    paths = vars(paths)
    for p in paths :
      if not paths[p] : continue
      for path in paths[p] :
        if not path : continue
        if os.path.isfile(path) : pass
        else :
          debug.printDebug("ERROR"
            , "Filepath {0} does not exists".format(path))
          return False
      # check if file is readable 
      if not os.access(path, os.R_OK) :
        debug.printDebug("ERROR", "File {0} is not readable".format(path))
  return True

@ %def ifPathsAreValid


\paragraph{Parse XML files}

  At least one model must be provided by the user.  Validation is not enable in
  this version. \todo[inline, color=red!60]{Download new neuroML2 models and
  turn validate=True in [[parseModels]] function call.}

<<parse xml models and handover control to main class>>=
import parser
if args : 
  if ifPathsAreValid(args) :
    logger.info("Started parsing XML models")
    debug.printDebug("INFO", "Started parsing XML models")
    etreeDict = parser.parseModels(args, validate=False)
    debug.printDebug("INFO", "Parsing of models is done")
    <<hand over control to class in multiscale module>>
    print("Done!")
  else :
    debug.printDebug("FATAL", "One or more model file does not exists.")
    sys.exit()
else :
  debug.printDebug("FATAL", "Please provide at least one model. None given.")
  sys.exit()

@ %def parse_models 

\paragraph{Create multi-scale models in Moose}
  
  We are done initializing our application. Lets define a class [[Multiscale]]
  and hand over the control to its object. This class is defined in 
  [[multiscale.nw]]. We need to import module [[multiscale]] to be able to
  initialize and object of this class.

<<hand over control to class in multiscale module>>=
import multiscale
multiScaleObj = multiscale.Multiscale(etreeDict)
multiScaleObj.buildMultiscaleModel()
@ %def multiScaleObj 

Over to \ref{sec:multiscale}.

