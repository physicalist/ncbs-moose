\documentclass{article}
%\usepackage[margin=10mm]{geometry}
\usepackage{pgf,tikz}
%\usepackage{algorithm2e}
%\usepackage{subfig}
\usepackage{noweb}
\usepackage{amsmath}
\usepackage{color}
\usepackage{amssymb}
\usepackage{listings}
\usetikzlibrary{circuits.logic.US}
\usetikzlibrary{positioning}
\usetikzlibrary{matrix}
 
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{ %
  language=python,                % the language of the code
  basicstyle=\footnotesize,           % the size of the fonts that are used for the code
  numbers=left,                   % where to put the line-numbers
  numberstyle=\tiny\color{gray},  % the style that is used for the line-numbers
  stepnumber=2,                   % the step between two line-numbers. If it's 1, each line 
                                  % will be numbered
  numbersep=5pt,                  % how far the line-numbers are from the code
  backgroundcolor=\color{white},      % choose the background color. You must add \usepackage{color}
  showspaces=false,               % show spaces adding particular underscores
  showstringspaces=false,         % underline spaces within strings
  showtabs=false,                 % show tabs within strings adding particular underscores
%  frame=single,                   % adds a frame around the code
  rulecolor=\color{black},        % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. commens (green here))
  tabsize=2,                      % sets default tabsize to 2 spaces
  captionpos=b,                   % sets the caption-position to bottom
  breaklines=true,                % sets automatic line breaking
  breakatwhitespace=false,        % sets if automatic breaks should only happen at whitespace
  title=\lstname,                   % show the filename of files included with \lstinputlisting;
                                  % also try caption instead of title
  keywordstyle=\color{blue},          % keyword style
  commentstyle=\color{dkgreen},       % comment style
  stringstyle=\color{mauve},         % string literal style
  escapeinside={\%*}{*)},            % if you want to add LaTeX within your code
  morekeywords={*,...}               % if you want to add more keywords to the set
}
\usepackage{amsthm}
\usepackage{todonotes}
\usepackage{hyperref}
\setlength{\parskip}{3mm}
\newtheorem{axiom}{Axiom}
\newtheorem{definition}{Definition}
\newtheorem{comment}{Comment}
\newtheorem{example}{Example}
\newtheorem{lemma}{Lemma}
\newtheorem{prop}{Property}
\newtheorem{problem}{Problem}
\newtheorem{remark}{Remark}
\newtheorem{theorem}{Theorem}

% Title Page
\title{\textbf{Developer documentation} \\
Multiscale modelling in \href{www.moose.ncbs.res.in}{Moose}}
\author{Dilawar Singh}
\date{\today}

\begin{document}
\maketitle

\begin{abstract}

  This documentation is a literate program. This is an attempt to develop
  multiscale modelling capabilities in Moose simulator.

  You need [[noweb]] tool to generate documentation out of these files. Run
  [[./run_web.sh --doc]] to generate documentation after installing [[noweb]].
  Run [[./run_web.sh]] to run the application.

  Contact \href{mailto:dilawars@ncbs.res.in}{Dilawar Singh} if you need any help.
  \todo[color=red!60]{Write introduction to multiscale modelling}

\end{abstract}


\section{Multiscale modelling}

\paragraph{Dependencies and import}

  We need [[lxml.etree]] for XML parsing. To print error and warning messages, I
  wrote a small module [[DebugModule]] \ref{sec:debug}. This module is
  implemented in file [[debug.nw]]. 
  
\paragraph{Imports}

  This chunks keeps the essentials modules which we need in almost all files.
  We'll try to import [[cElementTree]] first and then some other implementation of
  [[etree]]. Some other modules such as [[os]], [[sys]], [[re]] etc are also
  needed.
<<Import>>=
# Basic imports
import os 
import sys 
import logging 
import debug 

logger = logging.getLogger('multiscale')
try:
    import cElementTree as etree
    debug.printDebug("DEBUG", "running with lxml.etree")
except ImportError:
    try:
        # Python 2.5
        import xml.etree.cElementTree as etree
        debug.printDebug("DEBUG", "running with cElementTree")
    except ImportError:
        try:
            # Python 2.5
            import xml.etree.cElementTree as etree
            debug.printDebug("DEBUG", "running with ElementTree")
        except ImportError:
            try:
              # normal cElementTree install
              import cElementTree as etree
              debug.printDebug("DEBUG", "running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree
                    debug.printDebug("DEBUG", "running with ElementTree")
                except ImportError:
                    try : 
                      import lxml.etree as etree
                    except ImportError :
                        debug.prefix("FATAL", "Failed to import ElementTree")
                        os._exit(1)

@ %def imports

\paragraph{Entry point}

  This is entry point of this program. Let's write down the sturcture of
  program. This is what we want to do in this application.
  
%file:src/main.py
<<main.py>>=
<<Import>>
<<functions in main>>
<<argument parser>>
<<parse xml models>>
<<build multiscale models in moose>>
<<run and test the multiscale models>>

@ %def entry_point

\paragraph{Agrument parser}

  Paths of models files are to be passed  from the command line. More than one
  xml file can be passed. We use [[argparse]] library to build a command-line
  interface.

<<argument parser>>=

'''
command line parser
'''

# standard module for building a command line parser.

import argparse

# This section build the command line parser
argParser = argparse.ArgumentParser(description= 'Mutiscale modelling of neurons')
argParser.add_argument('--nml', metavar='nmlpath'
    , help = 'File having neuron described in neuroML'
    )
argParser.add_argument('--sbml', metavar='sbmlpath'
    , help = 'File having neuron described in SBML'
    , required = False
    )
args = argParser.parse_args()

# command line parser ends here.

@ %def argParser 

  We need a module to parse the xml models. This module has its own literate
  file [[parser.nw]]. You can see the documentation in \ref{sec:parser}.


\paragraph{Parse xml models}

  We pass two kind of models from command line to this application, [[sbml]] and
  [[neuroML]]. Parse them and we'll think of next step. We need at least one
  model to start with (neuroML?).

  But before we parse, we need a helper function to check if given paths exists
  and are readable.

<<functions in main>>=
def ifPathsAreValid(paths) :
  ''' Verify if path exists and are readable. '''
  if paths.nml :
    if os.path.isfile(paths.nml) : pass
    else :
      debug.printDebug("ERROR", "Filepath {0} is not valid".format(paths.nml))
      return False
  if paths.sbml :
    if os.path.isfile(paths.sbml) : pass 
    else :
      debug.printDebug("ERROR", "Filepath {0} is not valid".format(paths.sbml))
      return False
  return True

@ %def ifPathsAreValid


\paragraph{Parse xml files}

  At least one model must be provided by the user \todo[size=\small,
  color=red!20]{configure command line to raise error if at least one xmlpath is
  not provided}.

<<parse models>>=

# There must be at least one model specified by user at command line.
import parser
if args.nml or args.sbml : 
  if ifPathsAreValid(args) :
    logger.info("Started parsing XML models")
    debug.printDebug("INFO", "Started parsing XML models")
    etreeList = parser.parseModels(args)
  else :
    debug.printDebug("FATAL", "One or more model file does not exists.")
    sys.exit()
else :
  debug.printDebug("FATAL", "Please provide at least one model. None given.")
  sys.exit()

debug.printDebug("INFO", "Parsing of models is done")
@

\section{Debug module, print debugging messages}
\label{sec:debug}

  Different type of messages are printed in different colors.

%file:src/debug.py
<<debug.py>>=
HEADER = '\033[95m'
OKBLUE = '\033[94m'
OKGREEN = '\033[92m'
WARNING = '\033[93m'
ERR = '\033[91m'
ENDC = '\033[0m'
RED = ERR
WARN = WARNING
INFO = OKGREEN 
TODO = OKBLUE
DEBUG = HEADER

prefix = dict(
    ERR = ERR
    , WARN = WARN
    , FATAL = ERR
    , INFO = INFO
    , TODO = TODO 
    , NOTE = HEADER 
    , DEBUG = DEBUG
    )

def colored(msg, label) :
    """
    Return a colored string. Formatting is optional.
    """
    global prefix
    if label in prefix :
        color = prefix[label]
    else :
        color = ""
    return "[{0}] {1} {2}".format(label, color+msg, ENDC)

def printDebug(label, msg):
    print(colored(msg, label))

@ %def debug_module 

\section{XML parser}

This document deals with parser of XML models.

%file:src/parser.py
<<parser.py>>=
<<Import>>

def getModels(models) :

    """ 
    
    Parses given xml models. We can pass either one or two models; one described
    in neuroML and the other in sbml. 
    
    Notes: Document is properly. See 

      http://www.biomedcentral.com/1752-0509/7/88/abstract

    sent by Aditya Girla. It a online composition tool for SBML. In its
    references, some other tools are mentioned.

    Args :

    Raises :

    Return 
    return a list of elementTree of given models.

    """
    elemDict = dict()
    if models.nml :
        # Get the schema 
        with open(models.nml, "r") as nmlFile :
            elemDict['nml'] = models.nml
        
    if models.sbml :
        elemDict['sbml'] = models.sbml
    return elemDict
 

@ %def getModel 

\paragraph{Parse xml}

  Let's write a function to parse xml and return the root element.

<<parser.py>>=
def parseModel(modelPath):
   if not os.path.exists(modelPath) :
     pass
@

                                       
\listoftodos
\end{document}          
