\documentclass{article}
%\usepackage[margin=10mm]{geometry}
\usepackage{pgf,tikz}
%\usepackage{algorithm2e}
%\usepackage{subfig}
\usepackage{noweb}
\usepackage{amsmath}
\usepackage{color}
\usepackage{amssymb}
\usepackage{listings}
\usetikzlibrary{circuits.logic.US}
\usetikzlibrary{positioning}
\usetikzlibrary{matrix}
 
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{ %
  language=python,                % the language of the code
  basicstyle=\footnotesize,           % the size of the fonts that are used for the code
  numbers=left,                   % where to put the line-numbers
  numberstyle=\tiny\color{gray},  % the style that is used for the line-numbers
  stepnumber=2,                   % the step between two line-numbers. If it's 1, each line 
                                  % will be numbered
  numbersep=5pt,                  % how far the line-numbers are from the code
  backgroundcolor=\color{white},      % choose the background color. You must add \usepackage{color}
  showspaces=false,               % show spaces adding particular underscores
  showstringspaces=false,         % underline spaces within strings
  showtabs=false,                 % show tabs within strings adding particular underscores
%  frame=single,                   % adds a frame around the code
  rulecolor=\color{black},        % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. commens (green here))
  tabsize=2,                      % sets default tabsize to 2 spaces
  captionpos=b,                   % sets the caption-position to bottom
  breaklines=true,                % sets automatic line breaking
  breakatwhitespace=false,        % sets if automatic breaks should only happen at whitespace
  title=\lstname,                   % show the filename of files included with \lstinputlisting;
                                  % also try caption instead of title
  keywordstyle=\color{blue},          % keyword style
  commentstyle=\color{dkgreen},       % comment style
  stringstyle=\color{mauve},         % string literal style
  escapeinside={\%*}{*)},            % if you want to add LaTeX within your code
  morekeywords={*,...}               % if you want to add more keywords to the set
}
\usepackage{amsthm}
\usepackage{todonotes}
\usepackage{hyperref}
\setlength{\parskip}{3mm}
\newtheorem{axiom}{Axiom}
\newtheorem{definition}{Definition}
\newtheorem{comment}{Comment}
\newtheorem{example}{Example}
\newtheorem{lemma}{Lemma}
\newtheorem{prop}{Property}
\newtheorem{problem}{Problem}
\newtheorem{remark}{Remark}
\newtheorem{theorem}{Theorem}

% Title Page
\title{\textbf{Developer documentation} \\
Multiscale modelling in \href{www.moose.ncbs.res.in}{Moose}}
\author{Dilawar Singh}
\date{\today}

\begin{document}
\maketitle

\begin{abstract}

  This documentation is a literate program. This is an attempt to develop
  multiscale modelling capabilities in Moose simulator.

  You need [[noweb]] tool to generate documentation out of these files. Run
  [[./run_web.sh --doc]] to generate documentation after installing [[noweb]].
  Run [[./run_web.sh]] to run the application.

  Contact \href{mailto:dilawars@ncbs.res.in}{Dilawar Singh} if you need any help.
  \todo[color=red!60]{Write introduction to multiscale modelling}

\end{abstract}


\section{Multiscale modelling}

\paragraph{Dependencies and import}

  We need [[lxml.etree]] for XML parsing. To print error and warning messages, I
  wrote a small module [[DebugModule]] \ref{sec:debug}. This module is
  implemented in file [[debug.nw]]. 
  
\paragraph{Imports}

  This chunks [[Imports]] keeps the essentials modules which we need in almost
  all files.  We'll try to import [[cElementTree]] first, and then some other
  implementation of [[etree]]. Some other modules such as [[os]], [[sys]],
  [[re]] etc are also needed.

<<Import>>=
# Basic imports
import os 
import sys 
import logging 
import debug 

logger = logging.getLogger('multiscale')
from lxml import etree

@ %def imports

\paragraph{Entry point}

  This is entry point of this program. Let's write down the sturcture of
  program. This is what we want to do in this application.
  
%file:src/main.py
<<main.py>>=
<<Import>>
<<functions in main>>
<<argument parser>>
<<parse xml models>>
<<build multiscale models in moose>>
<<run and test the multiscale models>>

@ %def entry_point

\paragraph{Agrument parser}

  Paths of models files are to be passed  from the command line. More than one
  xml file can be passed. We use [[argparse]] library to build a command-line
  interface.

<<argument parser>>=

'''
command line parser
'''

# standard module for building a command line parser.

import argparse

# This section build the command line parser
argParser = argparse.ArgumentParser(description= 'Mutiscale modelling of neurons')
argParser.add_argument('--nml', metavar='nmlpath'
    , help = 'File having neuron described in neuroML'
    )
argParser.add_argument('--sbml', metavar='sbmlpath'
    , help = 'File having neuron described in SBML'
    , required = False
    )
args = argParser.parse_args()

# command line parser ends here.

@ %def argParser 

  We need a module to parse the xml models. This module has its own literate
  file [[parser.nw]]. You can see the documentation in \ref{sec:parser}.


\paragraph{Parse xml models}

  We pass two kind of models from command line to this application, [[sbml]] and
  [[neuroML]]. Parse them and we'll think of next step. We need at least one
  model to start with (neuroML?).

  But before we parse, we need a helper function to check if given paths exists
  and are readable.

<<functions in main>>=
def ifPathsAreValid(paths) :
  ''' Verify if path exists and are readable. '''
  if paths.nml :
    if os.path.isfile(paths.nml) : pass
    else :
      debug.printDebug("ERROR", "Filepath {0} is not valid".format(paths.nml))
      return False
  if paths.sbml :
    if os.path.isfile(paths.sbml) : pass 
    else :
      debug.printDebug("ERROR", "Filepath {0} is not valid".format(paths.sbml))
      return False
  return True

@ %def ifPathsAreValid


\paragraph{Parse xml files}

  At least one model must be provided by the user \todo[size=\small,
  color=red!20]{configure command line to raise error if at least one xmlpath is
  not provided}.

<<parse xml models>>=

# There must be at least one model specified by user at command line.
import parser
if args.nml or args.sbml : 
  if ifPathsAreValid(args) :
    logger.info("Started parsing XML models")
    debug.printDebug("INFO", "Started parsing XML models")
    etreeDict = parser.parseModels(args, validate=False)
    print etreeDict
  else :
    debug.printDebug("FATAL", "One or more model file does not exists.")
    sys.exit()
else :
  debug.printDebug("FATAL", "Please provide at least one model. None given.")
  sys.exit()
debug.printDebug("INFO", "Parsing of models is done")

@ %def parse_models 

\section{Debug module, print debugging messages}
\label{sec:debug}

  Different type of messages are printed in different colors.

%file:src/debug.py
<<debug.py>>=
HEADER = '\033[95m'
OKBLUE = '\033[94m'
OKGREEN = '\033[92m'
WARNING = '\033[93m'
ERR = '\033[91m'
ENDC = '\033[0m'
RED = ERR
WARN = WARNING
INFO = OKGREEN 
TODO = OKBLUE
DEBUG = HEADER

prefix = dict(
    ERR = ERR
    , WARN = WARN
    , FATAL = ERR
    , INFO = INFO
    , TODO = TODO 
    , NOTE = HEADER 
    , DEBUG = DEBUG
    )

def colored(msg, label) :
    """
    Return a colored string. Formatting is optional.
    """
    global prefix
    if label in prefix :
        color = prefix[label]
    else :
        color = ""
    return "[{0}] {1} {2}".format(label, color+msg, ENDC)

def printDebug(label, msg):
    print(colored(msg, label))

@ %def debug_module 

\section{XML parser}
\label{sec:parser}

  This section deals with parser of XML models. In [[multiscale.nw]], we call
  function [[parseModels]] of this modudle. This function receives argument from
  the command line, having paths of XML models. These paths of model files are
  valid and readable, this has been verified before sending arguments to this
  function. We need to parse the XMLs and return a dictionary, with keys as path
  of XML models and value as top-most XML element.

  Following captures what this module suppose to do.

%file:src/parser.py
<<parser.py>>=
<<Import>>
<<helper functions>>
<<function [[parseModels]] for parsing models>>
@

\paragraph{Parse models}

  Function [[parseModels]] parses the model, and it creates a dictionary to be
  returned. This function first read the file and validate it with a given
  schema. Validation can be turned on/off by setting the optional argument
  [[validate]] to [[False]].

<<function [[parseModels]] for parsing models>>=
def parseModels(commandLineArgs, validate=False) :
    '''
    Parse given models.
   
    '''
    xmlRootElemDict = dict()

    models = vars(commandLineArgs)
    for model in models :
      if models[model] :
        modelPath = models[model]
        debug.printDebug("INFO", "Parsing {0}".format(models[model]))
        if validate :
          # parse model and valid it with schama
          modelXMLRootElem = parseAndValidateWithSchema(model, modelPath)
        else :
          # Simple parse the model without validating it with schema.
          modelXMLRootElem = parseWithoutValidation(model, modelPath)
        xmlRootElemDict[model] = modelXMLRootElem 
    return xmlRootElemDict 

@  %def parseModels 

\paragraph{Validating with schema}

  We need two helper functions, [[parseAndValidateWithSchema]] to parse a given
  XML when a schema is available and [[parseWithoutValidation]] validation is
  off \textbf{schema is not available}. Ideally, schema should be provided as an
  argument to this module, but we can fix their location. Folder [[./moose_xml]]
  must contains all the schemas we need to validate. Currently
  [[./moose_xml/NeuroML_v2beta1.xsd]] and [[./moose_xml/sbml.xsd]] are schemas
  available for [[nml]] and [[sbml]] models.

%  What should be the relative path of these schemas; the source code generated
%  is always in one level below than the directory of this literate file e.g.
%  generated python file resides in \texttt{./src} directory while this file is
%  in \texttt{.} directory. Therefore, paths of these schemas are different in
%  the implementation of following functions than they are in this literate file.
%

<<helper functions>>=
def parseAndValidateWithSchema(modelName, modelPath) :
    
    prefixPath = ''
    if modelName == 'nml' :
      schemaPath = os.path.join(prefixPath, 'moose_xml/NeuroML_v2beta1.xsd')
    elif modelName == 'sbml' :
      schemaPath = os.path.join(prefixPath, 'moose_xml/sbml.xsd')

    try :
      schemaH = open(schemaPath, "r")
      schemaText = schemaH.read()
      schemaH.close()
    except Exception as e :
      debug.printDebug("WARN", "Error reading schema for validation."+
        " Falling back to validation-disabled parser."
        + " Failed with error {0}".format(e))
      return parseWithoutValidation(modelName, modelPath)
    # Now we have the schema text 
    schema = etree.XMLSchema(etree.XML(schemaText))
    xmlParser = etree.XMLParser(schema=schema)
    with open(modelPath, "r") as xmlTextFile :
        return etree.parse(xmlTextFile, xmlParser)

@ %def parseAndValidateWithSchema 

<<helper functions>>=
def parseWithoutValidation(modelName, modelPath) :
    try :
      xmlRootElem = etree.parse(modelPath)
    except e :
      debug.printDebug("ERROR", "Failed to parse model with error {0}".format(e))
      return 
    return xmlRootElem 

@ %def parseWithoutValidation 





\listoftodos
\end{document}          
