\documentclass{article}
%\usepackage[margin=10mm]{geometry}
\usepackage{pgf,tikz}
%\usepackage{algorithm2e}
%\usepackage{subfig}
\usepackage{noweb}
\usepackage{amsmath}
\usepackage{color}
\usepackage{amssymb}
\usepackage{listings}
%\usepackage{glossaries}

\usetikzlibrary{circuits.logic.US}
\usetikzlibrary{positioning}
\usetikzlibrary{matrix}
 
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{ %
  language=python,                % the language of the code
  basicstyle=\footnotesize,           % the size of the fonts that are used for the code
  numbers=left,                   % where to put the line-numbers
  numberstyle=\tiny\color{gray},  % the style that is used for the line-numbers
  stepnumber=2,                   % the step between two line-numbers. If it's 1, each line 
                                  % will be numbered
  numbersep=5pt,                  % how far the line-numbers are from the code
  backgroundcolor=\color{white},      % choose the background color. You must add \usepackage{color}
  showspaces=false,               % show spaces adding particular underscores
  showstringspaces=false,         % underline spaces within strings
  showtabs=false,                 % show tabs within strings adding particular underscores
%  frame=single,                   % adds a frame around the code
  rulecolor=\color{black},        % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. commens (green here))
  tabsize=2,                      % sets default tabsize to 2 spaces
  captionpos=b,                   % sets the caption-position to bottom
  breaklines=true,                % sets automatic line breaking
  breakatwhitespace=false,        % sets if automatic breaks should only happen at whitespace
  title=\lstname,                   % show the filename of files included with \lstinputlisting;
                                  % also try caption instead of title
  keywordstyle=\color{blue},          % keyword style
  commentstyle=\color{dkgreen},       % comment style
  stringstyle=\color{mauve},         % string literal style
  escapeinside={\%*}{*)},            % if you want to add LaTeX within your code
  morekeywords={*,...}               % if you want to add more keywords to the set
}
\usepackage{amsthm}
\usepackage{todonotes}
\usepackage{hyperref}
\setlength{\parskip}{3mm}
\newtheorem{axiom}{Axiom}
\newtheorem{definition}{Definition}
\newtheorem{comment}{Comment}
\newtheorem{example}{Example}
\newtheorem{lemma}{Lemma}
\newtheorem{prop}{Property}
\newtheorem{problem}{Problem}
\newtheorem{remark}{Remark}
\newtheorem{note}{Note}
\newtheorem{theorem}{Theorem}

% Title Page
\title{\textbf{Developer document} \\
Multiscale modelling in \href{www.moose.ncbs.res.in}{Moose}}
\author{Dilawar Singh}
\date{\today}

\begin{document}
\maketitle

\begin{abstract}
\label{abstract}

  This documentation is a literate program. This describes and ongoing attempt
  to make moose more capable of doing multi-scale modelling. There are various
  XML based models available, each describing a particular aspect of neural
  activities. Some describes the chemical activities inside neuron while some
  other describe their electrical properties etc. We wish to write a super-XML
  model which can make use of all these models and map them onto moose.
  Currently, we call it [[adaptorML]]. Later we should find a cool name for it
  such as [[mooseML]] or [[mooooml]].

\end{abstract}

\paragraph{Dependencies}

  You need [[noweb]] tool to generate documentation from this file. This file
  contains some macros which are not understood by [[noweb]]. These macros are
  used by a python script [[./pynoweb.py]] to generate [[noweb]] file. You need
  not know how to use it. Just run [[./generate_code_and_docs.sh --doc]] to
  generate documentation after installing [[noweb]].  Run the same command
  without [[--doc]] switch and you have your working application in [[src]]
  directory. 
  
  Contact the very friendly Homo Sapience Sapience named
  \href{mailto:dilawars@ncbs.res.in}{Dilawar Singh} if you need any help.
  He can be reached at \url{dilawars@ncbs.res.in}.
  \todo[color=red!60]{Write introduction to multiscale modelling}

\section{Initialize store-house}
\label{sec:setup}

\paragraph{Dependencies and import}

  We need [[lxml.etree]] for XML parsing. To print error and warning messages, I
  wrote a small module [[DebugModule]] \ref{sec:debug}. This module is
  implemented in file [[debug.nw]]. 
  
\paragraph{Imports}

  This chunk [[Imports]] keeps the essentials modules which we'll need in almost
  all files. We might occasionally also need a logger from python [[logging]]
  library. Let's create a standard logger too.

<<Import>>=
# Basic imports
import os 
import sys 
import logging 
import debug 

logger = logging.getLogger('multiscale')
from lxml import etree

@ %def imports

\paragraph{Entry point}

  This is entry point of this program. Let's write down the sturcture of
  program. This is what we want to do in this application.
  
%file:src/main.py
<<main.py>>=
<<Import>>
<<functions in main>>
<<argument parser>>
<<parse xml models and handover control to main class>>

@ %def entry_point

\paragraph{Argument parser}

  This application accepts paths of XML based models from command line. More
  than one XML model can be passed from command line. Python comes with a
  standard library [[argparse]] well suited to do this job. If more than two
  XML models are to be passed, each should be passed with its own [[--xml]]
  switch e.g. to pass [[modelA.xml]] and [[modelB.xml]] from command line, use
  the string {\color{blue}[[--xml modelA.xml --xml modelB.xml]]}. We must also
  provide the path of [[adaptorML]] file.

<<argument parser>>=
# standard module for building a command line parser.
import argparse

# This section build the command line parser
argParser = argparse.ArgumentParser(description= 'Mutiscale modelling of neurons')
argParser.add_argument('--xml', metavar='nmlpath'
    , required = True
    , nargs = '+'
    , help = 'multiscale model in XML'
    )
argParser.add_argument('--adaptor', metavar='nmlpath'
    , required = True
    , help = 'AdaptorML for moose'
    )
args = argParser.parse_args()

@ %def argParser 

  Once we have verified paths of XML models, we need a module to parse them. For
  the purpose of modularity, we wrote this module in its on literate file
  [[parser.nw]] and you can see its documentation in section \ref{sec:parser}.


\paragraph{Parse XML models}

  But before we parse, we need a helper function to check if given paths exists
  and are readable.

<<functions in main>>=
def ifPathsAreValid(paths) :
  ''' Verify if path exists and are readable. '''
  if paths.xml :
    for path in paths.xml :
      if os.path.isfile(path) : pass
      else :
        debug.printDebug("ERROR", "Filepath {0} does not exists".format(path))
        return False
    # check if file is readable 
    if not os.access(path, os.R_OK) :
      debug.printDebug("ERROR", "File {0} is not readable".format(path))
  return True

@ %def ifPathsAreValid


\paragraph{Parse XML files}

  At least one model must be provided by the user.  Validation is not enable in
  this version. \todo[inline, color=red!60]{Download new neuroML2 models and
  turn validate=True in [[parseModels]] function call.}

<<parse xml models and handover control to main class>>=
import parser
if args.xml : 
  if ifPathsAreValid(args) :
    logger.info("Started parsing XML models")
    debug.printDebug("INFO", "Started parsing XML models")
    etreeDict = parser.parseModels(args, validate=False)
    debug.printDebug("INFO", "Parsing of models is done")
    <<hand over control to class in multiscale module>>
    print("Done!")
  else :
    debug.printDebug("FATAL", "One or more model file does not exists.")
    sys.exit()
else :
  debug.printDebug("FATAL", "Please provide at least one model. None given.")
  sys.exit()

@ %def parse_models 

\paragraph{Create multi-scale models in Moose}
  
  We are done initializing our application. Lets define a class [[Multiscale]]
  and hand over the control to its object. This class is defined in 
  [[multiscale.nw]]. We need to import module [[multiscale]] to be able to
  initialize and object of this class.

<<hand over control to class in multiscale module>>=
import multiscale
multiScaleObj = multiscale.Multiscale(etreeDict)
multiScaleObj.buildMultiscaleModel()
@ %def multiScaleObj 

Over to \ref{sec:multiscale}.

\section{Construct a Database/AST from XML models}
\label{sec:multiscale}
  
  This is our defining module and it contains the basic functionality of this
  application. All XML modules are parsed into a dictionary and this dictionary
  is passed to the object of class [[Multiscale]] which is the main class in
  this module. We also have [[adaptorML]] file parsed in dictionary. 

\begin{remark}{Why AST/Database?}
 
 Should I directly map XML models to moose objects or a intermediate
 representation would be better. I am leaning towards haivng a intermediate
 sqlite3 based data-structure. The benefit of using sqlite is that we can simply
 insert and query the database without having to keep all XML models open. We'll
 simply populate the database for each given model. Details are bit hazy in my
 mind right now and I should add the them to this document as they become
 clearer to me.

\end{remark}
 
\paragraph{Structure} Structure of this module is following. 

%file:src/multiscale.py
<<multiscale>>=
<<Import>>
<<Local imports>>
<<Definition of class [[Multiscale]]>>

@ %def multiscale 

\paragraph{A skeleton of class}

  Now we have parsed XML. We are passing the parsed XML in dictionary to a
  method [[buildMultiscaleModel]] of this class. We know, what this class must
  have at this point. Let's write it down and we'll wonder later how to add more
  functionality. 
  
<<Definition of class [[Multiscale]]>>=

class Multiscale :
  
  def __init__(self, xmlDict) :
    self.xmlDict = xmlDict 
    <<initialize members>>
    debug.printDebug("INFO", "Object of class Multiscale intialized ...")

  <<methods in class [[Multiscale]]>>

  # This is the entry point of this class.
  def buildMultiscaleModel(self) :
      debug.printDebug("INFO", "Starting to build multiscale model")   
      <<flow of executation>>
  
  def exit(self) :
    # Clean up before you leave
    <<clean up the mess>>

  # Write down the tests, whenever needed.
  <<tests in class [[Multiscale]]>>



@ %def [[Multiscale]]

Before we move on, lets discuss some models developed by others we need to
import into moose.

\section{Traub models and their translation into Python}
\label{subsec:traub}

This file is based on file [[proto8.py]]. Following is based on the header of
this file.

\paragraph{Model information}

 This implementation is mostly based on on the
 \href{thttp://www.genesis-sim.org/GENESIS/Tutorials/cells/traubcell/traub91proto.g}{graub91proto.g}
 by Dave Beeman. Main difference is addition of Glu and NMDA \footnote{A
 predominant molecular device for controlling synaptic plasticity and memory
 function} channels. The 1991 Traub set of voltage and concentration dependent
 channels implemented as tabchannels by Dave Beeman R.D.Traub, R. K.  S. Wong,
 R. Miles, and H.  Michelson Journal of Neurophysiology, Vol. 66, p. 635 (1991)

 This file depends on functions and constants defined in defaults.g
 As it is also intended as an example of the use of the tabchannel
 object to implement concentration dependent channels, it has extensive
 comments.  Note that the original units used in the paper have been
 converted to SI (MKS) units.  Also, we define the ionic equilibrium 
 potentials relative to the resting potential, [[EREST_ACT]].  In the
 paper, this was defined to be zero.  Here, we use -0.060 volts, the
 measured value relative to the outside of the cell.

 November 1999 update for GENESIS 2.2: Previous versions of this file used
 a combination of a table, [[tabgate]], and [[vdep\_channel]] to implement the
 Ca-dependent K Channel - $K(C)$.  This new version uses the new tabchannel
 "instant" field, introduced in GENESIS 2.2, to implement an
 "instantaneous" gate for the multiplicative Ca-dependent factor in the
 conductance.   This allows these channels to be used with the fast
 [[hsolve]]  chanmodes > 1.

 This Traub model is now converted to an equivalent python model described here.
 It is used in [[pymoose]].


%file:src/proto.py
<<proto.py>>=
import moose
import numpy
import math

<<Define constants>>
<<Functions to create channels>>
<<Functions to maniputate property of channels>>
<<Glu receptor>>
<<NMDA receptor>>
<<Spike detector>>
@ %def proto 

\paragraph{Constants in model}

  \begin{table}[h]
    \centering
    \begin{tabular}{rll}
    \hline
    EREST\_ACT & Hippocampal cell resting potentional & $Volt$ \\
    ENA        & Equilibrium potential of Sodium      & $Volt$ \\
    EK         & Equilibrium potential of Potassium   & $Volt$ \\
    ECA        & Equilibrium potential of Calcium     & $Volt$ \\
    SOMA\_A    & Area of soma                         & $m^2$ \\
    \hline
    \end{tabular}
    \caption{Constants in this model}
  \end{table}

<<Define constants>>=
EREST_ACT = -0.060      # /* hippocampal cell resting potl */
ENA = 0.115 + EREST_ACT # // 0.055
EK = -0.015 + EREST_ACT # // -0.075
ECA = 0.140 + EREST_ACT # // 0.080
SOMA_A = 3.320e-9       # // soma area in square meters
@ %def constants 

\paragraph{Channels in model}
 
 For these channels, the maximum channel conductance ($Gbar$) has been
 calculated using the [[CA3]] \footnote{hippocampal pyramidal cell} soma channel
 conductance densities and soma area.  Typically, the functions which create
 these channels will be used to create a library of prototype channels.  When
 the cell reader creates copies of these channels in various compartments, it
 will set the actual value of Gbar by calculating it from the cell parameter
 file.


<<Functions to create channels>>=
<<Ordinary Ca channel>>
<<Ca-dependent K-AHP channel>>
<<Ca-dependent K-C channel>>
<<Tabchannel Na Hippocampal cell channel>>
<<Tabchannel K-DR Hippocampal cell channel>>
<<Tabchannel K-A Hippocampal cell channell>>

@ %def channels 

\paragraph{Tabulated Calcium channel}
    

\begin{note}{This note is from Traub's model written in Fortran}

Often, the alpha and beta rate parameters can be expressed in the functional
form $y = \frac{A + Bx}{C + \exp{\frac{x + D}{F}}}$.  When this is the case, the
command [[setupalpha chan gate AA AB AC AD AF BA BB BC BD BF]] can be used to
simplify the process of initializing the A and B tables for the X, Y and Z
gates.  Although [[setupalpha]] has been implemented as a compiled GENESIS
command, it is also defined as a script function in the
[[neurokit/prototypes/defaults.g]] file.  Although this command can be used as a
"black box", its definition shows some nice features of the [[tabchannel]]
object, and some tricks we will need when the rate parameters do not fit this
form.

\end{note}

 We can give a short summary of the variables used in this function and
 relationship among them.

\begin{equation}
Gbar = {Gk}X^{Xpower}Y^{Ypower}Z^{Zpower}
\end{equation}

\begin{table}[h!]
\centering
 \begin{tabular}[h]{lrr}
 \hline \\
 Ek & Reversal potential of channel & constant\\
 Gk & Channel conductance & variable \\
 Gbar & Maximum channel conductance & constant \\
 Xpower \footnote{See "The book of genesis" for explaination on this model}
        & Power of X-gate & constant \\ 
 Ypower & Power of Y gate & constant \\
 Zpower & Power of Z gate & constant \\
 \hline 
 \end{tabular}
 \caption{A short summary of variables used in function [[make_Ca]]}
 
\end{table}


<<Ordinary Ca channel>>=
# Traub tabulated calcium channel
def make_Ca():
  if moose.exists( 'Ca' ):
      return
  Ca = moose.HHChannel( 'Ca' )
  Ca.Ek = ECA
  Ca.Gbar = 40 * SOMA_A
  Ca.Gk = 0
  Ca.Xpower = 2
  Ca.Ypower = 1
  Ca.Zpower = 0

  xgate = moose.element( 'Ca/gateX' )
  <<setup X-gate using Traub model>>

  ygate = moose.element( 'Ca/gateY' )
  <<setup Y-gate using Traub model>>
  <<put information into cell-reader>>
@

\paragraph{Set-up X-gate}

  Use [[setupAlpha]] which is similar to Traub [[setupalpaha]]. We pass a numpy
  array of 13 elements.

<<setup X-gate using Traub model>>=
xA = numpy.array( [ 1.6e3, 0, 1.0, -1.0 * (0.065 + EREST_ACT), -0.01389
        , -20e3 * (0.0511 + EREST_ACT), 20e3, -1.0, -1.0 * (0.0511 + EREST_ACT)
        , 5.0e-3, 3000, -0.1, 0.05 ] )
xgate.setupAlpha( xA )
@ %def xgate 

\paragraph{Set-up Y-gate}

  The $Y$ gate $gCa/r$ is not quite of this form.  For $V > EREST\_ACT$, $alpha =
  5 \exp(-50(V - \text{EREST\_ACT}))$.  Otherwise, $alpha = 5$.  Over the entire
  range, $alpha + beta = 5$.  To create the [[Y_A]] and [[Y_B]] tables, we use some
  of the pieces of the [[setupalpha]] function.

<<setup Y-gate using Traub model>>=
ygate.min = -0.1
ygate.max = 0.05
ygate.divs = 3000
yA = numpy.zeros( (ygate.divs + 1), dtype=float)
yB = numpy.zeros( (ygate.divs + 1), dtype=float)

#Fill the Y_A table with alpha values and the Y_B table with (alpha+beta)
dx = (ygate.max - ygate.min)/ygate.divs
x = ygate.min
for i in range( ygate.divs + 1 ):
  if ( x > EREST_ACT):
    yA[i] = 5.0 * math.exp( -50 * (x - EREST_ACT) )
  else:
    yA[i] = 5.0
  yB[i] = 5.0
  x += dx
ygate.tableA = yA
ygate.tableB = yB
@

\paragraph{Setup cell-reader}

 As we typically use the cell reader to create copies of these prototype
 elements in one or more compartments, we need some way to be sure that the
 needed messages are established.  Although the cell reader has enough
 information to create the messages which link compartments to their channels
 and to other adjacent compartments, it must be provided with the information
 needed to establish additional messages.  This is done by placing the message
 string in a user-defined field of one of the elements which is involved in the
 message.  The cell reader recognizes the added object names "addmsg1",
 "addmsg2", etc. as indicating that they are to be evaluated and used to set up
 messages.  The paths are relative to the element which contains the message
 string in its added field.  Thus, "../Ca\_conc" refers to the sibling element
 [[Ca_conc]] and "." refers to the Ca element itself.

<<put information into cell-reader>>=
# Tell the cell reader that the current from this channel must be fed into
# the Ca_conc pool of calcium.
addmsg1 = moose.Mstring( '/library/Ca/addmsg1' )
addmsg1.value = '.  IkOut  ../Ca_conc  current'

# in some compartments, whe have an NMDA_Ca_conc object to put the current
# into.
addmsg2 = moose.Mstring( '/library/Ca/addmsg2' )
addmsg2.value = '.  IkOut  ../NMDA_Ca_conc  current'
@ %def cell-reader
 
\paragraph{Convert Ca current to Ca concentration}

  Next, we need an element to take the Calcium current calculated by the Ca
  channel and convert it to the Ca concentration.  The [[Ca_concen]] object
  solves the equation $\frac{dC}{dt} = B I_{Ca} - \frac{C}{\tau}$, and sets 
  $Ca=Ca_{base} + C$.  As it is easy to make mistakes in units when using
  this Calcium diffusion equation, the units used here merit some discussion.

\begin{note}{Upi's notes on Traub}

  With $Ca_{base} = 0$, this corresponds to Traub's diffusion equation for
  concentration, except that the sign of the current term here is positive, as
  GENESIS uses the convention that [[I_Ca]] is the current flowing INTO the
  compartment through the channel.  In SI units, the concentration is usually
  expressed in [[moles]]/$m^3$ (which equals [[millimoles/liter]]), and the
  units of B are chosen so that $B = \frac{1}{ion\_charge \times \text{Faraday}
  \times \text{volume}}$. Current is expressed in [[Amperes]] and one
  [[Faraday]] = 96487 [[Coulombs]].  However, in this case, Traub expresses the
  concentration in arbitrary units, current in [[micro-Amps]] and uses $\tau$ =
  13.33 msec.  If we use the same concentration units, but express current in
  amperes and tau in seconds, our B constant is then $10^{12}$ times the constant
  (called "phi") used in the paper.  The actual value used will be typically be
  determined by the cell reader from the cell parameter file.  However, for the
  prototype channel we wlll use Traub's corrected value for the soma.  (An error
  in the paper gives it as 17,402 rather than 17.402.)  In our units, this will
  be 17.402e12.

\end{note}

<<Functions to maniputate property of channels>>=
def make_Ca_conc():
  if moose.exists( 'Ca_conc' ):
    return
  conc = moose.CaConc( 'Ca_conc' )
  conc.tau = 0.013333  # sec
  conc.B  = 17.402e12 # Curr to conc conversion for soma
  conc.Ca_base = 0.0
@ %def make_Ca_conc

This [[Ca_concen]] element should receive a message from any calcium channels with
the current going through the channel. Here we have this specified in the Ca
channel, with the idea that more than one channel might contribute Ca ions to
this calcium pool. In the original GENESIS file this was specified here in
[[make_Ca_conc]].

\paragraph{Tabulated Ca-dependent Potassium AHP Channel}

This is a [[tabchannel]] \footnote{Tabulated channel. Instead of computing the
parameter directly, one used look-up table approach} which gets the calcium
concentration from [[Ca_conc]] in order to calculate the activation of its Z gate.
It is set up much like the Ca channel, except that the A and B tables have
values which are functions of concentration, instead of voltage.

<<Ca-dependent K-AHP channel>>=
def make_K_AHP():
    if moose.exists( 'K_AHP' ):
        return

    K_AHP = moose.HHChannel( 'K_AHP' )
    K_AHP.Ek = EK                      # V
    K_AHP.Gbar = 8 * SOMA_A            # S
    K_AHP.Gk = 0                       # S
    K_AHP.Xpower = 0
    K_AHP.Ypower = 0
    K_AHP.Zpower = 1

    zgate = moose.element( 'K_AHP/gateZ' )
    xmax = 500.0
    zgate.min = 0
    zgate.max = xmax
    zgate.divs = 3000
    zA = numpy.zeros( (zgate.divs + 1), dtype=float)
    zB = numpy.zeros( (zgate.divs + 1), dtype=float)
    dx = (zgate.max - zgate.min)/zgate.divs
    x = zgate.min
    for i in range( zgate.divs + 1 ):
        if (x < (xmax / 2.0 )):
            zA[i] = 0.02*x
        else:
            zA[i] = 10.0
        zB[i] = zA[i] + 1.0
        x = x + dx

    zgate.tableA = zA
    zgate.tableB = zB

    # Use an added field to tell the cell reader to set up a message from the
    # Ca_Conc with concentration info, to the current K_AHP object.
    addmsg1 = moose.Mstring( '/library/K_AHP/addmsg1' )
    addmsg1.value = '../Ca_conc  concOut  . concen'

@ %def make_K_AHP




\paragraph{Ca-dependent Pottasium Channel - K(C) - [[vdep_channel]] with table
and tabgate}

  The expression for the conductance of the potassium C-current channel has a
  typical voltage and time dependent activation gate, where the time dependence
  arises from the solution of a differential equation containing the rate
  parameters alpha and beta.  It is multiplied by a function of calcium
  concentration that is given explicitly rather than being obtained from a
  differential equation.  Therefore, we need a way to multiply the activation by
  a concentration dependent value which is determined from a lookup table.  This
  is accomplished by using the Z gate with the new tabchannel "instant" field,
  introduced in GENESIS 2.2, to implement an "instantaneous" gate for the
  multiplicative Ca-dependent factor in the conductance.

<<Ca-dependent K-C channel>>=
def make_K_C():
  if moose.exists( 'K_C'):
    return

  K_C = moose.HHChannel( 'K_C' )
  K_C.Ek = EK          #  V
  K_C.Gbar = 100.0 * SOMA_A   #  S
  K_C.Gk = 0          #  S
  K_C.Xpower = 1
  K_C.Zpower = 1
  K_C.instant = 4        # Flag: 0x100 means Z gate is instant.

  # Now make a X-table for the voltage-dependent activation parameter.
  xgate = moose.element( 'K_C/gateX' )
  xgate.min = -0.1
  xgate.max = 0.05
  xgate.divs = 3000
  xA = numpy.zeros( (xgate.divs + 1), dtype=float)
  xB = numpy.zeros( (xgate.divs + 1), dtype=float)
  dx = (xgate.max - xgate.min)/xgate.divs
  x = xgate.min
  for i in range( xgate.divs + 1 ):
    alpha = 0.0
    beta = 0.0
    if (x < EREST_ACT + 0.05):
      alpha = math.exp( 53.872 * (x - EREST_ACT) - 0.66835 ) / 0.018975
      beta = 2000* (math.exp ( (EREST_ACT + 0.0065 - x)/0.027)) - alpha
    else:
      alpha = 2000 * math.exp( ( EREST_ACT + 0.0065 - x)/0.027 )
      beta = 0.0
    xA[i] = alpha
    xB[i] = alpha + beta
    x = x + dx
  xgate.tableA = xA
  xgate.tableB = xB

    # Create a table for the function of concentration, allowing a
    # concentration range of 0 to 1000, with 50 divisions.  This is done
    # using the Z gate, which can receive a CONCEN message.  By using
    # the "instant" flag, the A and B tables are evaluated as lookup tables,
    #  rather than being used in a differential equation.
  zgate = moose.element( 'K_C/gateZ' )
  zgate.min = 0.0
  xmax = 500.0
  zgate.max = xmax
  zgate.divs = 3000
  zA = numpy.zeros( (zgate.divs + 1), dtype=float)
  zB = numpy.zeros( (zgate.divs + 1), dtype=float)
  dx = ( zgate.max -  zgate.min)/ zgate.divs
  x = zgate.min
  for i in range( xgate.divs + 1 ):
    if ( x < ( xmax / 4.0 ) ):
      zA[i] = x * 4.0 / xmax
    else:
      zA[i] = 1.0
    zB[i] = 1.0
    x += dx
  zgate.tableA = zA
  zgate.tableB = zB
   
   # Now we need to provide for messages that link to external elements.
   # The message that sends the Ca concentration to the Z gate tables is stored
   # in an added field of the channel, so that it may be found by the cell
   # reader.
  addmsg1 = moose.Mstring( '/library/K_C/addmsg1' )
  addmsg1.value = '../Ca_conc  concOut  . concen'
@

\paragraph{Tabchannel Na Hippocampal cell channel}


<<Tabchannel Na Hippocampal cell channel>>=
def make_Na():
  if moose.exists( 'Na' ):
    return
  Na = moose.HHChannel( 'Na' )
  Na.Ek = ENA        #  V
  Na.Gbar = 300 * SOMA_A  #  S
  Na.Gk = 0        #  S
  Na.Xpower = 2
  Na.Ypower = 1
  Na.Zpower = 0

  xgate = moose.element( 'Na/gateX' )
  xA = numpy.array( [ 320e3 * (0.0131 + EREST_ACT),
    -320e3, -1.0, -1.0 * (0.0131 + EREST_ACT), -0.004, 
    -280e3 * (0.0401 + EREST_ACT), 280e3, -1.0, 
    -1.0 * (0.0401 + EREST_ACT), 5.0e-3, 
    3000, -0.1, 0.05 ] )
  xgate.setupAlpha( xA )

  ygate = moose.element( 'Na/gateY' )
  yA = numpy.array( [ 128.0, 0.0, 0.0, -1.0 * (0.017 + EREST_ACT), 0.018,
    4.0e3, 0.0, 1.0, -1.0 * (0.040 + EREST_ACT), -5.0e-3, 
    3000, -0.1, 0.05 ] )
  ygate.setupAlpha( yA )

@ %def make_Na



\paragraph{Tabchannel K(DR) Hippocampal cell channel}

<<Tabchannel K-DR Hippocampal cell channel>>=
def make_K_DR():
  if moose.exists( 'K_DR' ):
    return
  K_DR = moose.HHChannel( 'K_DR' )
  K_DR.Ek = EK        #  V
  K_DR.Gbar = 150 * SOMA_A  #  S
  K_DR.Gk = 0        #  S
  K_DR.Xpower = 1
  K_DR.Ypower = 0
  K_DR.Zpower = 0

  xgate = moose.element( 'K_DR/gateX' )
  xA = numpy.array( [ 16e3 * (0.0351 + EREST_ACT), 
    -16e3, -1.0, -1.0 * (0.0351 + EREST_ACT), -0.005,
    250, 0.0, 0.0, -1.0 * (0.02 + EREST_ACT), 0.04,
    3000, -0.1, 0.05 ] )
  xgate.setupAlpha( xA )
@


\paragraph{Tabchannel K(A) Hippocampal cell channel}

<<Tabchannel K-A Hippocampal cell channell>>=
def make_K_A():
  if moose.exists( 'K_A' ):
    return
  K_A = moose.HHChannel( 'K_A' )
  K_A.Ek = EK        #  V
  K_A.Gbar = 50 * SOMA_A  #  S
  K_A.Gk = 0        #  S
  K_A.Xpower = 1
  K_A.Ypower = 1
  K_A.Zpower = 0

  xgate = moose.element( 'K_A/gateX' )
  xA = numpy.array( [ 20e3 * (0.0131 + EREST_ACT), 
    -20e3, -1.0, -1.0 * (0.0131 + EREST_ACT), -0.01,
    -17.5e3 * (0.0401 + EREST_ACT), 
    17.5e3, -1.0, -1.0 * (0.0401 + EREST_ACT), 0.01,
    3000, -0.1, 0.05 ] )
  xgate.setupAlpha( xA )

  ygate = moose.element( 'K_A/gateY' )
  yA = numpy.array( [ 1.6, 0.0, 0.0, 0.013 - EREST_ACT, 0.018,
    50.0, 0.0, 1.0, -1.0 * (0.0101 + EREST_ACT), -0.005,
    3000, -0.1, 0.05 ] )
  ygate.setupAlpha( yA )
@ %def make_K_A

\paragraph{SynChan: Glu receptor}

<<Glu receptor>>=
def make_glu():
  if moose.exists( 'glu' ):
    return
  glu = moose.SynChan( 'glu' )
  glu.Ek = 0.0
  glu.tau1 = 2.0e-3
  glu.tau2 = 9.0e-3
  glu.Gbar = 40 * SOMA_A
@ %def make_glu 


\paragraph{SynChan: NMDA receptor}

<<NMDA receptor>>=
def make_NMDA():
  if moose.exists( 'NMDA' ):
    return
  NMDA = moose.SynChan( 'NMDA' )
  NMDA.Ek = 0.0
  NMDA.tau1 = 20.0e-3
  NMDA.tau2 = 20.0e-3
  NMDA.Gbar = 5 * SOMA_A

  block = moose.MgBlock( '/library/NMDA/block' )
  block.CMg = 1.2    #  [Mg] in mM
  block.Zk = 2
  block.KMg_A = 1.0/0.28
  block.KMg_B = 1.0/62

  moose.connect( NMDA, 'channelOut', block, 'origChannel', 'OneToOne' )
  addmsg1 = moose.Mstring( '/library/NMDA/addmsg1' )
  addmsg1.value = '.. channel  ./block  channel'
  #Here we want to also tell the cell reader to _remove_ the original
  #Gk, Ek term going from the channel to the compartment, as this is
  # now handled by the MgBlock.
  #addmsg2 = moose.Mstring( 'NMDA/addmsg2'
  #addmsg2.value = 'DropMsg  ..  channel'
  addmsg3 = moose.Mstring( '/library/NMDA/addmsg3' )
  addmsg3.value = '.. VmOut  .  Vm'

@ %def make_NMDA

 The [[Ca_NMDA]] channel is a subset of the NMDA channel that carries Ca.  It is
 identical to above, except that the Ek for Ca is much higher: 0.08 V from the
 consts at the top of this file.  This is about the reversal potl for 1 uM
 [[Ca_in]], 2 mM out.  Also we do not want this channel to contribute to the
 current, which is already accounted for in the main channel. So there is no
 CHANNEL message to the parent compartment.  I would like to have used the
 Nernst to do the Ca potential, and Synchans now take Ek messages but I haven't
 yet used this.

<<NMDA receptor>>=
def make_Ca_NMDA():
  if moose.exists( 'Ca_NMDA' ):
    return
  Ca_NMDA = moose.SynChan( 'Ca_NMDA' )
  Ca_NMDA.Ek = ECA
  Ca_NMDA.tau1 = 20.0e-3
  Ca_NMDA.tau2 = 20.0e-3
  Ca_NMDA.Gbar = 5 * SOMA_A

  block = moose.MgBlock( '/library/Ca_NMDA/block' )
  block.CMg = 1.2    #  [Mg] in mM
  block.Zk = 2
  block.KMg_A = 1.0/0.28
  block.KMg_B = 1.0/62

  moose.connect( Ca_NMDA, 'channelOut', block, 'origChannel', 'OneToOne' )
  addmsg1 = moose.Mstring( '/library/Ca_NMDA/addmsg1' )
  addmsg1.value = '.. VmOut  ./block  Vm'
  addmsg2 = moose.Mstring( '/library/Ca_NMDA/addmsg2' )
  addmsg2.value = './block  IkOut ../NMDA_Ca_conc current'
  # The original model has the Ca current also coming here.

@ %def make_Ca_NMDA 

\paragraph{Ca pool for influx through [[Ca_NMDA]]}

 This pool used to set up Ca info coming to it. Now we insist that the
 originating channel should specify the deferred message.

<<Functions to maniputate property of channels>>=
def make_NMDA_Ca_conc():
  if moose.exists( 'NMDA_Ca_conc' ):
    return
  NMDA_Ca_conc = moose.CaConc( 'NMDA_Ca_conc' )
  NMDA_Ca_conc.tau = 0.004     # sec. Faster in spine than dend
  NMDA_Ca_conc.B = 17.402e12  # overridden by cellreader.
  NMDA_Ca_conc.Ca_base = 0.0

@ %def make_NMDA_Ca_conc 

\paragraph{Spike Detector}

<<Spike detector>>=
def make_axon():
  if moose.exists( 'axon' ):
    return
  axon = moose.SpikeGen( 'axon' )
  axon.threshold = -40e-3         # V
  axon.abs_refract = 10e-3        # sec
    
@ %def make_axon



\subsection{Database to keep the XML models}
\label{subsec:database}

  We use sqlite3 database. Let import it and add a section in our class to
  handle this database.

<<Local imports>>=
import sqlite3 as sql 
@ 

<<methods in class [[Multiscale]]>>=
<<methods to deal with database>>
@

  And lets open a database and initialize it. And add code to clean up the
  connection before exiting the class.

<<initialize members>>=
self.dbdir = 'db'
self.dbname = 'models.db'
self.dbpath = os.path.join(self.dbdir, self.dbname)
if not os.path.exists(self.dbpath) :
  try :
    os.makedirs(self.dbdir)
  except Exception as e :
    debug.printDebug("ERROR"
        , "Faild to create directory {0} with error {1}".format(self.dbdir, e))
    sys.exit(0)
self.conn = sql.connect(self.dbpath)
self.cursor = self.conn.cursor()
@ %def database 

<<clean up the mess>>=
self.cursor.commit()
self.conn.close()
sys.exit()
@ %def exit

\subsection{Populate database}

    We have the parsed models and we would be searching them extensively when
    combining them together to map onto moose. Populate the sqlite3 database
    such that we can query it easily.

<<flow of executation>>=
<<populate database with models>>
<<build queries from adaptorML>>
<<run queries and generate moose scripts>>
@ %def flow

\paragraph{Populating database}

    Should be directly translated XML to [[sqlite3]]? No, that would defeat the
    purpose of using sqlite3 in the middle. We must transform the XML as much as
    we can to create a well-defined database which we can simply query and build
    moose scripts. Let's me describe the flow. 
\begin{figure}[h]
\centering
\begin{tikzpicture}
    [every node/.style = {minimum size = 1.5cm}, font=\small]
    
    %\input{macro.tex};
    %\myscript{(0,1)}{3}{4}{hello};

    \node[draw, rectangle] (model1) at (0,0) {\texttt{model1.xml}};
    \node[draw, rectangle] (model2) at (0,2) {\texttt{model2.xml}};
    \node[draw, rectangle] (model3) at (0,4) {\texttt{model3.xml}};
    \node[draw, circle] (db) at (4,2) {\texttt{sqlite3}};
    \node[draw, rectangle] (gen) at (8,2)  {\texttt{moose generator}};
    \node[draw, rectangle] (adaptorML) at (8,4) {adaptorML};
    \node[rectangle] (moose) at (8,0) {moose.py};
    \draw[->] (model1) -- node [below, midway] {$f1$} (db);
    \draw[->] (model2) -- node [label={[xshift=0cm,yshift=-0.5cm]$f2$}] {} (db);
    \draw[->] (model3) -- node [above, midway] {$f3$} (db) -- (gen);
    \draw[->] (adaptorML) -- (gen) -- (moose);

\end{tikzpicture}
\label{fig:multiscale_flow}
\caption{Flow of multi-scale modelling}
\end{figure}


  
\section{AdaptorML for Moose}
\label{sec:adaptor}
  
  This adaptor example was writeen by an intern during GSoC. 

 \todo{Write adaptorML}.

%file:moose_xml/adaptor.xml
<<adaptor.xml>>=
<?xml version="1.0"?>
  <adapterML>
    <listOfAdaptors>
    <adaptor name="adaptK" id="/n/chem/neuroMesh/adaptK" scale="0.05">
      <inElement name="chemK" id="/n/chem/neuroMesh/kChan" field="get_conc" 
            adapt_type="requestField" mode="OneToAll"/>
      <outElement name="elecK" id="/n/elec/compt/K" field="set_Gbar" 
            adapt_type="outputSrc" mode="OneToAll"/>
    </adaptor>
    <adaptor name="adaptCa" id="/n/chem/neuroMesh/adaptCa" outputOffset="0.0001" scale="0.05">
      <inElement name="elecCa" id="/n/elec/compt/ca" field="concOut" 
            adapt_type="input" mode="OneToAll"/>
      <outElement name="chemCa" id="/n/chem/neuroMesh/Ca" field="set_conc" 
            adapt_type="outputSrc" mode="OneToAll"/>
    </adaptor>
  </listOfAdaptors>
</adapterML>
@ %def adaptorML
\section{XML parser}
\label{sec:parser}

  This section deals with parser of XML models. In [[multiscale.nw]], we call
  function [[parseModels]] belonging to this module. This function receives its
  arguments, a dictionary of paths of XML models. These file-paths are already
  verified; they exists and are readable. We now parse the XMLs and return a
  dictionary, with keys as path of XML models and value as top-most XML element.

  Following captures what this module suppose to do.

%file:src/parser.py
<<parser.py>>=
<<Import>>
<<helper functions>>
<<function [[parseModels]] for parsing models>>
@

\paragraph{Parse models}

  Function [[parseModels]] parses the model, and it creates a dictionary to be
  returned. This function first read the file and validate it with a given
  schema. Validation can be turned on/off by setting the optional argument
  [[validate]] to [[False]].

<<function [[parseModels]] for parsing models>>=
def parseModels(commandLineArgs, validate=False) :
  xmlRootElemDict = dict()
  models = vars(commandLineArgs)
  for model in models :
    if models[model] :
      modelPath = models[model]
      debug.printDebug("INFO", "Parsing {0}".format(models[model]))
      if validate :
        # parse model and valid it with schama
        modelXMLRootElem = parseAndValidateWithSchema(model, modelPath)
      else :
        # Simple parse the model without validating it with schema.
        modelXMLRootElem = parseWithoutValidation(model, modelPath)
      xmlRootElemDict[model] = modelXMLRootElem 
  return xmlRootElemDict 

@  %def parseModels 

\paragraph{Validating with schema}

  We need two helper functions, [[parseAndValidateWithSchema]] to parse a given
  XML when a schema is available and [[parseWithoutValidation]] validation is
  off \textbf{schema is not available}. Ideally, schema should be provided as an
  argument to this module, but we can fix their location. Folder [[./moose_xml]]
  contains the schema we are going to build and use in this application. Its
  path is [[./moose_xml/moose.xsd]].

 \todo[size=\small]{Write moose.xsd schema in ./moose\_xml/moose.xsd path.}

<<helper functions>>=
def parseAndValidateWithSchema(modelName, modelPath) :
    
    prefixPath = ''
    if modelName == 'xml' :
      schemaPath = os.path.join(prefixPath, 'moose_xml/moose.xsd')

    try :
      schemaH = open(schemaPath, "r")
      schemaText = schemaH.read()
      schemaH.close()
    except Exception as e :
      debug.printDebug("WARN", "Error reading schema for validation."+
        " Falling back to validation-disabled parser."
        + " Failed with error {0}".format(e))
      return parseWithoutValidation(modelName, modelPath)
    # Now we have the schema text 
    schema = etree.XMLSchema(etree.XML(schemaText))
    xmlParser = etree.XMLParser(schema=schema)
    with open(modelPath, "r") as xmlTextFile :
        return etree.parse(xmlTextFile, xmlParser)

@ %def parseAndValidateWithSchema 

<<helper functions>>=
def parseWithoutValidation(modelName, modelPath) :
    try :
      xmlRootElem = etree.parse(modelPath)
    except Exception as e :
      debug.printDebug("ERROR", "Parsing failed. {0}".format(e))
      return 
    return xmlRootElem 

@ %def parseWithoutValidation 

This ends our parser module and we can now go back to section
\ref{sec:multiscale} to do some real programming related stuff.

\section{Debug module, print debugging messages}
\label{sec:debug}

  Different type of messages are printed in different colors. 

%file:src/debug.py
<<debug.py>>=
HEADER = '\033[95m'
OKBLUE = '\033[94m'
OKGREEN = '\033[92m'
WARNING = '\033[93m'
ERR = '\033[91m'
ENDC = '\033[0m'
RED = ERR
WARN = WARNING
INFO = OKGREEN 
TODO = OKBLUE
DEBUG = HEADER

prefix = dict(
    ERR = ERR
    , WARN = WARN
    , FATAL = ERR
    , INFO = INFO
    , TODO = TODO 
    , NOTE = HEADER 
    , DEBUG = DEBUG
    )

def colored(msg, label) :
    """
    Return a colored string. Formatting is optional.
    """
    global prefix
    if label in prefix :
        color = prefix[label]
    else :
        color = ""
    return "[{0}] {1} {2}".format(label, color+msg, ENDC)

def printDebug(label, msg):
    print(colored(msg, label))

@ %def debug_module 

\nowebchunks
\nowebindex
\listoftodos
\end{document}          
