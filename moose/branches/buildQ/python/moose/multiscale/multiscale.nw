\section{Construct a Database/AST from XML models}
\label{sec:multiscale}
  
  This is our defining module and it contains the basic functionality of this
  application. All XML modules are parsed into a dictionary and this dictionary
  is passed to the object of class [[Multiscale]] which is the main class in
  this module. We also have [[adaptorML]] file parsed in dictionary. 

\begin{remark}{Why AST/Database?}
    
  In one previous version, [[sqlite3]] database was used to integrate all XML
  models. We no longer use [[sqlite3]] database but rather integrate all XML
  files into one XML file.

\end{remark}
 
\paragraph{Structure} Structure of this module is following. 

%file:src/multiscale.py
<<multiscale>>=
<<Import>>
<<Local imports>>
<<Definition of class [[Multiscale]]>>

@ %def multiscale 

   

\paragraph{A skeleton of class}

    This class will build a combined model which we can map on to [[moose]]
    later by using [[mumbl]]. 
  
<<Definition of class [[Multiscale]]>>=
from lxml.builder import E
import nml_parser
import cStringIO
import sys
sys.path.append("../../../python")
import moose

class Multiscale :
  
  def __init__(self, xmlDict) :
    self.xmlDict = xmlDict 
    self.xmlExpr = "//*[local-name() = $name]"
    self.rootModelPath = '/model'
    self.model = moose.Neutral(self.rootModelPath)
    <<initialize members>>
    debug.printDebug("INFO", "Object of class Multiscale intialized ...")

  <<methods>> 

  # This is the entry point of this class.
  def buildMultiscaleModel(self) :
      debug.printDebug("INFO", "Starting to build multiscale model")   
      <<flow of executation>>
  
  def exit(self) :
    # Clean up before you leave
    debug.printDebug("WARN", "Cleaning up before existing..")
    <<clean up the mess>>
    sys.exit(0)

  # Write down the tests, whenever needed.
  <<tests>>



@ %def [[Multiscale]]

Before we move on, lets discuss some models developed by others we need to
import into moose.

%\include{proto.nw}

\paragraph{Multi-scale Modelling in Biological Language (MuMBL)}

   The [[neuroML]] is our starting point. Get the [[adaptorML]] and map things
   onto moose. If more models appears then map them onto moose also and add
   support to do so in [[adaptorML]]. Not everything can be mapped and user
   inputs are also required to do modelling, this we do using a XML based
   language [[MuMBL]]. The user must supply at least three XML files, neuroml
   model, adaprorML and mumbl files. Both adaptor and mumbl are explained in
   appendix.

   \todo[inline]{We have already parsed all of our xml files. We are using
   [[generateDS.py]] to generate python class from the XSD. Remove all etree
   based parsing later.}

<<flow of executation>>=
<<map onto moose>>
<<setup simulation using mumbl>>
<<simulate>>
@ %def flow_of_execution

\paragraph{Mapping onto moose}

  Lets map XML models onto moose.

<<map onto moose>>=
# NeuroML to moose
self.neuroML2Moose()
@

\paragraph{NeuroML to moose}

  We need capabilities to map an ion-channel to moose.

<<methods>>=            
def mapIonChannel(self, ionChannelXml) :
  debug.printDebug("INFO"
    , "Mapping ion-channel {0} onto moose".format(ionChannelXml.tag))
  type = ionChannelXml.get('type')
  id = ionChannelXml.get('id')

def mapIncludedFile(self, filePath) :
  debug.printDebug("INFO", "Mapping included file {0}".format(filePath))
  incXml = etree.parse(filePath)
  for ionChannel in incXml.xpath(self.xmlExpr, name="ionChannel") :
    self.mapIonChannel(ionChannel)

def neuroML2Moose(self) :
  debug.printDebug("INFO", "Mapping neuroML to moose")
  nmlElems = self.xmlDict['nml']
  if len(nmlElems) > 1 :
    debug.printDebug("ERR", "More than one nueroml file is not supported yet.")
    self.exit()
  else : 
    nmlElem, nmlPath = nmlElems[0]
  self.nml = nml_parser.parse(nmlPath, silence=True)
  <<map morphology>>
  <<map ionchannels>>
@ %def neuroML2Moose

<<map morphology>>=
for cell in self.nml.cell :
  morphology = cell.morphology 
  compartmentDict = dict()
  for segment in morphology.segment :
    if not segment.parent :
      compartmentPath = os.path.join(self.rootModelPath, segment.name)
      comp = moose.Compartment(compartmentPath)
      compartmentDict[segment.id] = comp
    else  :
      parentPath = compartmentDict[segment.parent.segment].path
      comp = moose.Compartment(os.path.join(parentPath, segment.name))
      compartmentDict[segment.id] = comp
    proximalDiameter = 0.0
    distalDiameter = 0.0
    if segment.proximal :
      comp.x0 = segment.proximal.x
      comp.y0 = segment.proximal.y
      comp.z0 = segment.proximal.z 
      proximalDiameter = segment.proximal.diameter
    if segment.distal :
      comp.x = segment.distal.x
      comp.y = segment.distal.y
      comp.z = segment.distal.z 
      distalDiameter = segment.distal.diameter 
    
    if proximalDiameter > 0.0 and distalDiameter > 0.0 :
      comp.diameter = (proximalDiameter + distalDiameter) / 2
    elif proximalDiameter > 0.0 :
      comp.distalDiameter = proximalDiameter 
    else : 
      comp.diameter = distalDiameter 
    # check if this comparment has a parent 
   
@ %def map_morphology

<<map ionchannels>>=
expr = self.xmlExpr
modelDir = os.path.dirname(nmlPath)
for i in  nmlElem.xpath(expr, name="include") :
  incFile = os.path.join(modelDir, i.get('href'))
  if os.path.isfile(incFile) :
    self.mapIncludedFile(incFile)
  else :
    debug.printDebug("WARN", "Included file {0} does not exists".format(incFile))

@ %def map_ionchannels
