\section{Construct a Database/AST from XML models}
\label{sec:multiscale}
  
\todo[inline]{Write some Design Rule Check (SRC) when building moose}

  This is our defining module and it contains the basic functionality of this
  application. All XML modules are parsed into a dictionary and this dictionary
  is passed to the object of class [[Multiscale]] which is the main class in
  this module. We also have [[adaptorML]] file parsed in dictionary. 

\begin{remark}{Why AST/Database?}

    AST is maintained now in [[networkX]] graph. We are attaching XML-elements
    to the nodes of the graph.

\end{remark}
 
\paragraph{Structure} Structure of this module is following. 

%file:src/multiscale.py
<<multiscale>>=
<<Import>>
<<Local imports>>
<<Definition of class [[Multiscale]]>>

@ %def multiscale 

   

\paragraph{A skeleton of class}

    This class will build a combined model which we can map on to [[moose]]
    later by using [[mumbl]]. We build a graph object before we build a
    [[moose]] objects.
  
<<Local imports>>=
from lxml.builder import E
import networkx as nx
import nml_parser
import cStringIO
import sys
import unittest as ut
sys.path.append("../../../python")
import moose
@

<<Definition of class [[Multiscale]]>>=
class Multiscale :
  
  def __init__(self, xmlDict) :
    self.xmlDict = xmlDict 
    # This expression is useful for getting an element which is not sensitive to
    # name-space.
    self.xmlExpr = "//*[local-name() = $name]"
    self.rootModelPath = '/model'


    <<initialize members>>
    debug.printDebug("INFO", "Object of class Multiscale intialized ...")

  <<methods>> 

  # This is the entry point of this class.
  def buildMultiscaleModel(self) :
      debug.printDebug("INFO", "Starting to build multiscale model")   
      <<flow of executation>>
  
  def exit(self) :
    # Clean up before you leave
    debug.printDebug("WARN", "Cleaning up before existing..")
    <<clean up the mess>>
    sys.exit(0)

  # Write down the tests, whenever needed.
  <<tests>>

@ %def [[Multiscale]]

\paragraph{Initialize the main data-structures}

    A graph to hold the network and properties and a moose-object. 

<<initialize members>>=
# Initialize some attributes also.
self.mooseG = nx.MultiDiGraph(gProp={'segmentGroup' : set()})
self.model = moose.Neutral(self.rootModelPath)
@ %def initialization

\paragraph{Multi-scale Modelling in Biological-system, Language (MuMBL)}

   The [[neuroML]] is our starting point; parse this model and build a graph.
   Other XML models are merged into this one. Get the [[adaptorML]] and map this
   graph onto moose. If more models appears then map them onto moose also and
   add support to do so in [[adaptorML]]. Not everything can be mapped and user
   inputs are also required to do modelling, this we do using a XML based
   language [[MuMBL]]. The user must supply at least three XML files, neuroml
   model, adaprorML and mumbl files. Both adaptor and mumbl are explained in
   appendix.

<<flow of executation>>=
<<build network graph>>
<<map onto moose>>
<<setup simulation using mumbl>>
<<simulate>>
@ %def flow_of_execution

\paragraph{Mapping onto moose}

  Lets map XML models onto moose.

<<build network graph>>=
# NeuroML to moose
<<neuroml to network>>
<<sbml to network>>
<<otherml to network>>
@

%\include{neuroml2network.nw}
