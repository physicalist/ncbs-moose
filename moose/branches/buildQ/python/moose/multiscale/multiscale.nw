\section{Construct a Database/AST from XML models}
\label{sec:multiscale}
  
\todo[inline]{Write some Design Rule Check (SRC) when building moose}

  This is our defining module and it contains the basic functionality of this
  application. All XML modules are parsed into a dictionary and this dictionary
  is passed to the object of class [[Multiscale]] which is the main class in
  this module. We also have [[adaptorML]] file parsed in dictionary. 

\begin{remark}{Why AST/Database?}
    
  In one previous version, [[sqlite3]] database was used to integrate all XML
  models. We no longer use [[sqlite3]] database but rather integrate all XML
  files into one XML file.

\end{remark}
 
\paragraph{Structure} Structure of this module is following. 

%file:src/multiscale.py
<<multiscale>>=
<<Import>>
<<Local imports>>
<<Definition of class [[Multiscale]]>>

@ %def multiscale 

   

\paragraph{A skeleton of class}

    This class will build a combined model which we can map on to [[moose]]
    later by using [[mumbl]]. We build a graph object before we build a
    [[moose]] objects.
  
<<Local imports>>=
from lxml.builder import E
import networkx as nx
import nml_parser
import cStringIO
import sys
sys.path.append("../../../python")
import moose
@

<<Definition of class [[Multiscale]]>>=
class Multiscale :
  
  def __init__(self, xmlDict) :
    self.xmlDict = xmlDict 
    self.xmlExpr = "//*[local-name() = $name]"
    self.rootModelPath = '/model'
    # To hold the topology of the network 
    self.mooseG = nx.MultiDiGraph()
    self.model = moose.Neutral(self.rootModelPath)
    <<initialize members>>
    debug.printDebug("INFO", "Object of class Multiscale intialized ...")

  <<methods>> 

  # This is the entry point of this class.
  def buildMultiscaleModel(self) :
      debug.printDebug("INFO", "Starting to build multiscale model")   
      <<flow of executation>>
  
  def exit(self) :
    # Clean up before you leave
    debug.printDebug("WARN", "Cleaning up before existing..")
    <<clean up the mess>>
    sys.exit(0)

  # Write down the tests, whenever needed.
  <<tests>>



@ %def [[Multiscale]]

Before we move on, lets discuss some models developed by others we need to
import into moose.

%\include{proto.nw}

\paragraph{Multi-scale Modelling in Biological Language (MuMBL)}

   The [[neuroML]] is our starting point. All other XML models are merged into
   this one. Get the [[adaptorML]] and map this model onto moose. If more models
   appears then map them onto moose also and add support to do so in
   [[adaptorML]]. Not everything can be mapped and user inputs are also required
   to do modelling, this we do using a XML based language [[MuMBL]]. The user
   must supply at least three XML files, neuroml model, adaprorML and mumbl
   files. Both adaptor and mumbl are explained in appendix.

   \todo[inline]{We have already parsed all of our xml files. We are using
   [[generateDS.py]] to generate python class from the XSD. Remove all etree
   based parsing later.}

<<flow of executation>>=
<<build network graph>>
<<map onto moose>>
<<setup simulation using mumbl>>
<<simulate>>
@ %def flow_of_execution

\paragraph{Mapping onto moose}

  Lets map XML models onto moose.

<<build network graph>>=
# NeuroML to moose
<<neuroml to network>>
<<sbml to network>>
<<otherml to network>>
@

%\include{neuroml2network.nw}
