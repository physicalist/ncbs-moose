\section{XML parser}
\label{sec:parser}

  This section deals with parser of XML models. In [[multiscale.nw]], we call
  function [[parseModels]] of this modudle. This function receives argument from
  the command line, having paths of XML models. These paths of model files are
  valid and readable, this has been verified before sending arguments to this
  function. We need to parse the XMLs and return a dictionary, with keys as path
  of XML models and value as top-most XML element.

  Following captures what this module suppose to do.

%file:src/parser.py
<<parser.py>>=
<<Import>>
<<helper functions>>
<<function [[parseModels]] for parsing models>>
@

\paragraph{Parse models}

  Function [[parseModels]] parses the model, and it creates a dictionary to be
  returned. This function first read the file and validate it with a given
  schema. Validation can be turned on/off by setting the optional argument
  [[validate]] to [[False]].

<<function [[parseModels]] for parsing models>>=
def parseModels(commandLineArgs, validate=False) :
    '''
    Parse given models.
   
    '''
    xmlRootElemDict = dict()

    models = vars(commandLineArgs)
    for model in models :
      if models[model] :
        modelPath = models[model]
        debug.printDebug("INFO", "Parsing {0}".format(models[model]))
        if validate :
          # parse model and valid it with schama
          modelXMLRootElem = parseAndValidateWithSchema(model, modelPath)
        else :
          # Simple parse the model without validating it with schema.
          modelXMLRootElem = parseWithoutValidation(model, modelPath)
        xmlRootElemDict[model] = modelXMLRootElem 
    return xmlRootElemDict 

@  %def parseModels 

\paragraph{Validating with schema}

  We need two helper functions, [[parseAndValidateWithSchema]] to parse a given
  XML when a schema is available and [[parseWithoutValidation]] validation is
  off \textbf{schema is not available}. Ideally, schema should be provided as an
  argument to this module, but we can fix their location. Folder [[./moose_xml]]
  contains the schema we are going to build and use in this application. Its
  path is [[./moose_xml/moose.xsd]].

 \todo[size=\small]{Write moose.xsd schema in ./moose\_xml/moose.xsd path.}

<<helper functions>>=
def parseAndValidateWithSchema(modelName, modelPath) :
    
    prefixPath = ''
    if modelName == 'xml' :
      schemaPath = os.path.join(prefixPath, 'moose_xml/moose.xsd')

    try :
      schemaH = open(schemaPath, "r")
      schemaText = schemaH.read()
      schemaH.close()
    except Exception as e :
      debug.printDebug("WARN", "Error reading schema for validation."+
        " Falling back to validation-disabled parser."
        + " Failed with error {0}".format(e))
      return parseWithoutValidation(modelName, modelPath)
    # Now we have the schema text 
    schema = etree.XMLSchema(etree.XML(schemaText))
    xmlParser = etree.XMLParser(schema=schema)
    with open(modelPath, "r") as xmlTextFile :
        return etree.parse(xmlTextFile, xmlParser)

@ %def parseAndValidateWithSchema 

<<helper functions>>=
def parseWithoutValidation(modelName, modelPath) :
    try :
      xmlRootElem = etree.parse(modelPath)
    except Exception as e :
      debug.printDebug("ERROR", "Parsing failed. {0}".format(e))
      return 
    return xmlRootElem 

@ %def parseWithoutValidation 





