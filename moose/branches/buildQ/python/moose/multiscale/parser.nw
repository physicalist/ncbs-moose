\section{XML parser}
\label{sec:parser}

  This section deals with parser of XML models. In [[multiscale.nw]], we call
  function [[parseModels]] belonging to this module. This function receives its
  arguments, a dictionary of paths of XML models. These file-paths are already
  verified; they exists and are readable. We now parse the XMLs and return a
  dictionary, with keys as path of XML models and value as top-most XML element.

  Following captures what this module suppose to do.

%file:src/parser.py
<<parser.py>>=
<<Import>>
<<helper functions>>
<<function [[parseModels]] for parsing models>>
@

\paragraph{Parse models}

  Function [[parseModels]] parses the model, and it creates a dictionary to be
  returned. This function first read the file and validate it with a given
  schema. Validation can be turned on/off by setting the optional argument
  [[validate]] to [[False]].

<<function [[parseModels]] for parsing models>>=
def parseModels(commandLineArgs, validate=False) :
  xmlRootElemDict = dict()
  models = vars(commandLineArgs)
  for model in models :
    if models[model] :
      modelPath = models[model]
      debug.printDebug("INFO", "Parsing {0}".format(models[model]))
      if validate :
        # parse model and valid it with schama
        modelXMLRootElem = parseAndValidateWithSchema(model, modelPath)
      else :
        # Simple parse the model without validating it with schema.
        modelXMLRootElem = parseWithoutValidation(model, modelPath)
      xmlRootElemDict[model] = modelXMLRootElem 
  return xmlRootElemDict 

@  %def parseModels 

\paragraph{Validating with schema}

  We need two helper functions, [[parseAndValidateWithSchema]] to parse a given
  XML when a schema is available and [[parseWithoutValidation]] validation is
  off \textbf{schema is not available}. Ideally, schema should be provided as an
  argument to this module, but we can fix their location. Folder [[./moose_xml]]
  contains the schema we are going to build and use in this application. Its
  path is [[./moose_xml/moose.xsd]].

 \todo[size=\small]{Write moose.xsd schema in ./moose\_xml/moose.xsd path.}

<<helper functions>>=
def parseAndValidateWithSchema(modelName, modelPath) :
    
    prefixPath = ''
    if modelName == 'xml' :
      schemaPath = os.path.join(prefixPath, 'moose_xml/moose.xsd')

    try :
      schemaH = open(schemaPath, "r")
      schemaText = schemaH.read()
      schemaH.close()
    except Exception as e :
      debug.printDebug("WARN", "Error reading schema for validation."+
        " Falling back to validation-disabled parser."
        + " Failed with error {0}".format(e))
      return parseWithoutValidation(modelName, modelPath)
    # Now we have the schema text 
    schema = etree.XMLSchema(etree.XML(schemaText))
    xmlParser = etree.XMLParser(schema=schema)
    with open(modelPath, "r") as xmlTextFile :
        return etree.parse(xmlTextFile, xmlParser)

@ %def parseAndValidateWithSchema 

<<helper functions>>=
def parseWithoutValidation(modelName, modelPath) :
    try :
      xmlRootElem = etree.parse(modelPath)
    except Exception as e :
      debug.printDebug("ERROR", "Parsing failed. {0}".format(e))
      return 
    return xmlRootElem 

@ %def parseWithoutValidation 

This ends our parser module and we can now go back to section
\ref{sec:multiscale} to do some real programming related stuff.

