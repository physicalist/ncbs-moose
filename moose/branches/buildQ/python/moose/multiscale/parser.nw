\section{XML parser}
\label{sec:parser}

  This section deals with parser of XML models. In [[multiscale.nw]], we call
  function [[parseModels]] of this modudle. This function receives argument from
  the command line, having paths of XML models. These paths of model files are
  valid and readable, this has been verified before sending arguments to this
  function. We need to parse the XMLs and return a dictionary, with keys as path
  of XML models and value as top-most XML element.

  Following captures what this module suppose to do.

%file:src/parser.py
<<parser.py>>=
<<Import>>
<<helper functions>>
<<function [[parseModels]] for parsing models>>
@

\paragraph{Parse models}

  Function [[parseModels]] parses the model, and it creates a dictionary to be
  returned. This function first read the file and validate it with a given
  schema. Validation can be turned on/off by setting the optional argument
  [[validate]] to [[False]].

<<function [[parseModels]] for parsing models>>=
def parseModels(commandLineArgs, validate=False) :
    '''
    Parse given models.
   
    '''
    xmlRootElemDict = dict()

    models = vars(commandLineArgs)
    for model in models :
      if models[model] :
        modelPath = models[model]
        debug.printDebug("INFO", "Parsing {0}".format(models[model]))
        if validate :
          # parse model and valid it with schama
          modelXMLRootElem = parseAndValidateWithSchema(model, modelPath)
        else :
          # Simple parse the model without validating it with schema.
          modelXMLRootElem = parseWithoutValidation(model, modelPath)
        xmlRootElemDict[model] = modelXMLRootElem 
    return xmlRootElemDict 

@  %def parseModels 

\paragraph{Validating with schema}

  We need two helper functions, [[parseAndValidateWithSchema]] to parse a given
  XML when a schema is available and [[parseWithoutValidation]] validation is
  off \textbf{schema is not available}. Ideally, schema should be provided as an
  argument to this module, but we can fix their location. Folder [[./moose_xml]]
  must contains all the schemas we need to validate. Currently
  [[./moose_xml/NeuroML_v2beta1.xsd]] and [[./moose_xml/sbml.xsd]] are schemas
  available for [[nml]] and [[sbml]] models.

%  What should be the relative path of these schemas; the source code generated
%  is always in one level below than the directory of this literate file e.g.
%  generated python file resides in \texttt{./src} directory while this file is
%  in \texttt{.} directory. Therefore, paths of these schemas are different in
%  the implementation of following functions than they are in this literate file.
%

<<helper functions>>=
def parseAndValidateWithSchema(modelName, modelPath) :
    
    prefixPath = ''
    if modelName == 'nml' :
      schemaPath = os.path.join(prefixPath, 'moose_xml/NeuroML_v2beta1.xsd')
    elif modelName == 'sbml' :
      schemaPath = os.path.join(prefixPath, 'moose_xml/sbml.xsd')

    try :
      schemaH = open(schemaPath, "r")
      schemaText = schemaH.read()
      schemaH.close()
    except Exception as e :
      debug.printDebug("WARN", "Error reading schema for validation."+
        " Falling back to validation-disabled parser."
        + " Failed with error {0}".format(e))
      return parseWithoutValidation(modelName, modelPath)
    # Now we have the schema text 
    schema = etree.XMLSchema(etree.XML(schemaText))
    xmlParser = etree.XMLParser(schema=schema)
    with open(modelPath, "r") as xmlTextFile :
        return etree.parse(xmlTextFile, xmlParser)

@ %def parseAndValidateWithSchema 

<<helper functions>>=
def parseWithoutValidation(modelName, modelPath) :
    try :
      xmlRootElem = etree.parse(modelPath)
    except e :
      debug.printDebug("ERROR", "Failed to parse model with error {0}".format(e))
      return 
    return xmlRootElem 

@ %def parseWithoutValidation 





