\subsection{Map neuroML to network}
    
  Topology of the network is encoded in a networkx graph [[mooseG]] and we are
  attaching XML element to its node.  Merge all XML models into this graph,
  later use adaptorML to transform this graph to moose scripts. 
  
\paragraph{Network graph}
\label{mooseG}
  
  This is a netoworkx library [[MultiDiGraph]] graph. Adding parallel edges and
  self loops are allowed in this graph. And we can attach any hash-able data to
  nodes and edges. Graph is one data-structure build to rule them all. No other
  data-structure is maintained in this application for global reading and
  writing. All information is attached to nodes, edges or graphs. We explain
  them when we encounter them.

  The basic idea is to create one node for each compartment and cluster them
  according to the cell they are part of. Each node has a property called
  [[segmentGroup]]. When we are dumping the graph into a graphviz file using
  methods [[write_dot]] written in [[src/helper/graph_methods.py]] file, we are
  coloring nodes according to their segment group. 
  
  An outgoing edge $a \rightarrow b$ says that there is relation between $b$ and
  $a$ and edge describe that relation e.g. some change in $a$ causes a change in
  $b$. Properties attached to the edge are essentially relations. We color the
  edges according to properties.

\todo[inline]{Implement this test}
\begin{test}{Membership test}
\label{test:membership}

  Each compartment must have a unique label. And each compartment can only
  belong to one cell.

\end{test}

<<neuroml to network>>=
self.neuroml2Network(test=False)
@ %def neuroml2Network 

\begin{itemize}
\item Convert morphology to network.
\item Merge other XML model to this network.
\end{itemize}

<<methods>>=
def neuroml2Network(self, test=False) :
  debug.printDebug("INFO", "Converting neuroml to netowrk graph")
  nmlElems = self.xmlDict['nml']
  if len(nmlElems) > 1 :
    debug.printDebug("ERR", "More than one nueroml file is not supported yet.")
    self.exit()
  else : 
    nmlElem, nmlPath = nmlElems[0]
  self.nml = nmlElem
  <<add cell morphology>>
@ %def neuroML2Moose

<<Local imports>>=
import collections 
import os
import helper.graph_methods as graph_helper
import helper.xml_methods as xml_helper
@ 

<<add cell morphology>>=
networkElem = xml_helper.getElement(self.nml, self.xmlExpr, "network")
if not  networkElem :
  debug.printDebug("WARN", "No network found in model. Assuming a single"+
    " cell model. ", inspect.currentframe())
  <<build a single cell model>>
else :
  <<build network>>

debug.printDebug("INFO", "Dumping graph into a dot file")
graph_helper.write_dot(self.mooseG, 'graphs/moose.dot')
@

\paragraph{Cell}

   Following is the fragment of schema of [[CellType]]. Zero or more element of
   this type must be there in the document.

\input|"./fragment.py CellTypes 19"
\input|"./fragment.py Cell 10"

<<build a single cell model>>=
cellList = xml_helper.getElement(self.nml, self.xmlExpr, "cell")
for cellXml in cellList :
  self.insertCellIntoNetwork(cellXml) 
@

\paragraph{[[insertCellIntoNetwork]]}

    Each segment inside a cell has unique id but two segments in two different
    cells might have same id.  To avoid this, we identify each segment with a
    tuple of [[(cellid, segmentid)]].

<<methods>>=
def insertCellIntoNetwork(self, cell, test=False) :
  '''
  This function takes a XML representation of cell and insert in onto a graph.
  '''
  cellId = cell.get('id')
  cellMetaId = cell.get('metaid')
  # get morphology and build the network 
  for elem in cell :
    # Keep the type of segments in a dictionary.
    if xml_helper.isTaggedWith(elem, "morphology") :
      for e in elem :
        if xml_helper.isTaggedWith(e, "segment") :
          nodeId = (cellId, e.get('id'))
          self.mooseG.add_node(nodeId, label=e.get('name'))
          # Attach the segment to the node
          self.mooseG.node[nodeId]['segment'] = e
          parents = e.xpath("./*[local-name()='parent'][position()=1]") 
          if parents :
            if test :
              assert len(parents) == 1
            parent = parents[0]
            parentNodeId =(cellId, parent.get('segment'))
            try :
              self.mooseG.add_edge(parentNodeId, nodeId)
            except :
              debug.printDebug("ERR", sys.exc_info())
            
        elif xml_helper.isTaggedWith(e, "segmentGroup") :
          groupId = e.get('id')
          self.mooseG.graph['gProp']['segmentGroup'].add(groupId)
          for sg in e :
            if xml_helper.isTaggedWith(sg, "member") :
              nodeId = (cellId, sg.get('segment'))
              self.mooseG.node[nodeId]['segmentGroup'] = groupId
            else :
              debug.printDebug("NOTE", "This tag {0} is not supported.".format(sg.tag))

    elif xml_helper.isTaggedWith(elem, "biophysicalProperties") :
      for prop in elem :
        if xml_helper.isTaggedWith(prop, "membraneProperties") :
          <<attach membrane properties to compartment>>
        elif  xml_helper.isTaggedWith(prop, "intracellularProperties") :
          <<attach intracellular properties to compartment>>
        elif xml_helper.isTaggedWith(prop, "extracellularProperties") :
          print "Extra-cellular properties"
    elif xml_helper.isTaggedWith(elem, "notes") : pass
    elif xml_helper.isTaggedWith(elem, "annotation") : pass
    else :
      debug.printDebug("WARN", "Element {0} not supported yet.".format(elem.tag)
        , inspect.currentframe())

@ %def insertCellIntoNetwork

<<build network>>=
debug.printDebug("INFO", "Build network")

@ %def build_model

\paragraph{Adding membrane properties on to compartment}

    Lets write a generic function [[attachToCompartment]] which we will use to
    attach various thingies to a compartment (node of a graph).

<<methods>>=
def attachToCompartment(self, cellId, xmlElem) :
  debug.printDebug("INFO", "Attaching properties to element")
  
@ %def attachToCompartment 

\paragraph{Attaching properties}

    Properties are attached as tuple. First element of tuple is the name of the
    property and the second element of the tuple is the sub-type of the
    property.

<<attach membrane properties to compartment>>=
debug.printDebug("INFO", "Attaching properties to membrane")
for e in prop :
  propName = xml_helper.getTagName(e.tag)
  if e.get('segment') and e.get('segment') != 'all' :
    nodeId = (cellId, e.get('segment'))
    self.mooseG.node[nodeId][('membraneProperties', propName)] = e
  elif e.get('segmentGroup') :
    group = e.get('segmentGroup')
    for n in self.mooseG.nodes() :
      if self.mooseG.node[n]['segmentGroup'] == group :
        self.mooseG.node[n][('membraneProperties', propName)] = e
      else : pass
  else :
    for n in self.mooseG.nodes() :
      self.mooseG.node[n][('membraneProperties', propName)] = e
@ %def membrane_properties_to_comparment

\paragraph{Attach intracellular properties to the compartment}

    These ion channels are present in all comparments of a cell. Attach them to
    all compartments which are inside this cell. Unfortunately neuroML does not
    have a fixed SI units and that will create a headache. Write a function
    which converts these units to a SI units. A function to do this task
    [[toSIUnits]] is written in [[./src/helper/xml_methods.py]] file.

<<attach intracellular properties to compartment>>=
debug.printDebug("INFO", "Attaching intracellular properties")
for e in prop :
  propId = xml_helper.getTagName(e.tag)
  for n in self.mooseG.nodes() :
    if n[0] == cellId :
      self.mooseG.node[n][('intracellularProperties', propId)] = e

@ %def intracellular_properites_to_compartment
