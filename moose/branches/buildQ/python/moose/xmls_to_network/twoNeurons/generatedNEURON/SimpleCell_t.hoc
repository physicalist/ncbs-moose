
//  ******************************************************
//
//     File generated by: neuroConstruct v1.7.0
//
//     Generally replicates hoc for Cell Type as exported from
//     NEURON's Cell Builder, together with some neuroConstruct
//     specific helper/info procedures, e.g. toString(), netInfo()
//
//  ******************************************************


begintemplate SimpleCell_t

public init, topol, basic_shape, subsets, geom, memb
public synlist, x, y, z, position, connect2target


//  Some fields for referencing the cells

public reference, type, description, name
strdef reference, type, description, name


//  Some methods for referencing the cells

public toString, netInfo


//   Needed to match segment id to NEURON sections

public accessSectionForSegId
public getFractAlongSection

public all

objref synlist
objref all
objref stringFuncs

public soma_group
objref soma_group
public dendrite_group
objref dendrite_group
public axon_group
objref axon_group

proc init() {
    topol()
    subsets()
    geom()
    biophys()
    geom_nseg()
    synlist = new List()
    x = y = z = 0
    reference = $s1
    type = $s2
    description = $s3
    
    strdef indexNum
    stringFuncs = new StringFunctions()
    stringFuncs.tail(reference, "_", indexNum)
    while (stringFuncs.substr( indexNum, "_")>=0) {
        stringFuncs.tail(indexNum, "_", indexNum)
    }
    
    sprint(name, "%s", type)
}

create Soma
public Soma
create mainDendSec
public mainDendSec
create subDendSec1
public subDendSec1
create subDendSec2
public subDendSec2
create subDendSec3
public subDendSec3
create mainAxonSec
public mainAxonSec

proc topol() {
    connect mainDendSec(0), Soma(0.5)
    connect subDendSec1(0), mainDendSec(1.0)
    connect subDendSec2(0), mainDendSec(1.0)
    connect subDendSec3(0), mainDendSec(1.0)
    connect mainAxonSec(0), Soma(0.5)
    basic_shape()
}

proc basic_shape() {

//  Looking at segment number 0: Soma, section: Soma, SPHERICAL, ID: 0, ROOT SEGMENT, rad: 8.0, (0.0, 0.0, 0.0) -> (0.0, 0.0, 0.0) (FINITE VOLUME)
    Soma {pt3dclear() pt3dadd(0.0, -8.0, 0.0, 16.0) pt3dadd(0.0, 8.0, 0.0, 16.0)}

//  Looking at segment number 1: mainDend, section: mainDendSec, ID: 1, parent: Soma (0), FRACT ALONG: 0.5, rad: 1.0, (0.0, 0.0, 0.0) -> (20.0, 0.0, 0.0), len: 20
    mainDendSec {pt3dclear() pt3dadd(0.0, 0.0, 0.0, 2.0) pt3dadd(20.0, 0.0, 0.0, 2.0)}

//  Looking at segment number 2: subDend1, section: subDendSec1, ID: 2, parent: mainDend (1), rad: 1.0, (20.0, 0.0, 0.0) -> (40.0, 15.0, 0.0), len: 25
    subDendSec1 {pt3dclear() pt3dadd(20.0, 0.0, 0.0, 2.0) pt3dadd(40.0, 15.0, 0.0, 2.0)}

//  Looking at segment number 3: subDend2, section: subDendSec2, ID: 3, parent: mainDend (1), rad: 1.0, (20.0, 0.0, 0.0) -> (45.0, 0.0, 0.0), len: 25
    subDendSec2 {pt3dclear() pt3dadd(20.0, 0.0, 0.0, 2.0) pt3dadd(45.0, 0.0, 0.0, 2.0)}

//  Looking at segment number 4: subDend3, section: subDendSec3, ID: 4, parent: mainDend (1), rad: 1.0, (20.0, 0.0, 0.0) -> (40.0, -15.0, 0.0), len: 25
    subDendSec3 {pt3dclear() pt3dadd(20.0, 0.0, 0.0, 2.0) pt3dadd(40.0, -15.0, 0.0, 2.0)}

//  Looking at segment number 5: mainAxon, section: mainAxonSec, ID: 5, parent: Soma (0), FRACT ALONG: 0.5, rad: 0.5, (0.0, 0.0, 0.0) -> (-30.0, 0.0, 0.0), len: 30
    mainAxonSec {pt3dclear() pt3dadd(0.0, 0.0, 0.0, 1.0) pt3dadd(-30.0, 0.0, 0.0, 1.0)}
}

proc subsets() { local i


//  The group all is assumed never to change
    all = new SectionList()


    soma_group = new SectionList()

    Soma soma_group.append()


    dendrite_group = new SectionList()

    mainDendSec dendrite_group.append()
    subDendSec1 dendrite_group.append()
    subDendSec2 dendrite_group.append()
    subDendSec3 dendrite_group.append()


    axon_group = new SectionList()

    mainAxonSec axon_group.append()


    Soma all.append()
    mainDendSec all.append()
    subDendSec1 all.append()
    subDendSec2 all.append()
    subDendSec3 all.append()
    mainAxonSec all.append()
}

proc geom() {
}

proc biophys() {
    forsec all cm = 1.0
    forsec all Ra = 30.0

}

proc geom_nseg() {
    // All sections not mentioned here have nseg = 1

}


proc position() { local i
    forsec all {
        for i = 0, n3d()-1 {
            pt3dchange(i, $1+x3d(i), $2+y3d(i), $3+z3d(i), diam3d(i))
        }
    }
    x = $1  y = $2  z = $3
}


//  Accessing the section which corresponds to the given segment id

proc accessSectionForSegId() {   

    id = $1
    if (id == 0)  { access Soma }
    if (id == 1)  { access mainDendSec }
    if (id == 2)  { access subDendSec1 }
    if (id == 3)  { access subDendSec2 }
    if (id == 4)  { access subDendSec3 }
    if (id == 5)  { access mainAxonSec }
}


//  For getting the fraction along the NEURON section, given the fraction
//  along the segment who's id is given
//  NOTE:This function will produce incorrect results if the morphology of the cell is altered after initialisation
//  TODO: alter to use pt3d info direct from section, getting lengths from those... (may be slower)

func getFractAlongSection() {   

    fractionAlongSegment = $1
    id = $2
    // Section Soma has 1 segment
    if (id == 0)  {return fractionAlongSegment} // one seg in sec, so return immediately
    // Section mainDendSec has 1 segment
    if (id == 1)  {return fractionAlongSegment} // one seg in sec, so return immediately
    // Section subDendSec1 has 1 segment
    if (id == 2)  {return fractionAlongSegment} // one seg in sec, so return immediately
    // Section subDendSec2 has 1 segment
    if (id == 3)  {return fractionAlongSegment} // one seg in sec, so return immediately
    // Section subDendSec3 has 1 segment
    if (id == 4)  {return fractionAlongSegment} // one seg in sec, so return immediately
    // Section mainAxonSec has 1 segment
    if (id == 5)  {return fractionAlongSegment} // one seg in sec, so return immediately

    return fractionAlongSegment // assumes id not found, i.e. a one segment section...
}

proc connect2target() {   //$o1 target point process, $o2 returned NetCon


//  Using standard NetBuilder form. (Overly) simple assumption that first soma seg is trigger for AP...
//  Note: neuroConstruct does not use this func for creating connections (in serial mode!), but it can be useful when using generated files in NEURON's NetBuilder

    Soma $o2 = new NetCon(&v(1), $o1)
    print "connect2target called on ", name
}


//  This function is useful when checking what cells (aot sections) have been created. Run allcells() from nCtools.hoc...

proc toString() {
    strdef info
    sprint(info, "Cell ref: %s (%s), at: (%d, %d, %d)", reference, name, x, y, z)
    print info
}


//  This function is useful when checking network connections

proc netInfo() {
    strdef info
    sprint(info, "Cell reference: %s, type: %s", reference, type)
    print "--------  ",info
    print "    There are ", synlist.count(), " connections in ", synlist
    for i=0,synlist.count()-1 {
        print "        Connection from ", synlist.o[i].precell, " to: ", synlist.o[i].postcell
        print "        Pre:   Weight: ", synlist.o[i].weight, ", delay: ", synlist.o[i].delay, ", threshold: ", synlist.o[i].threshold 
        print "        Post:  ", synlist.o[i].syn(), ", gmax: ", synlist.o[i].syn().gmax , ", e: ", synlist.o[i].syn().e , ", rise time: ", synlist.o[i].syn().tau_rise , ", decay time: ", synlist.o[i].syn().tau_decay 
    print " "
    }
    
    
    
    print "--------  "
    print " "
}


endtemplate SimpleCell_t

