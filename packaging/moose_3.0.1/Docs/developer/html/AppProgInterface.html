<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>MOOSE: Applications Programming Interface, API. Async13 branch.</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">MOOSE
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Applications Programming Interface, API. Async13 branch. </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="DataStructs"></a>
Key Data structures</h1>
<h2><a class="anchor" id="DataStructOverview"></a>
Overview</h2>
<p>MOOSE represents all simulation concepts through objects. The API specifies how to manipulate these objects. Specifically, it deals with their creation, destruction, field access, computation, and exchange of data through messages.</p>
<p>Objects in MOOSE are always wrapped in the <a class="el" href="classElement.html">Element</a> container class. Each <a class="el" href="classElement.html">Element</a> holds an array of Objects, sized from zero to a very large number limited only by machine memory.</p>
<p>The functions and fields of each class in MOOSE are defined in Finfos: <a class="el" href="classField.html">Field</a> Info classes. These are visible to users as fields.</p>
<p>Data communication between Elements (that is, their constitutent Objects) is managed by the <a class="el" href="classMsg.html">Msg</a> class: messages.</p>
<p>These three concepts: Elements, Finfos, and Msgs - are manipulated by the API.</p>
<h2><a class="anchor" id="DataStructElementAccess"></a>
Id: Handles for Elements</h2>
<p>Each <a class="el" href="classElement.html">Element</a> is uniquely identified by an <b><a class="el" href="classId.html">Id</a></b>. Ids are consistent across all nodes and threads of a multiprocessor simulation. Ids are basically indices to a master array of all Elements. Ids are used by the Python system too.</p>
<h2><a class="anchor" id="DataStructElementClasses"></a>
Element classes: Handling Objects within elements.</h2>
<p>The <b><a class="el" href="classElement.html">Element</a></b> is a virtual base class that manages objects. It deals with creation, resizing, lookup and destruction of the data. It handles load balancing. It manages fields. It manages messages.</p>
<h2><a class="anchor" id="DataStructObjectClasses"></a>
Object classes: Computational and data entities in MOOSE.</h2>
<p><b>Objects</b> in MOOSE do the actual work of computation and data structures. They are insulated from the housekeeping jobs of creation, interfacing to scripts and to messaging. To do this they present a very stereotyped interface to the MOOSE <a class="el" href="classElement.html">Element</a> wrapper. The following are the essential components of this interface. These are discussed in more detail in the document "Building New MOOSE Classes." </p>
<h3><a class="anchor" id="ObjectsInMooseConstructor"></a>
Object Constructors</h3>
<p>All MOOSE classes need a constructor <b>Object()</b> that correctly initializes all fields. This constructor does not take any arguments. It can be omitted only if the default C++ constructor will guarantee initialization. </p>
<h3><a class="anchor" id="ObjectsInMooseAssignment"></a>
Object assignment operator</h3>
<p>MOOSE needs to know how to copy objects. By default it does a bit-copy. If this is not what you need, then you must explicitly specify an assignment operator. For example, if you set up pointers and do not want your objects to share the data in the pointers, you will want to specify an assignment operator to rebuild the contents of the pointers. </p>
<h3><a class="anchor" id="ObjectsInMooseFinfo"></a>
Object fields.</h3>
<p>MOOSE needs to know what fields an object has. Fields can be of three main kinds: value fields, message source fields, and message destination (aka function) fields. All these fields are managed by <b><a class="el" href="classFinfo.html">Finfo</a></b> objects (<a class="el" href="classField.html">Field</a> infos), which are in turn organized by the <a class="el" href="classCinfo.html">Cinfo</a> (Class Info) objects as described below. In a nutshell, all fields are associated with a name, access functions, and some documentation by creating Finfos for them, and all the Finfos are stored in the <a class="el" href="classCinfo.html">Cinfo</a>. </p>
<h3><a class="anchor" id="ObjectsInMooseCinfo"></a>
Object class information.</h3>
<p>Every MOOSE class is managed by a <b><a class="el" href="classCinfo.html">Cinfo</a></b> (Class Info) object. This is defined in a static initializer function in every class. The <a class="el" href="classCinfo.html">Cinfo</a> stores the class name and documentation, how to look up fields, how to handle data, and so on. </p>
<h3><a class="anchor" id="ObjectsInMooseMsgs"></a>
Object message sending.</h3>
<p>Any MOOSE object can call any function in any other object. This is managed by the message source fields: <b>SrcFinfos</b>. SrcFinfos defined as above all present a <b>send()</b> function, which traverses all targets of the message and calls the target function with the specified arguments. SrcFinfos are typed, so precisely the correct number and type of arguments are always sent. Messages can go across nodes, the user does not need to do anything special to arrange this.</p>
<h2><a class="anchor" id="DataStructObjectAccess"></a>
ObjId: Identifiers for Objects within elements.</h2>
<p>The <b><a class="el" href="classObjId.html">ObjId</a></b> specifies a specific object within the <a class="el" href="classElement.html">Element</a>. All Elements manage a linear array of identical objects, which can have any number of entries greater than zero, up to the limits of memory. The <a class="el" href="classObjId.html#a57f0ba8f44f988d2b28b8d013d74155e">ObjId::dataIndex</a> field is the index into this array. In addition, the <a class="el" href="classObjId.html">ObjId</a> has a field <a class="el" href="classObjId.html#adb85285987b1360491b77ca2a28edc5f">ObjId::fieldIndex</a> that comes into use in a subset of objects. This is used when each object has to manage arrays of fields, which are made visible as FieldElements. For example, one could have an array of receptor channels, each of which manages an array of synapses. Thus to fully specify a synapse, one uses both the <a class="el" href="classObjId.html#a57f0ba8f44f988d2b28b8d013d74155e">ObjId::dataIndex</a> to specify the parent receptor, and the <a class="el" href="classObjId.html#adb85285987b1360491b77ca2a28edc5f">ObjId::fieldIndex</a> to specify the synapse on that receptor.</p>
<h2><a class="anchor" id="DataStructObjId"></a>
ObjId: Fully specified handle for objects.</h2>
<p>The <a class="el" href="classObjId.html">ObjId</a> is a composite of <a class="el" href="classId.html">Id</a> and DataId. It uniquely specifies any entity in the simulation. It is consistent across nodes. In general, one would use the <a class="el" href="classObjId.html">ObjId</a> for most Object manipulation, field access, and messaging API calls. The <a class="el" href="classObjId.html">ObjId</a> can be initialized using a string path of an object. The string path of an object can be looked up from its <a class="el" href="classObjId.html">ObjId</a>.</p>
<h2><a class="anchor" id="DataStructTrees"></a>
Element hierarchies and path specifiers.</h2>
<p>Elements are organized into a tree hierarchy, much like a Unix file system. This is similar to the organization in GENESIS. Since every <a class="el" href="classElement.html">Element</a> has a name, it is possible to traverse the hierarchy by specifying a path. For example, you might access a specific dendrite on cell 72 as follows:</p>
<pre class="fragment">/network/cell[72]/dendrite[50]
</pre><p>Note that this path specifier maps onto a single <a class="el" href="classObjId.html">ObjId</a>. Every object can be indexed, and if no index is given then it assumed that it refers to index zero. For example, the above path is identical to:</p>
<pre class="fragment">/network[0]/cell[72]/dendrite[50]
</pre><p>Path specifiers can be arbitrarily nested. Additionally, one can have single dimensional arrays at any level of nesting. Here is an example path with nested arrays:</p>
<pre class="fragment">/network/layerIV/cell[23]/dendrite[50]/synchan/synapse[1234]
</pre><h2><a class="anchor" id="ObjIdAndPaths"></a>
ObjIds, paths, and dimensions.</h2>
<p>Objects sit on the Elements, which follow a tree hierarchy. There are two ways to find an object. First, the <a class="el" href="classObjId.html">ObjId</a> completely identifies an object no matter where it is in the object tree. Second, one can traverse the <a class="el" href="classElement.html">Element</a> tree using indices to identify specific Objects. This too uniquely identifies each Object. Every <a class="el" href="classObjId.html">ObjId</a> has a 'parent' <a class="el" href="classObjId.html">ObjId</a>, the exception being the root <a class="el" href="classObjId.html">ObjId</a> which is its own parent. Any <a class="el" href="classObjId.html">ObjId</a> can have its own 'child' objects in the tree. The tree cannot loop back onto itself. Objects are always stored as linear arrays.</p>
<pre class="fragment">/foo[0]/bar
</pre><p> is a different object from </p>
<pre class="fragment">/foo[1]/bar
</pre><p>Some useful API calls for dealing with the path:</p>
<p><a class="el" href="classObjId.html#a12bb905e21f97feaf86a50c9546c3517">ObjId::ObjId( const string&amp; path )</a>: Creates the <a class="el" href="classObjId.html">ObjId</a> pointing to an already created object on the specified path.</p>
<p>string <a class="el" href="classObjId.html#a47263201585866a708db4dcddea13ba2">ObjId::path()</a>: Returns the path string for the specified <a class="el" href="classObjId.html">ObjId</a>.</p>
<pre class="fragment">ObjId f2( "/f1[2]/f2" );
assert( f2.path() == "/f1[2]/f2[0]" );
</pre><p>There is a special meaning for the path for synapses. Recall that the <a class="el" href="classObjId.html">ObjId</a> for synapses (which are FieldElements of SynChans) has two indices, the DataIndex and the FieldIndex. The DataIndex of the synapse is identical to that of its parent <a class="el" href="classSynChan.html">SynChan</a>. This is illustrated as follows:</p>
<pre class="fragment">ObjId synchan( "/cell/synchan[20] );
assert( synchan.dataIndex == 20 );

ObjId synapse( "/cell/synchan[20]/synapse[5]" );
assert( synapse.dataIndex == 20 );
assert( synapse.fieldIndex == 5 );
</pre><h2><a class="anchor" id="Wildcard_paths"></a>
Wildcard paths</h2>
<p>Some commands take a <em>wildcard</em> path. This compactly specifies a large number of ObjIds. Some example wildcards are</p>
<pre class="fragment">/network/##     // All possible children of network, followed recursively
/network/#      // All children of network, only one level.
/network/ce#    // All children of network whose name starts with 'ce'
/network/cell/dendrite[]    // All dendrites, regardless of index
/network/##[ISA=CaConc]     // All descendants of network of class CaConc
/soma,/axon     // The elements soma and axon
</pre><h1><a class="anchor" id="FieldAccess"></a>
Setting and Getting Field values.</h1>
<h2><a class="anchor" id="FieldAccessOverview"></a>
Overview</h2>
<p>There is a family of classes for setting and getting <a class="el" href="classField.html">Field</a> values. These are the </p>
<ul>
<li>SetGet&lt; A1, A2... &gt;::set( <a class="el" href="classObjId.html">ObjId</a> id, const string&amp; name, arg1, arg2... ) and </li>
<li>SetGet&lt; A &gt;::get( ObjId id, const string&amp; name ) functions. Here A1, A2 are the templated classes of function arguments. A is the return class from the <em>get</em> call.</li>
</ul>
<p>Since Fields are synonymous with functions of MOOSE objects, the <em>set</em> family of commands is also used for calling object functions. Note that the <em>set</em> functions do not have a return value.</p>
<p>The reason there has to be a family of classes is that all functions in MOOSE are strongly typed. Thus there are <a class="el" href="classSetGet.html">SetGet</a> classes for up to six arguments.</p>
<h2><a class="anchor" id="FieldAccessExamples"></a>
Examples of field access.</h2>
<ol type="1">
<li>If you want to call a function foo( int A, double B ) on <a class="el" href="classObjId.html">ObjId</a> oid, you would do:</li>
</ol>
<pre class="fragment">                SetGet2&lt; int, double &gt;::set( oid, "foo", A, B );
</pre><ol type="1">
<li>To call a function bar( int A, double B, string C ) on oid: <pre class="fragment">                SetGet3&lt; int, double, string &gt;::set( oid, "bar", A, B, C );
</pre></li>
<li>To assign a field value "short abc" on object oid: <pre class="fragment">                Field&lt; short &gt;::set( oid, "abc", 123 );
</pre></li>
<li>To get a field value "double pqr" on object oid: <pre class="fragment">                double x = Field&lt; short &gt;::get( oid, "pqr" );
</pre></li>
<li><p class="startli">To assign the double 'xcoord' field on all the objects on element <a class="el" href="classId.html">Id</a> id, which has an array of the objects: </p>
<pre class="fragment">                vector&lt; double &gt; newXcoord;
                // Fill up the vector here.
                Field&lt; double &gt;::setVec( id, "xcoord", newXcoord );
</pre><p> Note that the dimensions of newXcoord should match those of the target element.</p>
<p class="startli">You can also use a similar call if it is just a function on id: </p>
<pre class="fragment">                SetGet1&lt; double &gt;::setVec( id, "xcoord_func", newXcoord );
</pre></li>
<li>To extract the double vector 'ycoord' field from all the objects on id: <pre class="fragment">                vector&lt; double &gt; oldYcoord; // Do not need to allocate.
                Field&lt; double &gt;::getVec( id, "ycoord", oldYcoord );
</pre></li>
<li>To set/get LookupFields, that is fields which have an index to lookup: <pre class="fragment">                double x = LookupField&lt; unsigned int, double &gt;::get( objId, field, index );
                LookupField&lt; unsigned int, double &gt;::set( objId, field, index, value );
</pre></li>
</ol>
<h1><a class="anchor" id="APIcalls"></a>
API system calls</h1>
<h2><a class="anchor" id="FieldAccessOverview"></a>
Overview</h2>
<p>There is a special set of calls on the <a class="el" href="classShell.html">Shell</a> object, which function as the main MOOSE programmatic API. These calls are all prefixed with 'do'. Here is the list of functions:</p>
<ul>
<li><a class="el" href="classId.html">Id</a> doCreate(  string type, Id parent, string name, vector&lt; unsigned int &gt; dimensions ); </li>
<li>bool doDelete( Id id ) </li>
<li>MsgId doAddMsg( const string&amp; msgType, ObjId src, const string&amp; srcField, ObjId dest, const string&amp; destField); </li>
<li>void doQuit(); </li>
<li>void doStart( double runtime ); </li>
<li>void doReinit(); </li>
<li>void doStop(); </li>
<li>void doMove( Id orig, Id newParent ); </li>
<li><a class="el" href="classId.html">Id</a> doCopyId orig, <a class="el" href="classId.html">Id</a> newParent, string newName, unsigned int n, bool copyExtMsgs); </li>
<li><a class="el" href="classId.html">Id</a> doFind( const string&amp; path ) const </li>
<li>void doSetClock( unsigned int tickNum, double dt ) </li>
<li>void doUseClock( string path, string field, unsigned int tick ); </li>
<li><a class="el" href="classId.html">Id</a> doLoadModel( const string&amp; fname, const string&amp; modelpath );</li>
</ul>
<h1><a class="anchor" id="ClockScheduling"></a>
Clocks, Ticks, and Scheduling</h1>
<h2><a class="anchor" id="ClockOverview"></a>
Overview</h2>
<p>Most of the computation in MOOSE occurs in a special function called <em>process</em>, which is implemented in all object classes that advance their internal state over time. The role of Clocks and Ticks is to set up the sequence of calling <em>process</em> for different objects, which may have different intervals for updating their internal state. The design of scheduling in moose is similar to GENESIS.</p>
<p>As a simple example, suppose we had six objects, which had to advance their internal state with the following intervals: </p>
<ul>
<li><b>A:</b> 5 </li>
<li><b>B:</b> 2 </li>
<li><b>C:</b> 2 </li>
<li><b>D:</b> 1 </li>
<li><b>E:</b> 3 </li>
<li><b>F:</b> 5</li>
</ul>
<p>Suppose we had to run this for 10 seconds. The desired order of updates would be:</p>
<pre class="fragment">Time    Objects called
1   D
2   D,B,C
3   D,E
4   D,B,C
5   D,A,F
6   D,B,C,E
7   D
8   D,B,C
9   D,E
10  D,B,C,A,F
</pre><h2><a class="anchor" id="ClockReinit"></a>
Reinit: Reinitializing state variables.</h2>
<p>In addition to advancing the simulation, the Clocks and Ticks play a closely related role in setting initial conditions. It is required that every object that has a <em>process</em> call, must have a matching <em>reinit</em> function. When the command <em>doReinit</em> is given from the shell, the simulation is reinitialized to its boundary conditions. To do so, the <em>reinit</em> function is called in the same sequence that the  would have been called at time 0 (zero). For the example above, this sequence would be:<br/>
D,B,C,E,A,F</p>
<p>In other words, the ordering is first by dt for the object, and second by the sequence of the object in the list.</p>
<p>During reinit, the object is expected to restore all state variables to their boundary condition. Objects typically also send out messages during reinit to specify this boundary condition value to dependent objects. For example, a compartment would be expected to send its initial <em>Vm</em> value out to a graph object to indicate its starting value.</p>
<h2><a class="anchor" id="ClockSetup"></a>
Setting up scheduling</h2>
<p>The API for setting up scheduling is as follows:<br/>
</p>
<ol type="1">
<li>Create the objects to be scheduled.<br/>
</li>
<li>Create <a class="el" href="classClock.html">Clock</a> Ticks for each time interval using</li>
</ol>
<pre class="fragment">    doSetClock( TickNumber, dt ).
</pre><p>In many cases it is necessary to have a precise sequence of events ocurring at the same time interval. In this case, set up two or more <a class="el" href="classClock.html">Clock</a> Ticks with the same dt but successive TickNumbers. They will execute in the same order as their TickNumber. <br/>
Note that TickNumbers are unique. If you reuse a TickNumber, all that will happen is that its previous value of dt will be overridden.</p>
<p>Note also that dt can be any positive decimal number, and does not have to be a multiple of any other dt.</p>
<ol type="1">
<li>Connect up the scheduled objects to their clock ticks:</li>
</ol>
<pre class="fragment">    doUseClock( path, function, TickNumber )
</pre><p>Here the <em>path</em> is a wildcard path that can specify any numer of objects.<br/>
The <em>function</em> is the name of the <em>process</em> message that is to be used. This is provided because some objects may have multiple <em>process</em> messages. The <em>TickNumber</em> identifies which tick to use.</p>
<p>Note that as soon as the <em>doUseClock</em> function is issued, both the <em>process</em> and <em>reinit</em> functions are managed by the scheduler as discussed above.</p>
<h2><a class="anchor" id="ClockSchedExample"></a>
Example of scheduling.</h2>
<p>As an example, here we set up the scheduling for the same set of objects A to F we have discussed above.<br/>
First we set up the clocks:</p>
<pre class="fragment">    doSetClock( 0, 1 );
    doSetClock( 1, 2 );
    doSetClock( 2, 3 );
    doSetClock( 3, 5 );
</pre><p>Now we connect up the relevant objects to them.</p>
<pre class="fragment">    doUseClock( "D", "process", 0 );
    doUseClock( "B,C", "process", 1 );
    doUseClock( "E", "process", 2 );
    doUseClock( "A,F", "process", 3 );
</pre><p>Next we initialize them:</p>
<pre class="fragment">    doReinit();
</pre><p>During the <em>doReinit</em> call, the <em>reinit</em> function of the objects would be called in the following sequence: </p>
<pre class="fragment">    D, B, C, E, A, F
</pre><p>Finally, we run the calculation for 10 seconds:</p>
<pre class="fragment">    doStart( 10 );
</pre> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Jan 4 2015 10:15:35 for MOOSE by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
