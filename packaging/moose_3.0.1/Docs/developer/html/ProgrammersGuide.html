<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>MOOSE: Programmer&#39;s Guide</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">MOOSE
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Programmer's Guide </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Documentation for programmers.</p>
<h1><a class="anchor" id="PG_ProcessLoop"></a>
Process Loop</h1>
<p>The MOOSE main process loop coordinates script commands, multiple threads to execute those commands and carry out calculations, and data transfer between nodes.</p>
<h2><a class="anchor" id="PG_Threads"></a>
Threads</h2>
<p>MOOSE runs in multithread mode by default. MOOSE uses pthreads.</p>
<ol type="1">
<li>The main thread (or the calling thread from a parser such as Python) is always allocated.<br/>
</li>
<li>MOOSE estimates the number of CPU cores and sets up that same number of compute threads. To override this number, the user can specify at the command line how many threads to use for computation.<br/>
If MOOSE is running with MPI, one more thread is allocated for controlling MPI data transfers.</li>
</ol>
<p>MOOSE can also run in single-threaded mode. Here everything remains in the 'main' thread or the parser thread, and no other threads are spawned.</p>
<h2><a class="anchor" id="PG_ProcessLoopDetails"></a>
Multithreading and the Process Loop</h2>
<p>The MOOSE process loop coordinates input from the main thread, such as parser commands, with computation and message passing. MOOSE has one process loop function (processEventLoop) which it calls on all compute threads. All these threads synchronize on custom-written barriers, during which a special single- thread function is executed.</p>
<p>The sequence of operations for a single-node, multithread calculation is as follows:</p>
<ol type="1">
<li>The Process calls of all the executed objects are called. This typically triggers all scheduled calculations, which emit various messages. As this is being done on multiple threads, all messages are dumped into individual temporary queues, one for each thread.<br/>
</li>
<li>The first barrier is hit. Here the swapQ function consolidates all the temporary queues into a single one.<br/>
</li>
<li>All the individual threads now work on the consolidated queue to digest messages directed to the objects under that thread. Possibly further messages will be emitted. As before these go into thread-specific queues.<br/>
</li>
<li>The second barrier is hit. Now the scheduler advances the clock by one tick.<br/>
</li>
<li>The loop cycles back.</li>
</ol>
<p>In addition to all this, the parser thread can dump calls into its special queue at any time. However, the parser queue operates a mutex to protect it during the first barrier. During the first barrier, the queue entries from the parser thread are also incorporated into the consolidated queue, and the parser queue is flushed.</p>
<p>These steps are illustrated below:</p>
<div class="image">
<img src="MOOSE_threading.gif" alt="MOOSE_threading.gif"/>
<div class="caption">
MOOSE threading and Process Loop</div></div>
 <h2><a class="anchor" id="PG_MPIProcessLoopDetails"></a>
Multinode data transfer, Multithreading and the Process Loop</h2>
<p>MOOSE uses MPI to transfer data between nodes. The message queues are already in a format that can be transferred between nodes, so the main issue here is to coordinate the threads, the MPI, and the computation in a manner that is as efficient as possible. When carrying out MPI data transfers, things are somewhat more involved. Here we have to additionally coordinate data transfers between many nodes. This is done using an MPI loop (mpiEventLoop) which is called on a single additional thread. MPI needs two buffers: one for sending and one for receiving data. So as to keep the communications going on in the background, the system interleaves data transfers from each node with computation. The sequence of operations starts out similar to above:</p>
<ol type="1">
<li>The Process calls of all the executed objects are called. This typically triggers all scheduled calculations, which emit various messages. As this is being done on multiple threads, all messages are dumped into individual temporary queues, one for each thread. MPI thread is idle.<br/>
</li>
<li>The first barrier is hit. Here the swapQ function consolidates all the temporary queues into a single one.<br/>
</li>
<li>Here, rather than digest the local consolidated queue, the system initiates an internode data transfer. It takes the node0 consolidated queue, and sends it to all other nodes using MPI_Bcast. On node 0, the command reads the provided buffer. On all other nodes, the command dumps the just-received data from node 0 to the provided buffer. The compute threads are idle during this phase.<br/>
</li>
<li>Barrier 2 is hit. Here the system swaps buffer pointers so that the just-received data is ready to be digested, and the other buffer is ready to receive the next chunk of data.<br/>
</li>
<li>Here the compute threads digest the data from node 0, while the MPI thread sends out data from node 1 to all other nodes.<br/>
</li>
<li>Barrier 2 comes round again, buffer pointers swap.<br/>
</li>
<li>Compute threads digest data from node 1, while MPI thread sends out data from node 2 to all other nodes.<br/>
... This cycle of swap/(digest+send) is repeated for all nodes.<br/>
</li>
<li>Compute threads digest data from the last node. MPI thread is idle.<br/>
</li>
<li>In the final barrier, the clock tick is advanced.<br/>
</li>
<li>The loop cycles back.</li>
</ol>
<p>As before, the parser thread can dump data into its own queue, and this is synchronized during the first barrier.</p>
<p>These steps are illustrated below:</p>
<div class="image">
<img src="MOOSE_MPI_threading.gif" alt="MOOSE_MPI_threading.gif"/>
<div class="caption">
MOOSE threading and Process Loop with MPI data transfers between nodes.</div></div>
 <h2><a class="anchor" id="ksolve_threading"></a>
Threading with the Kinetics GSL solver.</h2>
<p>Currently we only subdivide voxels, not parts of a single large model within one voxel.<br/>
</p>
<ul>
<li>
The GslIntegrator handles Process and Reinit. This drives the data structures set up by the <a class="el" href="classStoich.html">Stoich</a> class. </li>
<li>
The Compartment, which is a ChemMesh subclass, is subdivided into a number of MeshEntries (voxels). </li>
<li>
The GslIntegrator has to be created with as many instances as there are MeshEntries (voxels) in the mesh. </li>
<li>
The setup function (currently manual) calls the GslIntegrator::stoich() function on all instances of GslIntegrator (e.g., using setRepeat). </li>
<li>
The scheduling (currently manual) does: <ol>
<li>
Clock0: <a class="el" href="classMeshEntry.html#a5fcb57d5a62301fa251e76d1f2d92fbd">MeshEntry::process</a>. </li>
<li>
Clock1: GslIntegrator::process. </li>
</ol>
</li>
<li>
During Reinit, the GslIntegrator builds up a small data structure called StoichThread. This contains a pointer to the <a class="el" href="classStoich.html">Stoich</a>, to the <a class="el" href="classProcInfo.html">ProcInfo</a>, and the meshIndex. There is a separate StoichThread on each GslIntegrator instance. </li>
<li>
<p class="startli">During Process on the <a class="el" href="classMeshEntry.html">MeshEntry</a>, the following sequence of calls ensues: </p>
<ol>
<li>
ChemMesh::updateDiffusion( meshIndex ) </li>
<li>
Stoich::updateDiffusion( meshIndex, stencil ) </li>
<li>
Iterate through stencils, calling <a class="el" href="classStencil.html#a8b6a62b116c865fc3adeab0f707d226a">Stencil::addFlux</a> for meshIndex </li>
<li>
In <a class="el" href="classStencil.html#a8b6a62b116c865fc3adeab0f707d226a">Stencil::addFlux</a>: Add flux values to the Stoich::flux vector. </li>
</ol>
<p class="endli"></p>
</li>
<li>
During Process on the GslIntegrator: <ol>
<li>
the GslIntegrators on all threads call their inner loop for advancing to the next timestep through gsl_odeiv_evolve_apply. </li>
<li>
The GslIntegrators on all threads call Stoich::clearFlux. </li>
</ol>
</li>
<li>
During Process on the <a class="el" href="classStoich.html">Stoich</a>, which is called through the GslIntegrator functions, not directly from Process: <ol>
<li>
Through the GSL, Stoich::gslFunc is called on each thread. This calls the innerGslFunc with the appropriate meshIndex. This does the calculations for the specified voxel. These calculations include the chemistry, and also add on the appropriate flux terms for each molecule at this meshIndex.<br/>
 </li>
<li>
The Stoich::clearFlux function zeroes out all the entries in the flux_ vector at the specified meshIndex.<br/>
 </li>
</ol>
</li>
</ul>
<h1><a class="anchor" id="Solvers_zombies"></a>
Solvers and Zombies</h1>
<h2><a class="anchor" id="SolversOverview"></a>
Overview</h2>
<h2><a class="anchor" id="WritingZombies"></a>
Writing Zombies</h2>
<p>Zombies are superficially identical classes to regular MOOSE classes, only they are now controlled by some kind of numerically optimized solver. The role of the Zombie is to give the illusion that the original object is there and behaving normally (except perhaps computing much faster). All the original messages and fields are preserved. It is important that there be a one-to-one match between the original and zombie list of Finfos in the <a class="el" href="classCinfo.html">Cinfo</a> static intialization.<br/>
Zombies provide an interface between the original fields and the solver. They usually do so by maintaining a pointer to the solver, and using its access functions.<br/>
Zombie classes typically also provide two special functions: <br/>
zombify( Element* solver, Element* orig) and unzombify( Element* zombie). These do what you might expect from the name. The solver calls these operations during setup.<br/>
 There are two main kinds of zombies: </p>
<ul>
<li>
Soulless zombies: These lack any data whatsoever, and are derived classes from the solver. The Zombie data is nothing but a pointer to the managing solver, and is never duplicated. These are managed by a ZombieHandler. During the zombify routine, all the relevant data goes over to the solver, and the original data and dataHandler is deleted. </li>
<li>
Transformed Zombies: These carry some data of their own, as well as a pointer to the managing solver. If they are converted to an array, or resized they have to have their own data resized too. These are managed by a regular DataHandler. During the zombify routine, some parts of the data are copied over to the new Zombie data structure, some go to the solver, and the rest is discarded. The original data is deleted. </li>
</ul>
<h1><a class="anchor" id="NewClasses"></a>
Writing new MOOSE classes</h1>
<h2><a class="anchor" id="NewClassesOverview"></a>
Overview</h2>
<p>MOOSE is designed to make it easy to set up new simulation classes. This process is discussed in detail in this section. Briefly, the developer provides their favourite implementation of some simulation concept as a class. The functions and fields of this class are exposed to the MOOSE system through a stereotyped ClassInfo structure. With this, all of the MOOSE functionality becomes available to the new class.</p>
<h2><a class="anchor" id="FunctionsOnObjects"></a>
Functions on MOOSE objects</h2>
<p>MOOSE provides a general way for objects to call each other's functions through messaging, and for the script to also call these functions. To do this functions are exposed to the API in two layers. The top layer associates names with each function, using Finfos. A <a class="el" href="classDestFinfo.html">DestFinfo</a> is the most straightforward way to do this, as it handles just a single function. ValueFinfos and their kin are associated with two functions: a set function and a get function.</p>
<p>The second layer wraps each function in a consistent form so that the message queuing system can access it. This is done by the <a class="el" href="classOpFunc.html">OpFunc</a> and its derived classes, EpFunc, UpFunc, <a class="el" href="classGetOpFunc.html">GetOpFunc</a>, <a class="el" href="classProcOpFunc.html">ProcOpFunc</a>, and FieldOpFunc. The form of the wrapping in all cases is:</p>
<pre class="fragment">void op( const Eref&amp; e, const Qinfo* q, const double* buf ) const
</pre><p>The job of each of these classes is to then map the arguments in the buffer to the arguments used by the object function. Here are some of the key features: </p>
<ul>
<li>
<p class="startli"><a class="el" href="classOpFunc.html">OpFunc</a>: These contain just the arguments to the function. For example: </p>
<pre class="fragment">        OpFunc1&lt; Foo, double &gt;( &amp;Foo::sum );
        ...
        void Foo::sum( double v ) {
            tot_ += v;
        }</pre><p> These are useful when the function only operates on the internal fields of the destination object.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">EpFunc: These pass the <a class="el" href="classEref.html">Eref</a> and the Qinfo in ahead of the other function arguments. This is essential when you want to know about the MOOSE context of the function. For example, if you need to send a message out you need to know the originating object and thread. If you want to manipulate a field on the <a class="el" href="classElement.html">Element</a> (as opposed to the individual object), again you need a pointer to the <a class="el" href="classEref.html">Eref</a>. If your function needs to know what the originating Object was, it can get this from the Qinfo. For example: </p>
<pre class="fragment">        EpFunc1&lt; Bar, double &gt;( &amp;Bar::sum );
        ...
        void Bar::sum( const Eref&amp; e, const Qinfo* q, double v ) {
            tot_ += v;
            Id src = q-&gt;src();
            msg-&gt;send( e, q-&gt;threadNum(), tot_, src );
        }</pre><p class="endli"></p>
</li>
<li>
<p class="startli">UpFunc: These are used in FieldElements, where the actual data and operations have to be carried out one level up, on the parent. For example, Synapses may be FieldElements sitting as array entries on a Receptor object. Any functions coming to the Synapse have to be referred to the parent Receptor, with an index to identify which entry was called. UpFuncs do this. </p>
<pre class="fragment">        static DestFinfo addSpike( "addSpike",
        "Handles arriving spike messages. Argument is timestamp",
        new UpFunc1&lt; Receptor, double &gt;( &amp;Receptor::addSpike ) 
        );
        // Note that the DestFinfo on the Synapse refers to a function
        // defined on the Receptor.
        ...
        void Receptor::addSpike( unsigned int index, double time ) {
            Synapse&amp; s = synTable[index];
            s.addEvent( time );
        }</pre><p class="endli"></p>
</li>
<li>
<a class="el" href="classProcOpFunc.html">ProcOpFunc</a>: </li>
<li>
<a class="el" href="classGetOpFunc.html">GetOpFunc</a>: </li>
<li>
FieldOpFunc: </li>
</ul>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Jan 4 2015 10:15:35 for MOOSE by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
