<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>MOOSE: HSolve Overview</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">MOOSE
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title"><a class="el" href="classHSolve.html">HSolve</a> Overview </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="Introduction"></a>
Introduction</h1>
<p>This document gives an overview of the Hines' solver (<a class="el" href="classHSolve.html">HSolve</a>) implementation in MOOSE. At present it talks more about the interaction between <a class="el" href="classHSolve.html">HSolve</a> and the rest of MOOSE, and does not talk about <a class="el" href="classHSolve.html">HSolve</a>'s internals (that is, the numerical implementation). Hence, it will be useful for someone who is implementing a new numerical scheme in MOOSE.</p>
<p>When a neuronal model is read into MOOSE (from a NeuroML file, for example), it is represented inside MOOSE by biophysical objects (of type Compartment, <a class="el" href="classHHChannel.html">HHChannel</a>, etc.) linked up by messages. Representing the model in terms of objects and messages is nice because it provides a natural interface that the user and the rest of the system can use.</p>
<p>These objects have fields, using which the user can specify model parameters, and monitor state variables during a simulation. The objects also have some ODE solving code (usually <a class="el" href="classExponential.html">Exponential</a> Euler, or EE) which allows them to advance their own state. The messages allow the objects to talk to each other. In addition, the message connectivity depicts the model's structure.</p>
<p>In absence of <a class="el" href="classHSolve.html">HSolve</a>, these objects do the following things:</p>
<ul>
<li>They are woken up once every time-step to perform their calculations. (Usually a function called process()).</li>
<li>Serve parameter and state variables via fields. For example, for plotting, a Compartment's Vm may be inquired once every few time-steps. Objects do this by providing a get() function for each field, and also a set() function to change the field values.</li>
<li>Communicate with each other via messages. For example, a Compartment object will receive axial current from its neighbouring compartments, and also channel current from <a class="el" href="classHHChannel.html">HHChannel</a> objects.</li>
<li>Communicate with "external" objects (e.g.: other neurons) via messages. For example, sending/receiving synaptic events, receiving current injection in a compartment, etc.</li>
</ul>
<p>This method of doing calculations is good because it is simple to implement, and also provides a fallback method. However, it is very slow for the following reasons:</p>
<ul>
<li>The EE method itself is slow. Sometimes even for simple models with a 2-3 compartments and channels, a timestep of 1e-6 seconds does not give accurate results. On the other hand, with <a class="el" href="classHSolve.html">HSolve</a>, a timestep of 50e-6 is usually enough even for the biggest models.</li>
<li>Objects exchange information using messages. With a model of ~100 compartments and 2 channels per compartment, one can expect ~1000 messages being exchanged per time-step. This can seriously slow down calculations.</li>
<li>Objects may be spread out in memory, which will lead to a lot of cache misses. A single cache miss leads to a penalty of ~200-400 processor cycles.</li>
</ul>
<p>The Hines' solver, in addition to being a higher-order integration method, also increases speed by doing all the calculations in one place, and storing all the data in arrays. This eliminates messaging overheads, and improves data locality.</p>
<p>At the same time, one will like to retain the original objects-and-messages representation of the model, so that the user can easily inspect and manipulate it. In MOOSE, this is accomplished by replacing the original objects with "zombie" objects, whenever a solver like the <a class="el" href="classHSolve.html">HSolve</a> is created. The clients of the original objects remain unaware of this switch, and to them, the zombie objects look just like the originals. The zombie objects have the same fields as the original objects, and the message connectivity is also retained. The illusion is made complete by letting the zombie objects forward any field queries and incoming messages to the <a class="el" href="classHSolve.html">HSolve</a>. More detail on zombie objects is in the "Zombies" section below.</p>
<h1><a class="anchor" id="ConceptualOverview"></a>
Conceptual Overview</h1>
<p>MOOSE allows you to keep your main numerical code very loosely coupled with the rest of the MOOSE system. <a class="el" href="classHSolve.html">HSolve</a> makes good use of this, and keeps the numerical code as independent of MOOSE-specific concepts/classes as possible. The points of interaction between <a class="el" href="classHSolve.html">HSolve</a> and the rest of MOOSE are neatly contained in a few classes/files.</p>
<p>Note: At present, a single <a class="el" href="classHSolve.html">HSolve</a> object handles calculations for a single neuron. Soon, <a class="el" href="classHSolve.html">HSolve</a> will also handle calculations for arrays of identical neurons.</p>
<p>Here is an overview of how things proceed chronologically in a simulation:</p>
<ol type="1">
<li>The user loads in a model, from, say a NeuroML file. The model is represented inside MOOSE as a bunch of objects, connected by messages. The objects are of type Compartment, <a class="el" href="classHHChannel.html">HHChannel</a>, etc. The connections between these objects capture the structure of the model. Each of the objects have fields (e.g.: "Vm" for a Compartment, "Gk" for an <a class="el" href="classHHChannel.html">HHChannel</a>). The user can use these fields to read/modify the parameters and state of the model.</li>
<li>The objects are capable of doing their own calculations at simulation time, using the <a class="el" href="classExponential.html">Exponential</a> Euler method. Usually, the user "schedules" all the objects constituting the model. This means hooking up the objects to a clock, which will invoke the objects at regular intervals to do their calculations. However, since we want <a class="el" href="classHSolve.html">HSolve</a> to the calculations instead of the original objects, this scheduling step is not necessary.</li>
<li>The user connects this single-neuron model with other, external things. For example, a <a class="el" href="classTable.html">Table</a> object may be connected to a Compartment object for the purpose of monitoring its Vm, later during the simulation. Other examples are:<ul>
<li>a <a class="el" href="classTable.html">Table</a> providing time-varying current-injection to a compartment.</li>
<li>synaptic connections between compartments belonging to different neurons.</li>
</ul>
</li>
<li>The user creates an <a class="el" href="classHSolve.html">HSolve</a> object.</li>
<li>The user "schedules" the <a class="el" href="classHSolve.html">HSolve</a> object so that it can do its calculations.</li>
<li>The user sets the "dt" field of the <a class="el" href="classHSolve.html">HSolve</a> object.</li>
<li><p class="startli">The user points the <a class="el" href="classHSolve.html">HSolve</a> object to the model. This is done by setting the <a class="el" href="classHSolve.html">HSolve</a>'s "target" field to the location of model inside MOOSE.</p>
<p class="startli">(Note: MOOSE, arranges objects in a tree, just like directories and files are arranged in a tree by filesystems. Hence, the location of a model is simply the "path" to an object which contains all of the model's objects).</p>
<p class="startli">Setting the "target" field causes <a class="el" href="classHSolve.html">HSolve</a> to do the following:</p>
<ol type="a">
<li>Traverse the model, and build internal data structures based on the model's structure, parameters and state.</li>
<li>"Deschedule" all the original objects, so that they are not longer invoked by the clock to do their calculations.</li>
<li>Create "zombie" objects. More on this in the "Zombies" section below.</li>
</ol>
</li>
<li>The user runs the simulation. As mentioned above, only the <a class="el" href="classHSolve.html">HSolve</a> is invoked every time-step to do its calculations. Further, the rest of the system continues to interact with the individual zombified biophysical objects, not knowing that <a class="el" href="classHSolve.html">HSolve</a> is doing all the thinking in the background.</li>
</ol>
<p>Note that at present, the user is responsible for carrying out all the above steps. In the future, a "solver manager" will be implemented which will take over most of the above responsibilities from the user. The user will mainly need to specify the choice of solver: EE, <a class="el" href="classHSolve.html">HSolve</a>, or any other, if present.</p>
<h1><a class="anchor" id="Zombies"></a>
Zombies</h1>
<p>When an <a class="el" href="classHSolve.html">HSolve</a> object is created, it takes over all the above functions from the original objects. At the same time, each of the original objects is replaced by a corresponding "zombie" object. For example, a Compartment object is replaced with a <a class="el" href="classZombieCompartment.html">ZombieCompartment</a> object. The user (or the rest of the system) continues to interact with the zombie objects, unaware of the switch. The role of the zombies is to act as fully-functional stand-ins, while letting the <a class="el" href="classHSolve.html">HSolve</a> do all the thinking. Hence, a <a class="el" href="classTable.html">Table</a> object can continue requesting for Vm from the compartment it was connected to, not knowing that the compartment has now been replaced by a zombie. Simliarly, another <a class="el" href="classTable.html">Table</a> object can continue feeding current inject values to a compartment, not knowing that they are being fed into <a class="el" href="classHSolve.html">HSolve</a>. All of this is accomplished in the following way:</p>
<ul>
<li>The original objects are disconnected from the scheduling system, so that they are no longer woken up for performing their calculations. Instead, the <a class="el" href="classHSolve.html">HSolve</a> object is invoked once every time-step.</li>
<li>When a field query is made to a zombie object, it calls set/get functions on the <a class="el" href="classHSolve.html">HSolve</a>, rather than on itself.</li>
<li>Similarly, when an incoming message arrives, a function on the <a class="el" href="classHSolve.html">HSolve</a> is called to handle it.</li>
<li>During a simulation, the <a class="el" href="classHSolve.html">HSolve</a> sends out messages on behalf of the original objects, to any outside objects that are connect to objects belonging to the handled neuronal model.</li>
</ul>
<p>For further details about zombies, see the <a class="el" href="ProgrammersGuide.html">Programmer's Guide</a>.</p>
<h1><a class="anchor" id="code"></a>
C++ code: classes and files</h1>
<p>Now we look at the different C++ classes that make up <a class="el" href="classHSolve.html">HSolve</a>, and at the role they play in the processes described above.</p>
<p>At setup time, most of the information flow is in the MOOSE &ndash;&gt; <a class="el" href="classHSolve.html">HSolve</a> direction. Here, the <a class="el" href="classHSolveUtils.html">HSolveUtils</a> class is of particular interest.</p>
<p>At simulation time, most of the information flow is in the <a class="el" href="classHSolve.html">HSolve</a> &ndash;&gt; MOOSE direction. Here, the <a class="el" href="classHSolve.html">HSolve</a> class and the Zombie classes capture most of the interactions.</p>
<p>The numerical implementation is contained in the 3 classes <a class="el" href="classHSolveActive.html">HSolveActive</a>, <a class="el" href="classHSolvePassive.html">HSolvePassive</a>, and <a class="el" href="classHinesMatrix.html">HinesMatrix</a>.</p>
<p>Further details below:</p>
<ol type="1">
<li><a class="el" href="classHSolveUtils.html">HSolveUtils</a>: This is a little library of convenience functions built on top of more basic MOOSE API calls. This library is meant for someone implementing a numerical scheme, and wishing to read in the model. A typical call looks like: "For a given compartment, give me all its
   neighbouring compartments", or, "For a given compartment, give me all the
   HHChannels that it has".</li>
<li><a class="el" href="classHSolve.html">HSolve</a>: The user and the rest of MOOSE interact with this class, and the Zombie classes. <a class="el" href="classHSolve.html">HSolve</a> does the following:<ol type="a">
<li>Inherits numerical code and data structures from the <a class="el" href="classHSolveActive.html">HSolveActive</a> class.</li>
<li>It provides an interface for looking up and modifying the parameters and state of the model. This is implemented as a host of set/get functions, written in <a class="el" href="HSolveInterface_8cpp.html">HSolveInterface.cpp</a>.</li>
<li>Elevates its own status from regular C++ class to a MOOSE class. It does so by registering itself as a class with the MOOSE system. Here it also tells MOOSE that it has fields called "target" and "dt" (as mentioned earlier). It also specifies that it has a field called 'process', which allows it to be connected to a clock from the MOOSE scheduling system. All of this is done in <a class="el" href="classHSolve.html#a3d60964bbc6441f73c04fe702faba848" title="Interface to external channels. ">HSolve::initCinfo()</a>.</li>
<li>When the "target" field is set, it sets up its internal data structures using code inherited from <a class="el" href="classHSolveActive.html">HSolveActive</a>. At this point, it also converts all the original objects into zombies.</li>
</ol>
</li>
<li><a class="el" href="classHSolveActive.html">HSolveActive</a>: At setup time, when the "target" field of <a class="el" href="classHSolve.html">HSolve</a> is set, it triggers the <a class="el" href="classHSolveActive.html#abe1e04be095f6b2e77e0de5ff3c56b3d">HSolveActive::setup()</a> function. This function is encoded in <a class="el" href="HSolveActiveSetup_8cpp.html">HSolveActiveSetup.cpp</a>. It traverses the model using the <a class="el" href="classHSolveUtils.html">HSolveUtils</a> API, interrogates the model's structure, parameter and state, and sets up all the internal data-structures accordingly. At simulation time, <a class="el" href="classHSolveActive.html">HSolveActive</a> does the full-fledged calculations for a neuronal model with ion channels, calcium, synapses, etc.The entry point for these calculations is <a class="el" href="classHSolveActive.html#a2fa4c89fc57e5a3bf48933f1f71b331c" title="Equivalent to process. ">HSolveActive::step()</a>.</li>
<li><a class="el" href="classHSolvePassive.html">HSolvePassive</a>: This class does the compartmental calculations for passive neurons. Derives from <a class="el" href="classHinesMatrix.html">HinesMatrix</a>.</li>
<li><a class="el" href="classHinesMatrix.html">HinesMatrix</a>: This class stores the <a class="el" href="classHinesMatrix.html">HinesMatrix</a>.</li>
<li>Zombie*: These are the zombie classes. </li>
</ol>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Jan 2 2015 21:51:25 for MOOSE by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
