<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>MOOSE: Profiling</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">MOOSE
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Profiling </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="Introduction"></a>
Introduction</h1>
<p>It is possible to do profiling without altering any C++ implementation, and without writing any C++ testbed. Using Google's <a href="https://code.google.com/p/gperftools/" target="_blank">gperftools</a> combined with <a href="http://cython.org/">cython</a>, you can do C++ profiling by writing python script running the MOOSE functions in quetion.</p>
<p>First cython, gperftools, libc6-prof packages have to be installed. Secondly a cython wrapper should be made for three functions of gperftools. After that, moose may be recompiled with the 'profile' option. Lastly, the wrapper may be included into arbitrary python script, thus gperftools functions can be used.</p>
<h1><a class="anchor" id="PackageInstalltion"></a>
Package Installation</h1>
<ul>
<li>
<p class="startli">Cython:</p>
<pre class="fragment">~$ sudo apt-get install cython </pre><p class="endli"></p>
</li>
<li>
<p class="startli">gperftools: download it from <a href="https://code.google.com/p/gperftools/downloads/list" target="_blank">here</a>, then install it.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">libc6-prof:</p>
<pre class="fragment">~$ sudo apt-get install libc6-prof </pre><p class="endli"></p>
</li>
<li>
<p class="startli">kcachegrind (optional, for interpreting profiler output):</p>
<pre class="fragment">~$ sudo apt-get install kcachegrind </pre><p class="endli"></p>
</li>
</ul>
<h1><a class="anchor" id="CythonWrapper"></a>
Cython gperftools wrapper</h1>
<p>The simplest way to get the wrapper done is to write a cython script wrapping the gperftools functions and a python script that compiles the wrapped functions and link them to the gperftools library.</p>
<p>Let's call the cython script gperftools_wrapped.pyx:</p>
<pre class="fragment">cdef extern from "gperftools/profiler.h":
    int ProfilerStart(char* fname)
    void ProfilerStop()
    void ProfilerFlush()

def ProfStart(fname):
    return ProfilerStart(fname)

def ProfStop():
    ProfilerStop()

def ProfFlush():
    ProfilerFlush()</pre><p>Here we define a python function for each function of gperftools that we wrap. More functions can be wrapped for more custom profiling (see ProfilerStartWithOptions()).</p>
<p>The python compiler script may look something like this (setup.py):</p>
<pre class="fragment">from distutils.core import setup
from Cython.Build import cythonize

setup(
    name = 'gperftools_wrapped',
    ext_modules = cythonize("gperftools_wrapped.pyx"),
)</pre><p>Now the setup.py may be run with the following manner, adding the -lprofiler flag: </p>
<pre class="fragment">~$ python setup.py build_ext --inplace -lprofiler </pre><p>If everything went right now you should have gperftools_wrapped.c, gperftools_wrapped.so, and a build directory as result of the compilation.</p>
<p>Put gperftools_wrapped.so nearby your python testbed and import as gperftools_wrapped, so you can profile python C extensions. But (!) first the C extensions may be compiled using the -lprofiler flag.</p>
<h1><a class="anchor" id="MooseRecomp"></a>
Moose recompilation</h1>
<p>To profile moose, it should be recompiled with altering the Makefile setting BUILD:</p>
<pre class="fragment">BUILD=profile </pre><p>Essentially you should add the -lprofiler flag. So if the flags corresponding to the "profile" BUILD option does not include -lprofiler you should add it yourself (probably that is the case).</p>
<p>Flags to use for example:</p>
<pre class="fragment">CXXFLAGS  = -pg -lprofiler -fpermissive -fno-strict-aliasing -fPIC -Wall -Wno-long-long -pedantic -DUSE_GENESIS_PARSER </pre><p>You may only add the -lprofiler flag to the Makefile which compiles the C++ code you are interested in profiling (not tested). Then recompile moose.</p>
<h1><a class="anchor" id="ProfilingInAction"></a>
Profiling in action</h1>
<p>Before profiling one should always set the PYTHONPATH to the directory from where python picks up moose functions. To get the function names in your profiling, this should be done, whether it is already set in e.g. your .bashrc script. Example:</p>
<pre class="fragment">export PYTHONPATH=/path_to_moose/python/ </pre><p>To test profiling let's use an existing demo to check the runtime of <a class="el" href="classHSolve.html">HSolve</a> functions.</p>
<p>From the moose directory alter the script at Demos/traub_2005/py/test_hsolve_tcr.py. First import the wrapper we just made.</p>
<pre class="fragment">from gperftools_wrapped import * </pre><p>Then edit the testHSolve function, adding the wrapper functions:</p>
<pre class="fragment">    def testHSolve(self):
        ProfStart("hsolve.prof")
        self.schedule(simdt, plotdt, 'hsolve')
        self.runsim(simtime, pulsearray=pulsearray)
        self.savedata()
        ProfFlush()
        ProfStop()

    def testEE(self):
        pass
        #self.schedule(simdt, plotdt, 'ee')
        #self.runsim(simtime, pulsearray=pulsearray)
        #self.savedata()</pre><p>You can also comment out the testEE() function so the it will run faster.</p>
<p>After running the python script you should have a file named hsolve.prof. As you can see the string passed to ProfStart() determines the name of the profiler's output.</p>
<p>You can interpret the output using pprof, or if you installed kcachegrind. Note that for the 'program' parameter of pprof you should provide the _moose.so file inside /path_to_moose/python/moose/.</p>
<p>pprof text method:</p>
<pre class="fragment">~$ pprof --text /path_to_moose/python/moose/_moose.so hsolve.prof &gt; log
~$ less log
</pre><p>kcachegrind method:</p>
<pre class="fragment">~$ pprof --callgrind /path_to_moose/python/moose/_moose.so hsolve.prof &gt; output.callgrind
~$ kcachegrind output.callgrind
</pre><dl class="section author"><dt>Author</dt><dd>Viktor TÃ³th </dd></dl>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Jan 2 2015 21:51:25 for MOOSE by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
