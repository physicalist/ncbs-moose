<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>MOOSE: The Messaging System</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">MOOSE
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The Messaging System </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="Intro"></a>
Introduction</h1>
<p>The messaging system is central to the way moose works. Any understanding of the internals of moose must start with the messaging framework.</p>
<p>The framework essentially allows "moose objects" to "send" messages to or "receive" messages from each other. The following sections expand on the exact implementation of sending and receiving messages, both from a C++ programmer's perspective as well as from a python programmer's perspective.</p>
<p>(TODO: add more messaging system philosophy)</p>
<h1><a class="anchor" id="mooseObjects"></a>
Moose Objects</h1>
<p>A moose object is an instance of a moose class. A moose class is a C++ class that has a <a class="el" href="classCinfo.html">Cinfo</a> object representing it. <a class="el" href="classCinfo.html">Cinfo</a> objects are class descriptors. They describe the fields that classes want to expose in the python script in one way or another.</p>
<p>The fields that go into python are of three main types:</p>
<ul>
<li>Value fields: the sort that are like a simple variable that can be changed as and when desired - a "public" data element on a python class</li>
<li>Source fields: A source of messages. These fields can be used to send data to other moose objects</li>
<li>Destination fields: A destination for messages. These are fields that act as recepients of messages sent by source fields.</li>
</ul>
<p>In an ordinary C++ class, there is no distinction between different class members. In order to create the aforementioned classification of class members into various field types, there is a need to use <a class="el" href="classFinfo.html">Finfo</a> objects: the so-called "field descriptors".</p>
<p>Consider the example of the simple class, Example:</p>
<pre class="fragment"> class Example {

 private:
     int x_;

 public:

     int getX() { return x_; }
     void setX( int x ) { x_ = x; }

     static const Cinfo *initCinfo() {
         static ValueFinfo&lt; Example, int &gt; x(
             "x",
             "An example field of an example class",
             &amp;Example::getX,
             &amp;Example::setX
         );
         static Finfo *exampleFinfos[] = { &amp;x };
         static Cinfo exampleCinfo(
             "Example",              // The name of the class in python
             Neutral::initCinfo(),   // TODO
             exampleFinfos,          // The array of Finfos created above
             1,                      // The number of Finfos
             new Dinfo&lt; Example &gt;()  // The class Example itself (FIXME ?)
     }

 }; </pre><p>Example shows you how you can create a value field. The initCinfo function here could have been called anything. It merely does the job of creating a <a class="el" href="classCinfo.html">Cinfo</a> object for the class. This is typically the case throughout moose. The <a class="el" href="classValueFinfo.html">ValueFinfo</a> object takes the class and the value's data type as template arguments, as shown. The initialization parameters are the name of the class member in python, the python docstring for the member and the addresses of the set and get functions used to access and modify the said value field.</p>
<p>But this alone is not enough. We have not yet created a <a class="el" href="classCinfo.html">Cinfo</a> <em>object</em> corresponding to this class. The <a class="el" href="classCinfo.html">Cinfo</a> object can be created in any of the files in the project, but it is usually created below the respective initCinfo function's definition. In this case, the object would be instantiated in a manner such as: </p>
<pre class="fragment"> static const Cinfo *exampleCinfo = Example::Cinfo(); </pre><p>This creates a <a class="el" href="classCinfo.html">Cinfo</a> object in the same file which is picked up by pymoose during compilation. Example is then made into an actual python class, accessible as moose.Example (provided that the directory under which these files are located is included in the main moose Makefile for compilation).</p>
<p>Note the importance of the "static" storage class specifier throughout this example.</p>
<p>Any class that has such a <a class="el" href="classCinfo.html">Cinfo</a> object described after it is considered to have been upgraded from a C++ class into a moose class.</p>
<p>It helps to have moose classes rather than C++ classes, because they provide a mechanism for introspection. For example, you can "ask" a moose object what its fields are. In fact, you can be even more specific and ask it to tell you only its value fields, source fields or destination fields.</p>
<h1><a class="anchor" id="sendingAndReceiving"></a>
Sending and receiving</h1>
<p>Sending and receiving messages in moose is accomplished through source and destination fields respectively. Once again, in order to designate a field as a source or destination field, it is necessary to use an <a class="el" href="classFinfo.html">Finfo</a> object.</p>
<p>The trials directory in the moose buildQ branch gives an excellent example of how to define simple source and destination Finfos.</p>
<pre class="fragment"> static SrcFinfo1&lt; double &gt; XOut( "XOut", "Value of random field X" );
 static DestFinfo handleX( "handleX",
         "Prints out X as and when it is received",
         new OpFunc1&lt; Receiver, double &gt;( &amp;Receiver::handleX )
 ); </pre><p>The source <a class="el" href="classFinfo.html">Finfo</a> is defined within a function that returns the address of the <a class="el" href="classFinfo.html">Finfo</a>. This is done because the same function is called in order to use the send() method of the source <a class="el" href="classFinfo.html">Finfo</a> that activates the sending of the message.</p>
<p>Notice that the source <a class="el" href="classFinfo.html">Finfo</a> is defined using the class "SrcFinfo1". The 1 indicates the number of variables being sent across. It is also the number of template arguments that have to be supplied and the number of extra parameters that go into the send() call. Sender::process() calls XOut()-&gt;send( e, pthreadIndexInGroup, X_ ). The X_ here is the variable being sent across. There's only one variable being sent, which is why we use an <a class="el" href="classSrcFinfo1.html">SrcFinfo1</a>. For another example, one can take a look at <a class="el" href="Compartment_8cpp.html">biophysics/Compartment.cpp</a>. Here, we need to send out two variables, so we use an <a class="el" href="classSrcFinfo2.html">SrcFinfo2</a> class. The sending function is defined as <a class="el" href="Compartment_8cpp.html#a1e548232b53842a22f215378e73d0d6c">raxialOut()</a>-&gt;send( e, pthreadIndexInGroup, Ra_, Vm_ ) to send out Ra_ and Vm_. In such a manner, upto six variables can be sent out in a single message.</p>
<p>The destination field is defined by a handler function which is held by the <a class="el" href="classOpFunc.html">OpFunc</a> class. The handler should be able to take as many variables as the source field sends out. So <a class="el" href="classOpFunc.html">OpFunc</a> can also take upto six template arguments. The actual handler function (be it handleX or handleRaxial) takes these many values as arguments (in the same order).</p>
<p>More information regarding OpFunc-like classes can be found in the Programmers Guide.</p>
<h1><a class="anchor" id="creatingConnections"></a>
Creating connections</h1>
<p>So far we have taken a look at how sources and destinations are made, but not at how they are actually connected. There is as yet no information designating which destinations a source field is supposed to send messages to when their send() method is called.</p>
<p>In order to find out more about how connections are made (and also about how pymoose can be used) read the pymoose walkthrough in the user documentation. In the trials example, we created the connection in test_trials.py with: </p>
<pre class="fragment"> conn = moose.connect(s, 'XOut', r, 'handleX') </pre><p> In order to accomplish this in C++, one would do something like: </p>
<pre class="fragment"> MsgId mid = shell-&gt;doAddMsg("Single", srcId, "XOut", destId,
                             "handleX" ); </pre><p> This requires the definition of a shell variable which handles the creation of paths in the moose system. Read the Application Programming Interface guide for more information on paths. For now, try to digest the fact that the following lines create a shell object that can be used to make objects on paths - a neutral object and a compartment object have been created as a demonstration. </p>
<pre class="fragment"> Shell* shell = reinterpret_cast&lt; Shell* &gt;( Id().eref().data() );
 Id n = shell-&gt;doCreate( "Neutral", Id(), "n" );
 Id c = shell-&gt;doCreate( "Compartment", n, "c" ); </pre><p> This creates a <a class="el" href="classNeutral.html">Neutral</a> object at /n and a Compartment object at /n/c/. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Jan 2 2015 21:51:25 for MOOSE by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
